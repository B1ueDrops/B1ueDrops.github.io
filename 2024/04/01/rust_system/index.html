<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Rust基础系统总结 | B1ueDrops</title>
  <meta name="keywords" content="">
  <meta name="description" content="Rust基础系统总结 | B1ueDrops">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="向阳而生, 喜欢聪明的人.">
<meta property="og:type" content="website">
<meta property="og:title" content="B1ueDrops">
<meta property="og:url" content="https://b1uedrops.github.io/about.html">
<meta property="og:site_name" content="B1ueDrops">
<meta property="og:description" content="向阳而生, 喜欢聪明的人.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-02-09T08:49:59.399Z">
<meta property="article:modified_time" content="2024-02-09T08:49:59.394Z">
<meta property="article:author" content="B1ueDrops">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpeg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpeg"/>
</a>
<div class="author">
    <span>B1ueDrops</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/B1ueDrops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:bluedrops@yeah.net"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2381446488&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(46)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="编程语言">
            
            编程语言
            <small>(6)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="并发编程">
            
            并发编程
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="工具/环境">
            
            工具/环境
            <small>(7)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="计算机网络">
            
            计算机网络
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="金融知识">
            
            金融知识
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="脑机接口">
            
            脑机接口
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="软件工程">
            
            软件工程
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="社会技能">
            
            社会技能
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(9)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="信号处理">
            
            信号处理
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="AI">
            
            AI
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="English">
            
            English
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="46">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All 社会技能 "
           href="/2024/04/26/secure_drive/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="安全驾驶知识">安全驾驶知识</span>
            <span class="post-date" title="2024-04-26 19:53:53">2024/04/26</span>
        </a>
        
        
        <a  class="All 金融知识 "
           href="/2024/04/26/quant/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基金及量化投资">基金及量化投资</span>
            <span class="post-date" title="2024-04-26 13:42:05">2024/04/26</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2024/04/21/network_tcp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TCP的相关知识">TCP的相关知识</span>
            <span class="post-date" title="2024-04-21 15:16:42">2024/04/21</span>
        </a>
        
        
        <a  class="All 信号处理 "
           href="/2024/04/20/fourier/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="傅立叶级数分解">傅立叶级数分解</span>
            <span class="post-date" title="2024-04-20 18:36:34">2024/04/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/04/14/two_pointer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="双指针系列">双指针系列</span>
            <span class="post-date" title="2024-04-14 19:46:01">2024/04/14</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/13/practical-rust/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust原理与实战记录">Rust原理与实战记录</span>
            <span class="post-date" title="2024-04-13 17:05:26">2024/04/13</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/04/13/ai_basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AI的一些基础概念">AI的一些基础概念</span>
            <span class="post-date" title="2024-04-13 16:43:26">2024/04/13</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/04/13/transformer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="简单理解Transformer">简单理解Transformer</span>
            <span class="post-date" title="2024-04-13 12:36:45">2024/04/13</span>
        </a>
        
        
        <a  class="All 并发编程 "
           href="/2024/04/12/rust_async/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust的异步编程">Rust的异步编程</span>
            <span class="post-date" title="2024-04-12 14:09:37">2024/04/12</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2024/04/08/network_http/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="应用层-HTTP协议">应用层-HTTP协议</span>
            <span class="post-date" title="2024-04-08 19:44:40">2024/04/08</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/07/python_many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python用到什么学什么">Python用到什么学什么</span>
            <span class="post-date" title="2024-04-07 10:46:59">2024/04/07</span>
        </a>
        
        
        <a  class="All 脑机接口 "
           href="/2024/04/06/eeg_device/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="脑电的原理">脑电的原理</span>
            <span class="post-date" title="2024-04-06 10:35:04">2024/04/06</span>
        </a>
        
        
        <a  class="All 社会技能 "
           href="/2024/04/05/eq/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="培养高情商的一些策略">培养高情商的一些策略</span>
            <span class="post-date" title="2024-04-05 10:25:28">2024/04/05</span>
        </a>
        
        
        <a  class="All 并发编程 "
           href="/2024/04/04/rust_multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust多线程编程模型">Rust多线程编程模型</span>
            <span class="post-date" title="2024-04-04 12:38:50">2024/04/04</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/02/rust_leetcode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="用Rust实现Leetcode算法题">用Rust实现Leetcode算法题</span>
            <span class="post-date" title="2024-04-02 12:59:13">2024/04/02</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/01/rust_system/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust基础系统总结">Rust基础系统总结</span>
            <span class="post-date" title="2024-04-01 19:24:52">2024/04/01</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/30/binary-tree/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二叉树/二叉搜索树全系列">二叉树/二叉搜索树全系列</span>
            <span class="post-date" title="2024-03-30 17:07:34">2024/03/30</span>
        </a>
        
        
        <a  class="All 并发编程 "
           href="/2024/03/30/multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多进程/多线程编程模型">多进程/多线程编程模型</span>
            <span class="post-date" title="2024-03-30 16:47:20">2024/03/30</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/30/profile/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="软件的性能分析">软件的性能分析</span>
            <span class="post-date" title="2024-03-30 13:49:01">2024/03/30</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/28/linkedlist/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="链表系列">链表系列</span>
            <span class="post-date" title="2024-03-28 09:53:10">2024/03/28</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/24/data-struct/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构系列">数据结构系列</span>
            <span class="post-date" title="2024-03-24 14:10:22">2024/03/24</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/23/vscode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="vscode插件配置">vscode插件配置</span>
            <span class="post-date" title="2024-03-23 15:50:58">2024/03/23</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/command_line/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shell脚本现用现学">Shell脚本现用现学</span>
            <span class="post-date" title="2024-03-22 12:50:32">2024/03/22</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/cpp-many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++之用到什么学什么">C++之用到什么学什么</span>
            <span class="post-date" title="2024-03-22 11:31:11">2024/03/22</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/21/prefix-sum-sub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前缀和差分系列">前缀和差分系列</span>
            <span class="post-date" title="2024-03-21 15:44:29">2024/03/21</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/linear-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性动态规划系列">线性动态规划系列</span>
            <span class="post-date" title="2024-03-20 18:11:22">2024/03/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/tree-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="树形动态规划系列">树形动态规划系列</span>
            <span class="post-date" title="2024-03-20 18:10:56">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-method/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Methodology">英语科技论文写作模型-Methodology</span>
            <span class="post-date" title="2024-03-20 16:53:17">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-abstract/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Abstract">英语科技论文写作模型-Abstract</span>
            <span class="post-date" title="2024-03-20 16:49:54">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-conclusion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Conclusion">英语科技论文写作模型-Conclusion</span>
            <span class="post-date" title="2024-03-20 16:49:46">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-results/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Results">英语科技论文写作模型-Results</span>
            <span class="post-date" title="2024-03-20 16:49:31">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/19/sci-writing-introduction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Introduction">英语科技论文写作模型-Introduction</span>
            <span class="post-date" title="2024-03-19 10:16:07">2024/03/19</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/03/10/ai-cnn/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CNN的一些基础知识">CNN的一些基础知识</span>
            <span class="post-date" title="2024-03-10 15:57:42">2024/03/10</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/10/catalan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡特兰数系列">卡特兰数系列</span>
            <span class="post-date" title="2024-03-10 12:47:19">2024/03/10</span>
        </a>
        
        
        <a  class="All 并发编程 "
           href="/2024/03/05/concurrent_sketch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="并发编程的概述">并发编程的概述</span>
            <span class="post-date" title="2024-03-05 15:00:50">2024/03/05</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/03/knapsack/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="背包问题的模板总结">背包问题的模板总结</span>
            <span class="post-date" title="2024-03-03 16:22:21">2024/03/03</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/02/jetbrains/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jetbrains系列IDE的配置">Jetbrains系列IDE的配置</span>
            <span class="post-date" title="2024-03-02 19:00:15">2024/03/02</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/02/tmux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tmux键位配置">tmux键位配置</span>
            <span class="post-date" title="2024-03-02 13:16:32">2024/03/02</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/01/clean_code/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码整洁之道">代码整洁之道</span>
            <span class="post-date" title="2024-03-01 14:30:08">2024/03/01</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/01/software_rule/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面向对象设计的基本原则">面向对象设计的基本原则</span>
            <span class="post-date" title="2024-03-01 14:30:02">2024/03/01</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/29/lazygit/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="lazygit的一些常见用法">lazygit的一些常见用法</span>
            <span class="post-date" title="2024-02-29 17:44:04">2024/02/29</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/28/yabai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="yabai窗口管理器键位配置">yabai窗口管理器键位配置</span>
            <span class="post-date" title="2024-02-28 13:01:35">2024/02/28</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/27/joshuto/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="joshuto的键位配置">joshuto的键位配置</span>
            <span class="post-date" title="2024-02-27 19:43:49">2024/02/27</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/02/26/behaviour_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="行为型的设计模式">行为型的设计模式</span>
            <span class="post-date" title="2024-02-26 20:11:27">2024/02/26</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/26/vimium/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Chrome中vimium键位">Chrome中vimium键位</span>
            <span class="post-date" title="2024-02-26 20:03:26">2024/02/26</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/02/25/build_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创建型的设计模式">创建型的设计模式</span>
            <span class="post-date" title="2024-02-25 15:27:36">2024/02/25</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-rust_system" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Rust基础系统总结</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="编程语言">编程语言</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-04-11 10:36:29'>2024-04-01 19:24</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8Snippets"><span class="toc-text">常用Snippets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98-%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">可变&#x2F;不可变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-text">所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BA%A6%E6%9D%9F"><span class="toc-text">生命周期约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trait"><span class="toc-text">trait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BA%A6%E6%9D%9F-1"><span class="toc-text">生命周期约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-text">软件工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90"><span class="toc-text">权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="toc-text">多文件编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">集合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector"><span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Option"><span class="toc-text">Option</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E5%BC%82%E5%B8%B8"><span class="toc-text">不可恢复异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%81%A2%E5%A4%8D%E5%BC%82%E5%B8%B8"><span class="toc-text">可恢复异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">单元测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-text">高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84trait"><span class="toc-text">常见的trait</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Clone"><span class="toc-text">Clone</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Copy"><span class="toc-text">Copy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#From"><span class="toc-text">From</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Deref"><span class="toc-text">Deref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Drop"><span class="toc-text">Drop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Box"><span class="toc-text">Box&lt;T&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rc"><span class="toc-text">Rc&lt;T&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arc"><span class="toc-text">Arc&lt;T&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RefCell"><span class="toc-text">RefCell&lt;T&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F"><span class="toc-text">宏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#derive"><span class="toc-text">derive</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="常用Snippets"><a href="#常用Snippets" class="headerlink" title="常用Snippets"></a>常用Snippets</h2><ul>
<li><p>只遍历元素:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// item不是引用,此处会发生所有权转移</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> arr &#123;<br>  <br>&#125;<br><span class="hljs-comment">// item是不可变引用</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;arr &#123;<br>  <br>&#125;<br><span class="hljs-comment">// item是可变引用</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> arr &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>同时遍历下标和元素:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 注意这里的i类型是usize</span><br><span class="hljs-comment">// 注意这里的v是不可变引用</span><br><span class="hljs-comment">// a可以是vec</span><br><span class="hljs-keyword">for</span> (i, v) <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第&#123;&#125;个元素是&#123;&#125;&quot;</span>, i + <span class="hljs-number">1</span>, v);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>遍历String的每一个字符:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> (i, c) <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>  <span class="hljs-comment">// c是char类型</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>找String的第<code>i</code>个字符: </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// x是char</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = s.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">nth</span>(i).<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure></li>
<li><p>通过循环修改原数组</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 因为要对原数组进行修改, 所以数组定义成可变mut</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">arr</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-comment">// 对数组进行可变的借用, item类型是&amp;mut i32</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> arr &#123;<br>    *item = *item + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>把一个数组中的内容放到另一个数组:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-built_in">vec!</span>[<br>    <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1&quot;</span>),<br>    <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;2&quot;</span>),<br>    <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;3&quot;</span>)<br>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">b</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = <span class="hljs-built_in">vec!</span>[];<br><br><span class="hljs-comment">// to_owned方法可以给引用调, 用来拷贝引用指向的对象, 并且返回值是拷贝后的对象, 而不是引用</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;a &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, item.<span class="hljs-title function_ invoke__">to_owned</span>());<br>  	b.<span class="hljs-title function_ invoke__">push</span>(item.<span class="hljs-title function_ invoke__">to_owned</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="可变-不可变"><a href="#可变-不可变" class="headerlink" title="可变&#x2F;不可变"></a>可变&#x2F;不可变</h3><ul>
<li>对于一个变量, 如果你要修改它的值, 那么它就是可变变量, 需要用<code>mut</code>.<ul>
<li>例如: 数组中修改元素的值, 结构体中修改成员变量的值.</li>
</ul>
</li>
</ul>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><ul>
<li>所有权是指<strong>数据的所有权</strong>.</li>
<li>所有权的核心: <strong>对于一个数据, 仅可能通过一个变量去访问, 也就是一个存储在内存中的值, 有且仅有一个ownership</strong>.<ul>
<li>如果出现赋值语句, 函数参数传递, 或者函数返回值返回, 都会发生所有权的转移, 原变量会失效.</li>
<li>但是对于实现了Copy trait的类型来说, 如果出现上述情况, <strong>不会发生所有权转移</strong>, 实现Copy trait的类型有:<ul>
<li>基本类型.</li>
<li>基本类型组成的元组.</li>
<li><strong>不可变引用<code>&amp;T</code></strong>.</li>
</ul>
</li>
</ul>
</li>
<li>可以使用<code>clone()</code>函数对堆上的数据进行<strong>深拷贝</strong>, 但是<code>clone()</code>会极大拖慢程序性能.</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p>引用是对所有权的<strong>租借(borrow)</strong>, 也是实现<strong>浅拷贝</strong>的方法.</p>
<ul>
<li>无论你如何使用引用, 都不会改变原变量的所有权, 只有使用权.</li>
</ul>
</li>
<li><p>引用是个变量, 本身具有可变&#x2F;不可变两种类型:</p>
<ul>
<li>可变引用: 这个引用变量可以租借其他变量所有权.</li>
<li>不可变引用: 这个引用变量只能租借一个变量的所有权.</li>
</ul>
</li>
<li><p>引用有两种内置类型, 注意这里的类型与上面描述不同, type的描述词是<code>&amp;T</code>和<code>&amp;mut T</code>:</p>
<ul>
<li><p><code>&amp;T</code>: 不可以通过修改引用来改变原变量的值.</p>
</li>
<li><p><code>&amp;mut T</code>: 可以通过修改引用修改原变量的值.</p>
<ul>
<li>原变量必须是可变变量(有<code>mut</code>).</li>
</ul>
</li>
<li><p><strong>租借规则:</strong></p>
<ul>
<li>对于一个变量, 在同一作用域内, 允许有多个<code>&amp;T</code>引用, 但是<strong>只能有一个<code>&amp;mut T</code>引用.</strong></li>
<li>对于一个变量, 在同一作用域内, 不允许同时出现<code>&amp;T</code>和<code>&amp;mut T</code>引用.</li>
</ul>
</li>
<li><p>引用本质上也是一种<strong>非基本类型</strong>, 并且<strong>实现了Deref trait</strong>, 因此能和普通变量一样使用, 不需要显式解引用. </p>
<ul>
<li>对一个引用调用<code>clone()</code>, 本质上是克隆的原始变量.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>变量在定义时, 生命周期就会固定.</li>
<li><strong>堆上的数据是否被释放, 取决于它的所有权在哪个变量</strong>, 变量生命周期过了就会被释放.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>;<br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br>        <span class="hljs-comment">// String::from本来在这个生命周期会被释放, 但是值的所有权转移后, 就不会被释放.</span><br>        b = a;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>最基本的生命周期约束:</strong> 使用引用租借一个变量的所有权时, 需要保证<strong>引用指向的原变量的生命周期, 小于等于依赖引用指向的所有变量的生命周期</strong>.</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="生命周期约束"><a href="#生命周期约束" class="headerlink" title="生命周期约束"></a>生命周期约束</h3><ul>
<li><p>可以对引用进行生命周期的标注, 例如: <code>first: &amp;&#39;a i32</code>:</p>
<ul>
<li>标注的意思是: <strong>这个引用所指向的原变量的生命周期是<code>a</code></strong>.</li>
</ul>
</li>
<li><p><strong>函数的生命周期约束: <strong>如果函数返回值是</strong>引用</strong>, 那么<strong>返回值引用指向的原变量</strong>的生命周期, 要小于等于所有参数生命周期的最小值.</p>
<ul>
<li>函数如果返回引用, 那么这个引用只有两个来源:<ul>
<li>函数参数.</li>
<li>函数内部新的变量的引用, 这种情况会出现Dangling Reference, 需要返回原变量, 让其发生所有权转移.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Rust消除生命周期标注的规则:</strong></p>
<ul>
<li><p>对于输入的每个引用, 都会分配一个生命周期标注:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 分配前</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(x: &amp;<span class="hljs-type">i32</span>, y: &amp;<span class="hljs-type">i32</span>);<br><span class="hljs-comment">// 分配后</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>, y: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">i32</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果只有一个输入生命周期<code>a</code>, 并且函数返回值是引用, 那么返回值引用的生命周期也会被标注为<code>a</code>.</p>
</li>
<li><p>如果存在多个输入生命周期, 但是其中有一个引用是<code>&amp;self</code>或者是<code>&amp;mut self</code>, 并且函数返回值是引用, 那么返回值引用的生命周期会和<code>&amp;self/&amp;mut self</code>标注的一样.</p>
</li>
</ul>
</li>
<li><p>如果实际情况不符合生命周期标注规则, 那么就需要<strong>手动标注</strong>, 否则编译不通过:</p>
<ul>
<li><p>最典型情况: 函数参数有多个引用类型, 并且返回值也是引用类型.</p>
<ul>
<li><p>为什么这种情况需要标注?</p>
<ul>
<li><p>因为返回值引用必然依赖于函数参数引用, 但是可能函数在运行时才能决定依赖于那些参数引用, 例如这个例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 函数用来返回长度较长的字符串的引用, 具体返回哪个参数取决于运行时</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>(x: &amp;<span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>怎么标注?</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>  	<span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>表示返回值的引用指向的原变量的生命周期, 和函数参数<code>x, y</code>具有相同的生命周期, 这才能通过编译.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>最长的生命周期:</strong> <code>&#39;static</code>, 这个生命周期能和程序活得一样久.</p>
<ul>
<li>字符串字面值: <code>let s: &amp;&#39;static str = &quot;我没啥优点，就是活得久，嘿嘿&quot;;</code></li>
</ul>
</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul>
<li><p>定义语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 最后没有;</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    active: <span class="hljs-type">bool</span>,<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    sign_in_count: <span class="hljs-type">u64</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>方法的定义语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Circle</span> &#123;<br>    x: <span class="hljs-type">f64</span>,<br>    y: <span class="hljs-type">f64</span>,<br>    radius: <span class="hljs-type">f64</span>,<br>&#125;<br><span class="hljs-comment">// 同样没有;</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Circle</span> &#123;<br>  <span class="hljs-comment">// 调用: Circle::new</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: <span class="hljs-type">f64</span>, y: <span class="hljs-type">f64</span>, radius: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> Circle &#123;<br>        Circle &#123;<br>            x: x,<br>            y: y,<br>            radius: radius,<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>        std::<span class="hljs-type">f64</span>::consts::PI * (<span class="hljs-keyword">self</span>.radius * <span class="hljs-keyword">self</span>.radius)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>方法有三种类型:</p>
<ul>
<li>**关联方法(associated method): **参数中不含任何<code>self</code>, 可以用来写构造方法.</li>
<li>参数带<code>&amp;self</code>的方法: 不可以修改成员变量.</li>
<li>参数带<code>&amp;mut self</code>的方法: 可以修改成员变量.</li>
</ul>
</li>
<li><p>**构造方法: **一般用<code>new</code>当作方法名, Rust中<code>new</code>不是关键字.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Self代指原结构体类型</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(width: <span class="hljs-type">u32</span>, height: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123; width, height &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Getter方法:</strong> 方法名称和私有成员变量同名.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">width</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.width;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 函数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>&#125;<br><br><span class="hljs-comment">// 结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T,U&gt; &#123;<br>    x: T,<br>    y: U,<br>&#125;<br><span class="hljs-comment">// 方法</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">x</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.x<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 针对具体类型实现方法</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Point</span>&lt;<span class="hljs-type">f32</span>&gt; &#123;<br><br>&#125;<br><span class="hljs-comment">// trait</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt;;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h3><ul>
<li><p>trait类似于接口, 用来把行为标准和具体实现解耦, 减少冗余代码.</p>
</li>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">// impl &lt;trait&gt; for &lt;struct&gt;</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>trait中也可以定义默认方法(与接口不同之处), 实现trait的人可以选择重载.</p>
</li>
<li><p>**孤儿规则(orphan rule, OR): **</p>
<ul>
<li>如果要实现外部定义的trait, 需要将其导入作用域.</li>
<li>可以对自定义类型实现外部trait.</li>
<li>可以对外部类型实现当前作用域自定义的trait.</li>
<li>不允许对外部类型实现外部trait.</li>
<li>**一句话概括: **如果要为类型A实现trait T, 那么A和T的定义至少要有一个在当前作用域.</li>
</ul>
</li>
<li><p>**特征约束: **</p>
<ul>
<li><p>场景: 你传入了一个泛型, 你要求这个泛型必须实现某几个trait.</p>
</li>
<li><p>语法: </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// T: Summary表示T这个泛型必须实现Summary trait</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;<br>    <br>&#125;<br><span class="hljs-comment">// 表示T必须同时实现Summary和Display</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;<br><br><span class="hljs-comment">// where防止特征约束过于复杂</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span><br>    <span class="hljs-keyword">where</span> T: Display + <span class="hljs-built_in">Clone</span>,<br>          U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span><br>&#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>语法糖: <code>impl &lt;trait&gt;</code>表示实现了<code>trait</code>特征的类型</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// impl Summary表示所有实现了Summary trait的结构体</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item: &amp;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span>) &#123;<br><br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item: &amp;(<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> + Display)) &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>语法糖的限制:</strong> 返回值约束</p>
<ul>
<li>这样写是正确的, 但是, Rust要求函数的返回值只能是一种类型, 假设类型<code>A</code>和类型<code>B</code>都实现了Summary trait, 你写的函数既可能返回<code>A</code>, 又可能返回<code>B</code>, 这种是不允许的, 因为返回值要求只能返回一种类型.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">returns_summarizable</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>特征对象:</strong></p>
<ul>
<li><p>场景: 假设你有一个数组, 这个数组中需要存储所有实现了某个trait的对象.</p>
</li>
<li><p>语法: 使用<code>&amp;dyn trait</code>或者<code>Box&lt;dyn trait&gt;</code>表示实现了trait的对象, 这个类型本质上是引用类型.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Screen</span> &#123;<br>  <span class="hljs-comment">// components存储所有实现了Draw trait的对象的引用</span><br>    <span class="hljs-keyword">pub</span> components: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Draw&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>为什么不定义成<code>dyn trait</code> ?</strong></p>
<ul>
<li>因为特征对象本质上是<strong>动态类型</strong>, 编译时不知道大小, 而Rust要求对象在编译时知道大小.</li>
<li>但是<code>&amp;dyn trait</code>和<code>Box&lt;dyn trait&gt;</code>是在编译时就知道大小的.</li>
</ul>
</li>
<li><p><strong>特征对象的限制:</strong></p>
<ul>
<li>并不是所有的trait都能有特征对象, 只有对象安全的trait才可以有.</li>
</ul>
</li>
<li><p>对象安全的定义:</p>
<ul>
<li><p>trait中方法中没有泛型参数.</p>
</li>
<li><p>trait方法中返回值没有<code>Self</code>.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>特征继承(super trait)</strong></p>
<ul>
<li><p>场景: 有时候在写一个trait时, 需要继承其他trait的功能才能完成这个trait.</p>
</li>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// OutlinePrint: Display表示, 要实现OutlinePrint这个trait, 你还得先实现Display</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">OutlinePrint</span>: Display &#123;<br>&#125;<br><span class="hljs-comment">// 同时继承多个trait</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">CacheableItem</span>: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Default</span> + fmt::<span class="hljs-built_in">Debug</span> + Decodable + Encodable &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>关联类型(associated type)</strong></p>
<ul>
<li><p>场景: 在trait中想使用泛型的场景都可以用关联类型代替, 这样就不用再使用泛型时都带上<code>&lt;T&gt;</code>, 提高可读性</p>
</li>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 泛型</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt;;<br>&#125;<br><span class="hljs-comment">// 实现trait</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Iterator</span>&lt;T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &lt;T&gt; &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>&lt;T&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt; &#123;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 关联类型</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br><span class="hljs-comment">// 实现trait, 这时候就不用写</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">u32</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>完全限定语法:</strong></p>
<ul>
<li><p>场景: 为一个结构体实现了多个trait, 但是多个trait中有方法重名, 怎么告诉编译器调哪一个?</p>
</li>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">&lt;Type <span class="hljs-keyword">as</span> Trait&gt;::<span class="hljs-title function_ invoke__">function</span>(receiver_if_method, next_arg, ...);<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>  	<span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dog</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>      <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Spot&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>) &#123;   <br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>      <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;puppy&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>    <br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 调Animal Trait中的baby_name方法</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, &lt;Dog <span class="hljs-keyword">as</span> Animal&gt;::<span class="hljs-title function_ invoke__">baby_name</span>());<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Dog &#123;&#125;;<br>  <span class="hljs-comment">// 默认调用impl Dog中的fly方法</span><br>  a.<span class="hljs-title function_ invoke__">fly</span>();<br>  <span class="hljs-comment">// 如果要调用Animal中的fly</span><br>  &lt;Dog <span class="hljs-keyword">as</span> Animal&gt;::<span class="hljs-title function_ invoke__">fly</span>(&amp;a);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="生命周期约束-1"><a href="#生命周期约束-1" class="headerlink" title="生命周期约束"></a>生命周期约束</h3><ul>
<li><p><strong>结构体的生命周期约束:</strong> 结构体的成员变量如果存在引用, 那么结构体的生命周期一定要小于等于引用成员变量所指向的原变量的生命周期.</p>
</li>
<li><p><strong>生命周期标注语法:</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcept</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">level</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>生命周期约束语法:</strong> <code>&#39;a:&#39;b</code>表示<code>&#39;b</code>这个生命周期小于<code>&#39;a</code>这个生命周期.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 假设有这样一个方法</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>: <span class="hljs-symbol">&#x27;b</span>, <span class="hljs-symbol">&#x27;b</span>&gt; ImportantExcept&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">announce_and_return_part</span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>, announcement: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);<br>        <span class="hljs-keyword">self</span>.part<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>生命周期标注如果和泛型出现在一起, 可以同时写到<code>&lt;&gt;</code>中: <code>fn longest_with_an_announcement&lt;&#39;a, T&gt;</code></p>
</li>
</ul>
<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><ul>
<li>Rust中, 很多元素都有权限, 这个权限是相对于其他mod说明的:<ul>
<li><code>pub</code>权限: 可以在其他mod中导入元素.</li>
<li>不写<code>pub</code>: 就是private权限, 只可以在当前mod中使用权限.</li>
</ul>
</li>
</ul>
<h3 id="多文件编程"><a href="#多文件编程" class="headerlink" title="多文件编程"></a>多文件编程</h3><p>rust中, 一个package可以分为多个binary crate和至多一个libary crate:</p>
<ul>
<li>crate root是<code>src/main.rs</code>和<code>src/lib.rs</code>.</li>
<li>rust编译器只能看到crate root.</li>
</ul>
<p>一般来说, 你需要在crate root中声明依赖的模块, 然后再用<code>use</code>导入元素:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// src/main.rs或src/lib.rs</span><br><span class="hljs-comment">// 声明crate(main.rs)所依赖的module</span><br><span class="hljs-keyword">mod</span> A;<br><span class="hljs-keyword">mod</span> B;<br><span class="hljs-keyword">mod</span> C;<br><br><span class="hljs-keyword">use</span> A::funcA;<br></code></pre></td></tr></table></figure>

<p>对于模块, 你只需要理解下面几点:</p>
<ul>
<li>一个<code>rs</code>文件是一个模块, 其中的元素你可以用<code>pub</code>导出.</li>
<li>一个文件夹中, 你需要创建<code>mod.rs</code>, 然后在其中用<code>pub mod XX;</code>来将文件夹中的所有rust文件导出.</li>
<li>在crate root中需要用<code>mod XX;</code>声明上级模块.</li>
<li>如果在子模块中需要导入上级模块的东西, 可以用<code>use package名字::XXX</code>导入.</li>
<li><code>super</code>关键字指的是父模块.</li>
</ul>
<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul>
<li><p>创建Vector:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">vec</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">vec</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure>
</li>
<li><p>插入元素: <code>push</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong><font color="red">注意, <code>push</code>会对<code>vec</code>进行可变借用, 如果前面存在不可变借用, 那么就会报错:</font></strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 报错代码</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = &amp;v[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 对v的不可变借用</span><br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// 对v的可变借用</span><br></code></pre></td></tr></table></figure>

<ul>
<li>由于Vector是变长数组, 如果你<code>push</code>, 会有可能导致扩容, 扩容后, Rust会新分配一块内存, 然后把原来的数据拷贝, 那么之前的不可变引用就会报错.</li>
</ul>
</li>
</ul>
</li>
<li><p>索引元素:</p>
<ul>
<li>第一种, 用下标, <code>vec[2]</code>, 但是如果越界, 程序会发生<code>panic</code>.</li>
<li>第二种, 用<code>vec.get(2)</code>, 返回<code>Option&lt;&amp;&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li><p>导入包:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br></code></pre></td></tr></table></figure>


</li>
<li><p>创建HashMap:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">hash</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>()<br></code></pre></td></tr></table></figure>
</li>
<li><p>插入值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 注意, 这里x, y会发生所有权转移</span><br><span class="hljs-comment">// 如果插入引用, 需要保证HashMap的生命周期小于等于插入的引用的生命周期</span><br>hash.<span class="hljs-title function_ invoke__">insert</span>(x, y)<br></code></pre></td></tr></table></figure>
</li>
<li><p>根据key判断是否存在键值对:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 传入的Key是&amp;</span><br><span class="hljs-comment">// 返回值是Option&lt;&amp;&gt;</span><br>hash.<span class="hljs-title function_ invoke__">get</span>(&lt;你的key&gt;)<br><br><span class="hljs-comment">// x是原值</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(&amp;x) = hash.<span class="hljs-title function_ invoke__">get</span>(&amp;y) &#123;<br>   <br>&#125;<br><span class="hljs-comment">// x是&amp;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = hash.<span class="hljs-title function_ invoke__">get</span>(&amp;y) &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>遍历key, value:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// key, value不是&amp;</span><br><span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> scores &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);<br>&#125;<br><br><span class="hljs-comment">// key, value是&amp;</span><br><span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> &amp;scores &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);<br>&#125;<br><br><span class="hljs-comment">// key是&amp;, value是&amp;mut, 可以修改原值</span><br><span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> scores &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>查询已有值, 若不存在则插入新值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// x, y都是值, 不是&amp;, 返回&amp;mut, 可以根据z修改哈希表中的值</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = scores.<span class="hljs-title function_ invoke__">entry</span>(x).<span class="hljs-title function_ invoke__">or_insert</span>(y);<br>*z = *z + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><ul>
<li><p>闭包是一种匿名函数, 可以赋值给变量, 也可以捕获闭包之外的作用域中的值.</p>
</li>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = |x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>  	x + y<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>闭包的一个用法: 简化冗余代码.</strong></p>
<ul>
<li>假设你有一个目的, 有很多种方法实现, 目的留出接口, 那么实现就可以用不同的闭包.</li>
</ul>
</li>
<li><p>闭包可以进行自动类型推导, 但是函数必须要标注类型.</p>
</li>
<li><p><strong>闭包作为结构体成员变量:</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cacher</span>&lt;T&gt; <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>  query: T,<br>  value: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt;<br>&#125;<br><span class="hljs-comment">// 调用闭包</span><br>(<span class="hljs-keyword">self</span>.query)(args);<br></code></pre></td></tr></table></figure>

<ul>
<li>其中, <code>Fn(u32) -&gt; u32</code>是一个特征用来规范闭包类型<code>T</code>.</li>
</ul>
</li>
<li><p><strong>闭包作为函数参数:</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;F&gt;(func: F) <span class="hljs-keyword">where</span> F: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>闭包的特征, 以及所有权问题:</strong></p>
<ul>
<li><p>闭包能够捕获闭包作用域之外的值, 但是这个捕获就涉及所有权转移的问题.</p>
</li>
<li><p><strong>特征1: <code>FnOnce</code></strong>: 实现这个trait的闭包, 会把参数&#x2F;里面捕获的变量的所有权拿走, 因此只能运行一次.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;F&gt;(func: F) <span class="hljs-keyword">where</span> F: <span class="hljs-title function_ invoke__">FnOnce</span>(<span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>, &#123;<br>  <span class="hljs-title function_ invoke__">func</span>(<span class="hljs-number">3</span>);<br>  <span class="hljs-comment">// 调用第二次时, x的所有权已经被第一个闭包拿走, 第二个闭包没权利用x</span><br>  <span class="hljs-title function_ invoke__">func</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> 	<span class="hljs-keyword">let</span> <span class="hljs-variable">closure</span> = |z| &#123; z == x.<span class="hljs-title function_ invoke__">len</span>() &#125;;<br>  <span class="hljs-title function_ invoke__">fn_once</span>(closure);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong><code>FnOnce</code>加<code>Copy</code></strong>: 如果闭包trait实现了Copy trait, 那么在使用时, 就会调用闭包的拷贝, 可以运行多次.</p>
<ul>
<li>注意, 如果一个闭包实现了Copy trait, 那么不管其中捕获的变量是否实现Copy trait, 都没有关系, 都会调用闭包的拷贝.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;F&gt;(func: F) <span class="hljs-keyword">where</span> F: <span class="hljs-title function_ invoke__">FnOnce</span>(<span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> + <span class="hljs-built_in">Copy</span>, &#123;<br>  <span class="hljs-title function_ invoke__">func</span>(<span class="hljs-number">3</span>);<br>  <span class="hljs-comment">// 调用第二次时, x的所有权已经被第一个闭包拿走, 第二个闭包没权利用x</span><br>  <span class="hljs-title function_ invoke__">func</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> 	<span class="hljs-keyword">let</span> <span class="hljs-variable">closure</span> = |z| &#123; z == x.<span class="hljs-title function_ invoke__">len</span>() &#125;;<br>  <span class="hljs-title function_ invoke__">fn_once</span>(closure);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>如何判断一个闭包是否实现了<code>Copy</code>特征?</strong><ul>
<li>如果一个闭包捕获的所有变量的类型都实现了<code>Copy</code>特征, 那么这个闭包就会自动实现Copy特征.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>特征2: <code>FnMut</code></strong>: 以可变引用<code>&amp;mut</code>的方式捕获</p>
<ul>
<li><p>只要闭包声明时带了<code>mut</code>, 那么这个闭包就默认实现了<code>FnMut</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">update_string</span> = |<span class="hljs-type">str</span>| s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-type">str</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>特征3: <code>Fn</code></strong>: 以不可变借用<code>&amp;</code>的方式捕获:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">update_string</span> =  |<span class="hljs-type">str</span>| s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-type">str</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>闭包实现特征的规律:</strong></p>
<ul>
<li>一个闭包可以同时实现多个特征.</li>
<li>所有闭包默认实现<code>FnOnce</code>, 保证一个闭包至少可以被调用一次.</li>
<li>如果闭包内没有对捕获变量进行改变, 那么实现了<code>Fn</code>特征.</li>
<li>如果闭包把捕获变量的所有权改变了, 那么实现了<code>FnMut</code>特征.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>move</code>关键字:</strong> 定义在参数列表<code>||</code>之前, 表示闭包会强制把捕获变量的所有权拿走, 适用于<strong>闭包生命周期大于捕获变量生命周期</strong>.</p>
</li>
</ul>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul>
<li><p>Rust中迭代器是懒加载的, 只创建不使用迭代器不会产生任何性能损失.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// 将数组转化为迭代器</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v_iter</span> = v.<span class="hljs-title function_ invoke__">iter</span>();<br><span class="hljs-comment">// 使用迭代器遍历</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> v_iter &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>所有迭代器默认实现了<code>Iterator</code> trait</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>  <span class="hljs-comment">// next方法返回下一个元素, 并且会消耗掉, 没有元素后就会返回None</span><br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>还有一个trait叫<code>IntoIterator</code>, 如果一个类型实现了这个trait, 那么它就可以通过<code>iter()/into_iter()</code>变成迭代器.</li>
</ul>
</li>
<li><p>迭代器和所有权问题: 将数组转换为迭代器时, 有可能会把数组中元素的所有权给拿走, 具体分为以下三种情况:</p>
<ul>
<li><p>不可变借用: <code>iter()</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">values</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">v</span> <span class="hljs-keyword">in</span> values.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>  <span class="hljs-comment">// v的类型是&amp;T</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可变借用: <code>iter_mut()</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 原数组必须可变</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">values</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter_mut</span>() &#123;<br>  <span class="hljs-comment">// item类型是&amp;mut T, 可以修改原数组元素</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>会夺走元素所有权: <code>into_iter()</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">values</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">into_iter</span>() &#123;<br>  <span class="hljs-comment">// item的类型是T</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>迭代器适配器&#x2F;迭代器消费者:</strong></p>
<ul>
<li><p>迭代器适配器非常强大, 可以把一个迭代器转换成你想要的迭代器, 然后配合迭代器消费者, 可以将一个数组转换成你想要的数组.</p>
</li>
<li><p><code>map + collect</code> : <code>map</code>方法可以传入一个闭包, 对原数组进行操作, 然后用迭代器消费者<code>collect()</code>转换成数组.</p>
<ul>
<li>注意, 使用<code>collect()</code>必须进行类型标注, <code>_</code>表示让编译器进行标注.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// 把v中的元素加1, 放到新数组中, 对原数组所有权没有影响</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x + <span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>filter + collect</code>: <code>filter</code>方法可以传入一个返回bool的闭包, 如果返回值是true, 那么会在原数组中保留, 否则删除.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// 筛选原数组中的偶数, 注意v2中的元素是&amp;i32类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span>: <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-type">i32</span>&gt; = v.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">filter</span>(|x| **x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h4><ul>
<li><p>如果一个值的类型是<code>Option&lt;T&gt;</code>, 说明这个值可能是<code>None</code>.</p>
</li>
<li><p><code>Option&lt;T&gt;</code>的定义:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>  <span class="hljs-title function_ invoke__">Some</span>(T),<br>  <span class="hljs-literal">None</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>构造<code>Option&lt;T&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">value</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">non_value</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>拆解<code>Option&lt;T&gt;</code></p>
<ul>
<li><p>如果确定不会是None, 可以用<code>unwrap()</code>, 如果出现None, 程序就会<code>panic</code>.</p>
</li>
<li><p>用match表达式:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> some_value &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(value) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value is &#123;&#125;&quot;</span>, value),<br>    <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;There is no value&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>用<code>if let</code>表达式:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">value</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(value) = some_value &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value is &#123;&#125;&quot;</span>, value);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// None</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;There is no value&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>判断是否有值&#x2F;None:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">value1</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">value2</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;some_value is &#123;&#125;&quot;</span>, value1.<span class="hljs-title function_ invoke__">is_some</span>());<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;none_value is &#123;&#125;&quot;</span>, value2.<span class="hljs-title function_ invoke__">is_none</span>());<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="不可恢复异常"><a href="#不可恢复异常" class="headerlink" title="不可恢复异常"></a>不可恢复异常</h4><ul>
<li><p><code>panic!()</code>如果在main线程中, 会直接停止main线程, 但是在子线程中panic不会让main线程挂, 因此不要让main线程承担大多数任务.</p>
</li>
<li><p><code>panic</code>有两种退出模式:</p>
<ul>
<li><p>栈回溯(backtrace): 退出时打印调用栈, 可以用在开发环境.</p>
</li>
<li><p>终止(abort): 直接退出, 适合生产环境, 能减少编译出的二进制文件大小.</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[profile.release]</span><br><span class="hljs-attr">panic</span> = <span class="hljs-string">&#x27;abort&#x27;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="可恢复异常"><a href="#可恢复异常" class="headerlink" title="可恢复异常"></a>可恢复异常</h4><p>一般来说, 可能存在异常的函数返回值都是<code>Result&lt;T, E&gt;</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个类型之后可以用<code>unwrap()</code>或者<code>expect()</code>处理, 两者类似, 区别在于<code>expect()</code>可以接受一个字符串, panic后打印这个字符串信息:</p>
<ul>
<li><code>unwrap/expect</code>: 如果成功, 直接返回返回值, 如果失败, 直接<code>panic</code>.</li>
<li>这是异常处理最快的方法.</li>
</ul>
<blockquote>
<p>处理方法1: Match表达式</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>) &#123;<br>    	<span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>    	<span class="hljs-title function_ invoke__">Error</span>(error) =&gt; &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Cannot read file&quot;</span>);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以在<code>Error</code>后再用Match表达式处理:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::ErrorKind;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-keyword">match</span> error.<span class="hljs-title function_ invoke__">kind</span>() &#123;<br>            ErrorKind::NotFound =&gt; <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>) &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(fc) =&gt; fc,<br>                <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),<br>            &#125;,<br>            other_error =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),<br>        &#125;,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可以直接不处理, 向上传播异常:</p>
<ul>
<li>原函数需要返回<code>Result&lt;T, E&gt;</code></li>
<li>match表达式如果是<code>Error</code>, 需要<code>return Err(error)</code>.</li>
</ul>
<p>Rust提供了专门的宏<code>?</code>来简化传播异常的写法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个写法就等价于:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>) &#123;<br>      	<span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>      	<span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-title function_ invoke__">Err</span>(error)<br>  	&#125;;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>?相比于match表达式, 还有另一种好处.</p>
</blockquote>
<ul>
<li><p><code>?</code>传播的异常, 返回的本质上是<code>Box&lt;dyn std::error:Error&gt;</code>类型.</p>
</li>
<li><p>在一个系统中, 你可以基于<code>Error</code>, 自定义异常.</p>
</li>
<li><p>自定义的异常需要实现<code>From</code> trait中的<code>from</code>函数, 用来转换到更大的异常类型.</p>
</li>
<li><p>这样, 在使用<code>?</code>时, rust就会根据你的签名, 自动给你转换到对应级别的异常.</p>
</li>
<li><p><code>Option&lt;T&gt;</code>也支持<code>?</code>.</p>
</li>
</ul>
<p>如果在main函数中使用了<code>?</code>, 那么main函数的签名需要改动:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>rust TDD (test driven development)的一般流程是:</p>
<ul>
<li><p>在<code>src</code>同级目录下创建<code>test</code>.</p>
</li>
<li><p>里面创建很多个rust文件, 随便起名.</p>
</li>
<li><p>每个文件的格式如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br><br>    <span class="hljs-keyword">use</span> package名字::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">two_result</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">query</span> = <span class="hljs-string">&quot;duct&quot;</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">contents</span> = <span class="hljs-string">&quot;Rust:\nSafe duct\nniubi duct&quot;</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;Safe duct&quot;</span>, <span class="hljs-string">&quot;niubi duct&quot;</span>], <span class="hljs-title function_ invoke__">search</span>(query, contents))<br>    &#125;<br>  	<br>  	<span class="hljs-meta">#[test]</span><br>  <span class="hljs-comment">// 新的测试</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>#[cfg(test)]</code>表示只有在<code>cargo test</code>时才运行测试.</li>
<li><code>#[test]</code>表示单元测试.</li>
</ul>
</li>
<li><p>错误信息采用<code>eprintln</code>输出到<code>stderr</code>.</p>
</li>
</ul>
<p>之后只要运行<code>cargo test</code>就会运行所有单元测试.</p>
<p><font color="red">上述函数中, 无法对私有函数进行测试</font>, 如果真要对私有函数进行测试, 需要把测试函数<code>#[test]</code>写私有函数定义的地方.</p>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="常见的trait"><a href="#常见的trait" class="headerlink" title="常见的trait"></a>常见的trait</h3><h4 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h4><p>Clone接口的定义是:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Clone</span>: <span class="hljs-built_in">Sized</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clone</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>调用<code>clone</code>方法返回原对象的深拷贝.</li>
</ul>
<p>Clone trait可以和<code>derive</code>一起使用:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Clone)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h4><p>文档: <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/marker/trait.Copy.html">https://doc.rust-lang.org/std/marker/trait.Copy.html</a></p>
<h4 id="From"><a href="#From" class="headerlink" title="From"></a>From</h4><p>From trait定义了一种类型如何转换成另一种类型:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::convert::<span class="hljs-built_in">From</span>;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Number</span> &#123;<br>    value: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;<span class="hljs-type">i32</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Number</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(item: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Number &#123; value: item &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 用from方法转换</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">num</span> = Number::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-number">30</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;My number is &#123;:?&#125;&quot;</span>, num);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>有时候<code>from</code>也会当做构造方法.</li>
</ul>
<h4 id="Deref"><a href="#Deref" class="headerlink" title="Deref"></a>Deref</h4><p>Deref是一个有关于解引用的trait.</p>
<p>假设我有一个结构体:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt;(T);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">MyBox</span>(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在, 你可以为这个结构体实现<code>Deref</code> 这个trait, 来让你能<code>*</code>一个结构体引用.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>  <span class="hljs-comment">// &amp;self是结构体引用类型, 在这个函数中, 你要通过这个结构体引用, find一个基本类型的引用, 然后返回</span><br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>    &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>本质上, <code>deref</code>会把一个结构体引用, 转换成一个基本类型引用.</p>
<p>实现&#96;&#96;deref<code>后, 你再</code><em><code>一个结构体引用</code>x<code>, 就等价于</code></em>(x.deref())&#96;</p>
<blockquote>
<p>自动deref机制</p>
</blockquote>
<p>看这段代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(s: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>));<br>    <span class="hljs-title function_ invoke__">display</span>(&amp;s)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于<code>&amp;s</code>, 它会被连续<code>deref</code> , 直到转换成<code>&amp;str</code>为止.</p>
<p>在Rust中, 引用类型其实不用你手动<code>*</code>才能访问值, 例如你有一个结构体引用, 你不用<code>(*x).name</code>才能访问成员, 而是直接用<code>x.name</code>就可以, 背后的机制就是<code>deref trait</code>.</p>
<h4 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h4><p>Drop是一个<code>trait</code>, 如果一个结构体实现了<code>Drop</code>, 那么它的生命周期结束之后, 就会自动调用<code>drop</code>方法实现收尾工作, rust就是因为这个才可以不实现<code>GC</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">XXX</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是, 在这段代码中, <code>drop</code>的参数是<code>&amp;mut self</code>, 就表示一个结构体调用<code>drop</code>函数后, 它的所有权没有被收走.</p>
<ul>
<li>因此, 你不可以对一个结构体<code>x</code>显示地调用<code>x.drop()</code>函数.</li>
</ul>
<p>但是, 有些场景下, 你需要提前释放某些资源, 例如互斥锁等, 这个时候可以使用<code>std::prelude::drop</code>函数.</p>
<p>这个函数签名是:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>&lt;T&gt;(_x: T)<br></code></pre></td></tr></table></figure>

<p>会直接把所有权拿走, 调用完这个函数, 如果在下面再使用原变量, 就会编译错误.</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="Box"><a href="#Box" class="headerlink" title="Box&lt;T&gt;"></a>Box&lt;T&gt;</h4><p>Box指针本质上还是引用类型, 只是这个引用会把你原本的数据放到堆上, 然后再给你返回一个引用.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// a数据存在3上</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>

<p>如果你想打印<code>a</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a);<br></code></pre></td></tr></table></figure>

<p>这时可以打印, 并且不会报错的, 因为<code>a</code>会隐式调用<code>deref</code>进行解引用.</p>
<p>但是如果你想拿这个值做运算:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>这就会报错, 正确写法是<code>let b = *a + 1</code>, 这个时候需要手动调用<code>deref</code>.</p>
<p><font color="red">注意: Box指针会导致所有权的转移</font>, <code>Box::new(xxx)</code>之后, <code>xxx</code>的所有权会转移到接收变量中.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello, world&quot;</span>);<br>    <span class="hljs-comment">// s在这里被转移给a</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(s);<br>    <span class="hljs-comment">// 报错！此处继续尝试将 s 转移给 b</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Box指针有一个非常有效的应用场景:</strong></p>
<ul>
<li>在Rust中, 编译器要求类型的大小必须是固定的.</li>
<li>但是有些类型是无法在编译时期知道大小的, 例如递归的类型定义.</li>
<li>这时, 可以将递归的成员变量转换成<code>Box&lt;T&gt;</code>指针类型.</li>
</ul>
<p>例如, 如果你想用一个数组, 存储所有实现了某一个<code>trait</code>的对象(动态类型), 就需要用到<code>Box</code>指针, 例子如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Draw</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">draw</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><span class="hljs-comment">// 下面Button和Select都实现了Draw这个trait</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Button</span> &#123;<br>    id: <span class="hljs-type">u32</span><br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Draw</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">draw</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Button &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.id);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Select</span> &#123;<br>    id: <span class="hljs-type">u32</span><br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Draw</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Select</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">draw</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Select &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.id)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  	<span class="hljs-comment">// 定义类型时需要加上dyn, 因为实现trait的对象都是一个动态类型</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">elems</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Draw&gt;&gt; = <span class="hljs-built_in">vec!</span>[ <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Button &#123;id:<span class="hljs-number">1</span>&#125;), <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Select &#123;id: <span class="hljs-number">1</span>&#125;) ];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">e</span> <span class="hljs-keyword">in</span> elems &#123;<br>        e.<span class="hljs-title function_ invoke__">draw</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果你要从Box指针数组中取出元素时, 你需要解两次引用, 例如下面这个例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = <span class="hljs-built_in">vec!</span>[ <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>), <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">2</span>) ];<br>    <span class="hljs-comment">// 注意, 这里必须取引用, 否则会发生所有权转移</span><br>    <span class="hljs-keyword">let</span> (first, second) = (&amp;arr[<span class="hljs-number">0</span>], &amp;arr[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 第一次将&amp;Box&lt;i32&gt;转成Box&lt;i32&gt;, 第二次将Box&lt;i32&gt;转成i32</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = **first + **second;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Rc"><a href="#Rc" class="headerlink" title="Rc&lt;T&gt;"></a>Rc&lt;T&gt;</h4><p>Rc&lt;T&gt;可以在单线程环境下, 创建一个数据的多个<strong>不可变引用</strong>, 并且提供了如下功能:</p>
<ul>
<li>实现了<code>Deref</code>和<code>Drop</code>.</li>
<li>提供了引用计数(reference counting), 一旦数据的引用计数是0, 就会自动释放.</li>
</ul>
<p>用法如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  	<span class="hljs-comment">// 用Rc::new创建一个数据的引用, 类型是Rc&lt;String&gt;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>));<br>  <br>  	<span class="hljs-comment">// 用Rc::clone创建数据的新的不可变引用, 这个clone是浅拷贝, 性能比较高</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a);<br>  	<span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a);<br>  <br>		<span class="hljs-comment">// 用Rc::strong_count输出变量的计数</span><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">3</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>    <span class="hljs-built_in">assert_eq!</span>(Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a), Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;b));<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Arc"><a href="#Arc" class="headerlink" title="Arc&lt;T&gt;"></a>Arc&lt;T&gt;</h4><p>Arc&lt;T&gt;可以在多线程环境下, 实现多个线程拥有同一个数据的多个不可变引用, 和<code>Rc&lt;T&gt;</code>的API完全相同.</p>
<ul>
<li>和<code>Rc&lt;T&gt;</code>不同之处在于, <code>Arc&lt;T&gt;</code>采用原子指令维护了引用计数, 会有一定的性能损耗.</li>
</ul>
<h4 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell&lt;T&gt;"></a>RefCell&lt;T&gt;</h4><ul>
<li><p>RefCell&lt;T&gt;提供了变量的内部可变性, 也就是<strong>原变量不可变的前提下, 你还可以创建可变引用</strong>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// val的类型是RefCell&lt;i32&gt;</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">val</span> = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">// 可变引用修改</span><br>*val.<span class="hljs-title function_ invoke__">borrow_mut</span>() += <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, *val.<span class="hljs-title function_ invoke__">borrow</span>());<br></code></pre></td></tr></table></figure>
</li>
<li><p>但是, <code>RefCell&lt;T&gt;</code>仍然要遵守rust的借用规则, 例如不能让可变引用和不可变引用共存.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 报错, 同时有了可变借用和不可变借用</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a.<span class="hljs-title function_ invoke__">borrow</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = a.<span class="hljs-title function_ invoke__">borrow_mut</span>();<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, b, c);<br></code></pre></td></tr></table></figure>
</li>
<li><p>一个例子: 假设你要为自己的类型实现trait, 但是trait中方法签名是<code>&amp;self</code>, 但是你就想在这个方法中修改成员变量, 这个时候需要将成员变量定义成<code>RefCell&lt;T&gt;</code>类型.</p>
</li>
<li><p><code>Rc + Refcell</code>: Rc可以实现一个数据有多个不可变引用, 结合<code>Refcell</code>可以通过不可变引用修改数据.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">10</span>));<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a1</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a2</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a);<br><br>*a1.<span class="hljs-title function_ invoke__">borrow_mut</span>() += <span class="hljs-number">1</span>;<br>*a2.<span class="hljs-title function_ invoke__">borrow_mut</span>() += <span class="hljs-number">2</span>;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a.<span class="hljs-title function_ invoke__">borrow</span>()); <span class="hljs-comment">//13</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>在Rust中, 宏可以分为两类:</p>
<ul>
<li>声明宏.</li>
<li>过程宏.</li>
</ul>
<h4 id="derive"><a href="#derive" class="headerlink" title="derive"></a>derive</h4><ul>
<li><p>derive一般用在结构体&#x2F;枚举中, 用来给结构体&#x2F;枚举快速实现某些trait.</p>
<ul>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>常见的trait:</p>
<ul>
<li><code>Debug</code>: 可以使用<code>println!(&quot;&#123;:?&#125;&quot;, my_struct)</code>打印结构体.</li>
<li><code>Clone</code>: 可以使用<code>my_struct.clone()</code>.</li>
<li><code>PartialEq</code>: 结构体具有部分相等性.</li>
<li><code>Eq</code>: 结构体具有完全相等性.</li>
</ul>
</li>
</ul>
</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 向阳而生, 喜欢聪明的人. </span>
    </div>
</article>







    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©B1ueDrops
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
