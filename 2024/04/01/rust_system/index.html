<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Rust系统总结 | B1ueDrops</title>
  <meta name="keywords" content="">
  <meta name="description" content="Rust系统总结 | B1ueDrops">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="向阳而生, 喜欢聪明的人.">
<meta property="og:type" content="website">
<meta property="og:title" content="B1ueDrops">
<meta property="og:url" content="https://b1uedrops.github.io/about.html">
<meta property="og:site_name" content="B1ueDrops">
<meta property="og:description" content="向阳而生, 喜欢聪明的人.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-02-09T08:49:59.399Z">
<meta property="article:modified_time" content="2024-02-09T08:49:59.394Z">
<meta property="article:author" content="B1ueDrops">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpeg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpeg"/>
</a>
<div class="author">
    <span>B1ueDrops</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/B1ueDrops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:bluedrops@yeah.net"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2381446488&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(34)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="编程语言">
            
            编程语言
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="并发编程">
            
            并发编程
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="工具/环境">
            
            工具/环境
            <small>(8)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="软件工程">
            
            软件工程
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(8)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="AI">
            
            AI
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="English">
            
            English
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="34">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All 编程语言 "
           href="/2024/04/02/rust_leetcode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="用Rust实现Leetcode Hot100">用Rust实现Leetcode Hot100</span>
            <span class="post-date" title="2024-04-02 12:59:13">2024/04/02</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/01/rust_system/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust系统总结">Rust系统总结</span>
            <span class="post-date" title="2024-04-01 19:24:52">2024/04/01</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/30/binary-tree/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二叉树/二叉搜索树全系列">二叉树/二叉搜索树全系列</span>
            <span class="post-date" title="2024-03-30 17:07:34">2024/03/30</span>
        </a>
        
        
        <a  class="All 并发编程 "
           href="/2024/03/30/multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多进程/多线程编程模型">多进程/多线程编程模型</span>
            <span class="post-date" title="2024-03-30 16:47:20">2024/03/30</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/30/profile/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="软件的性能分析">软件的性能分析</span>
            <span class="post-date" title="2024-03-30 13:49:01">2024/03/30</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/28/linkedlist/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="链表系列">链表系列</span>
            <span class="post-date" title="2024-03-28 09:53:10">2024/03/28</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/24/data-struct/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构系列">数据结构系列</span>
            <span class="post-date" title="2024-03-24 14:10:22">2024/03/24</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/23/vscode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="vscode插件配置">vscode插件配置</span>
            <span class="post-date" title="2024-03-23 15:50:58">2024/03/23</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/command_line/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shell脚本现用现学">Shell脚本现用现学</span>
            <span class="post-date" title="2024-03-22 12:50:32">2024/03/22</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/cpp-many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++之用到什么学什么">C++之用到什么学什么</span>
            <span class="post-date" title="2024-03-22 11:31:11">2024/03/22</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/21/prefix-sum-sub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前缀和差分系列">前缀和差分系列</span>
            <span class="post-date" title="2024-03-21 15:44:29">2024/03/21</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/linear-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性动态规划系列">线性动态规划系列</span>
            <span class="post-date" title="2024-03-20 18:11:22">2024/03/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/tree-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="树形动态规划系列">树形动态规划系列</span>
            <span class="post-date" title="2024-03-20 18:10:56">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-method/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Methodology">英语科技论文写作模型-Methodology</span>
            <span class="post-date" title="2024-03-20 16:53:17">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-abstract/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Abstract">英语科技论文写作模型-Abstract</span>
            <span class="post-date" title="2024-03-20 16:49:54">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-conclusion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Conclusion">英语科技论文写作模型-Conclusion</span>
            <span class="post-date" title="2024-03-20 16:49:46">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-results/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Results">英语科技论文写作模型-Results</span>
            <span class="post-date" title="2024-03-20 16:49:31">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/19/sci-writing-introduction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Introduction">英语科技论文写作模型-Introduction</span>
            <span class="post-date" title="2024-03-19 10:16:07">2024/03/19</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/03/10/ai-cnn/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CNN的一些基础知识">CNN的一些基础知识</span>
            <span class="post-date" title="2024-03-10 15:57:42">2024/03/10</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/10/catalan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡特兰数系列">卡特兰数系列</span>
            <span class="post-date" title="2024-03-10 12:47:19">2024/03/10</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/05/rust/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="rust阅读学习">rust阅读学习</span>
            <span class="post-date" title="2024-03-05 20:58:51">2024/03/05</span>
        </a>
        
        
        <a  class="All 并发编程 "
           href="/2024/03/05/concurrent_sketch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="并发编程的概述">并发编程的概述</span>
            <span class="post-date" title="2024-03-05 15:00:50">2024/03/05</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/03/knapsack/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="背包问题的模板总结">背包问题的模板总结</span>
            <span class="post-date" title="2024-03-03 16:22:21">2024/03/03</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/02/jetbrains/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jetbrains系列IDE的配置">Jetbrains系列IDE的配置</span>
            <span class="post-date" title="2024-03-02 19:00:15">2024/03/02</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/02/tmux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tmux键位配置">tmux键位配置</span>
            <span class="post-date" title="2024-03-02 13:16:32">2024/03/02</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/01/clean_code/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码整洁之道">代码整洁之道</span>
            <span class="post-date" title="2024-03-01 14:30:08">2024/03/01</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/01/software_rule/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面向对象设计的基本原则">面向对象设计的基本原则</span>
            <span class="post-date" title="2024-03-01 14:30:02">2024/03/01</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/29/lazygit/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="lazygit的一些常见用法">lazygit的一些常见用法</span>
            <span class="post-date" title="2024-02-29 17:44:04">2024/02/29</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/28/yabai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="yabai窗口管理器键位配置">yabai窗口管理器键位配置</span>
            <span class="post-date" title="2024-02-28 13:01:35">2024/02/28</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/27/joshuto/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="joshuto的键位配置">joshuto的键位配置</span>
            <span class="post-date" title="2024-02-27 19:43:49">2024/02/27</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/27/neovim/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Neovim/Nvchad键位配置">Neovim/Nvchad键位配置</span>
            <span class="post-date" title="2024-02-27 19:40:03">2024/02/27</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/02/26/behaviour_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="行为型的设计模式">行为型的设计模式</span>
            <span class="post-date" title="2024-02-26 20:11:27">2024/02/26</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/26/vimium/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Chrome中vimium键位">Chrome中vimium键位</span>
            <span class="post-date" title="2024-02-26 20:03:26">2024/02/26</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/02/25/build_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创建型的设计模式">创建型的设计模式</span>
            <span class="post-date" title="2024-02-25 15:27:36">2024/02/25</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-rust_system" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Rust系统总结</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="编程语言">编程语言</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-04-03 18:01:25'>2024-04-01 19:24</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8Snippets"><span class="toc-text">常用Snippets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88-%E5%A0%86"><span class="toc-text">栈&#x2F;堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98-%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-text">可变&#x2F;不可变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-text">所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text">引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BA%A6%E6%9D%9F"><span class="toc-text">生命周期约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trait"><span class="toc-text">trait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%BA%A6%E6%9D%9F-1"><span class="toc-text">生命周期约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-text">软件工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90"><span class="toc-text">权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="toc-text">多文件编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-text">集合类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vector"><span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Option"><span class="toc-text">Option</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">单元测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-text">高级特性</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="常用Snippets"><a href="#常用Snippets" class="headerlink" title="常用Snippets"></a>常用Snippets</h2><ul>
<li><p>只遍历元素:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// item不是引用,此处会发生所有权转移</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> arr &#123;<br>  <br>&#125;<br><span class="hljs-comment">// item是不可变引用</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;arr &#123;<br>  <br>&#125;<br><span class="hljs-comment">// item是可变引用</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> arr &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>同时遍历下标和元素:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 注意这里的i类型是usize</span><br><span class="hljs-comment">// 注意这里的v是不可变引用</span><br><span class="hljs-comment">// a可以是vec</span><br><span class="hljs-keyword">for</span> (i, v) <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;第&#123;&#125;个元素是&#123;&#125;&quot;</span>, i + <span class="hljs-number">1</span>, v);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>遍历String的每一个字符:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> (i, c) <span class="hljs-keyword">in</span> s.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>  <span class="hljs-comment">// c是char类型</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>找String的第<code>i</code>个字符: </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// x是char</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = s.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">nth</span>(i).<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure></li>
<li><p>通过循环修改原数组</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 因为要对原数组进行修改, 所以数组定义成可变mut</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">arr</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-comment">// 对数组进行可变的借用, item类型是&amp;mut i32</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> arr &#123;<br>    *item = *item + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>把一个数组中的内容放到另一个数组:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-built_in">vec!</span>[<br>    <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;1&quot;</span>),<br>    <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;2&quot;</span>),<br>    <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;3&quot;</span>)<br>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">b</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = <span class="hljs-built_in">vec!</span>[];<br><br><span class="hljs-comment">// to_owned方法可以给引用调, 用来拷贝引用指向的对象, 并且返回值是拷贝后的对象, 而不是引用</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;a &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, item.<span class="hljs-title function_ invoke__">to_owned</span>());<br>  	b.<span class="hljs-title function_ invoke__">push</span>(iten.<span class="hljs-title function_ invoke__">to_owned</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="栈-堆"><a href="#栈-堆" class="headerlink" title="栈&#x2F;堆"></a>栈&#x2F;堆</h3><ul>
<li><p>基本类型的值存储在线程的栈上, 因为基本类型大小固定, 并且栈的存储&#x2F;访问速度一般快.</p>
<ul>
<li>基本类型有: 整数, 浮点, 字符, 以及仅包含它们的元组.</li>
</ul>
</li>
<li><p>非基本类型存储在堆上, 因为非基本类型大小有可能在编译时期不固定, 在栈中会存储数据在堆中地址.</p>
</li>
</ul>
<h3 id="可变-不可变"><a href="#可变-不可变" class="headerlink" title="可变&#x2F;不可变"></a>可变&#x2F;不可变</h3><ul>
<li>对于一个变量, 如果你要修改它的值, 那么它就是可变变量, 需要用<code>mut</code>.<ul>
<li>例如: 数组中修改元素的值, 结构体中修改成员变量的值.</li>
</ul>
</li>
</ul>
<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><ul>
<li>所有权是指<strong>数据的所有权</strong>.</li>
<li>所有权的核心: <strong>对于一个数据, 仅可能通过一个变量去访问, 也就是一个存储在内存中的值, 有且仅有一个ownership</strong>.<ul>
<li>如果出现赋值语句, 函数参数传递, 或者函数返回值返回, 都会发生所有权的转移, 原变量会失效.</li>
<li>但是对于实现了Copy trait的类型来说, 如果出现上述情况, <strong>不会发生所有权转移</strong>, 实现Copy trait的类型有:<ul>
<li>基本类型.</li>
<li>基本类型组成的元组.</li>
<li><strong>不可变引用<code>&amp;T</code></strong>.</li>
</ul>
</li>
</ul>
</li>
<li>可以使用<code>clone()</code>函数对堆上的数据进行<strong>深拷贝</strong>, 但是<code>clone()</code>会极大拖慢程序性能.</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p>引用是对所有权的<strong>租借(borrow)</strong>, 也是实现<strong>浅拷贝</strong>的方法.</p>
<ul>
<li>无论你如何使用引用, 都不会改变原变量的所有权, 只有使用权.</li>
</ul>
</li>
<li><p>引用是个变量, 本身具有可变&#x2F;不可变两种类型:</p>
<ul>
<li>可变引用: 这个引用变量可以租借其他变量所有权.</li>
<li>不可变引用: 这个引用变量只能租借一个变量的所有权.</li>
</ul>
</li>
<li><p>引用有两种内置类型, 注意这里的类型与上面描述不同, type的描述词是<code>&amp;T</code>和<code>&amp;mut T</code>:</p>
<ul>
<li><p><code>&amp;T</code>: 不可以通过修改引用来改变原变量的值.</p>
</li>
<li><p><code>&amp;mut T</code>: 可以通过修改引用修改原变量的值.</p>
<ul>
<li>原变量必须是可变变量(有<code>mut</code>).</li>
</ul>
</li>
<li><p><strong>租借规则:</strong></p>
<ul>
<li>对于一个变量, 在同一作用域内, 允许有多个<code>&amp;T</code>引用, 但是<strong>只能有一个<code>&amp;mut T</code>引用.</strong></li>
<li>对于一个变量, 在同一作用域内, 不允许同时出现<code>&amp;T</code>和<code>&amp;mut T</code>引用.</li>
</ul>
</li>
<li><p>引用本质上也是一种<strong>非基本类型</strong>, 并且<strong>实现了Deref trait</strong>, 因此能和普通变量一样使用, 不需要显式解引用. </p>
<ul>
<li>对一个引用调用<code>clone()</code>, 本质上是克隆的原始变量.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>变量在定义时, 生命周期就会固定.</li>
<li><strong>堆上的数据是否被释放, 取决于它的所有权在哪个变量</strong>, 变量生命周期过了就会被释放.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>;<br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br>        <span class="hljs-comment">// String::from本来在这个生命周期会被释放, 但是值的所有权转移后, 就不会被释放.</span><br>        b = a;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>最基本的生命周期约束:</strong> 使用引用租借一个变量的所有权时, 需要保证<strong>引用指向的原变量的生命周期, 小于等于依赖引用指向的所有变量的生命周期</strong>.</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="生命周期约束"><a href="#生命周期约束" class="headerlink" title="生命周期约束"></a>生命周期约束</h3><ul>
<li><p>可以对引用进行生命周期的标注, 例如: <code>first: &amp;&#39;a i32</code>:</p>
<ul>
<li>标注的意思是: <strong>这个引用所指向的原变量的生命周期是<code>a</code></strong>.</li>
</ul>
</li>
<li><p><strong>函数的生命周期约束: <strong>如果函数返回值是</strong>引用</strong>, 那么<strong>返回值引用指向的原变量</strong>的生命周期, 要小于等于所有参数生命周期的最小值.</p>
<ul>
<li>函数如果返回引用, 那么这个引用只有两个来源:<ul>
<li>函数参数.</li>
<li>函数内部新的变量的引用, 这种情况会出现Dangling Reference, 需要返回原变量, 让其发生所有权转移.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Rust消除生命周期标注的规则:</strong></p>
<ul>
<li><p>对于输入的每个引用, 都会分配一个生命周期标注:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 分配前</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>(x: &amp;<span class="hljs-type">i32</span>, y: &amp;<span class="hljs-type">i32</span>);<br><span class="hljs-comment">// 分配后</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">foo</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>, y: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">i32</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果只有一个输入生命周期<code>a</code>, 并且函数返回值是引用, 那么返回值引用的生命周期也会被标注为<code>a</code>.</p>
</li>
<li><p>如果存在多个输入生命周期, 但是其中有一个引用是<code>&amp;self</code>或者是<code>&amp;mut self</code>, 并且函数返回值是引用, 那么返回值引用的生命周期会和<code>&amp;self/&amp;mut self</code>标注的一样.</p>
</li>
</ul>
</li>
<li><p>如果实际情况不符合生命周期标注规则, 那么就需要<strong>手动标注</strong>, 否则编译不通过:</p>
<ul>
<li><p>最典型情况: 函数参数有多个引用类型, 并且返回值也是引用类型.</p>
<ul>
<li><p>为什么这种情况需要标注?</p>
<ul>
<li><p>因为返回值引用必然依赖于函数参数引用, 但是可能函数在运行时才能决定依赖于那些参数引用, 例如这个例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 函数用来返回长度较长的字符串的引用, 具体返回哪个参数取决于运行时</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>(x: &amp;<span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>怎么标注?</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>  	<span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>表示返回值的引用指向的原变量的生命周期, 和函数参数<code>x, y</code>具有相同的生命周期, 这才能通过编译.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>最长的生命周期:</strong> <code>&#39;static</code>, 这个生命周期能和程序活得一样久.</p>
<ul>
<li>字符串字面值: <code>let s: &amp;&#39;static str = &quot;我没啥优点，就是活得久，嘿嘿&quot;;</code></li>
</ul>
</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul>
<li><p>定义语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 最后没有;</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>    active: <span class="hljs-type">bool</span>,<br>    username: <span class="hljs-type">String</span>,<br>    email: <span class="hljs-type">String</span>,<br>    sign_in_count: <span class="hljs-type">u64</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><p>方法的定义语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Circle</span> &#123;<br>    x: <span class="hljs-type">f64</span>,<br>    y: <span class="hljs-type">f64</span>,<br>    radius: <span class="hljs-type">f64</span>,<br>&#125;<br><span class="hljs-comment">// 同样没有;</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Circle</span> &#123;<br>  <span class="hljs-comment">// 调用: Circle::new</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: <span class="hljs-type">f64</span>, y: <span class="hljs-type">f64</span>, radius: <span class="hljs-type">f64</span>) <span class="hljs-punctuation">-&gt;</span> Circle &#123;<br>        Circle &#123;<br>            x: x,<br>            y: y,<br>            radius: radius,<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">f64</span> &#123;<br>        std::<span class="hljs-type">f64</span>::consts::PI * (<span class="hljs-keyword">self</span>.radius * <span class="hljs-keyword">self</span>.radius)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>方法有三种类型:</p>
<ul>
<li>**关联方法(associated method): **参数中不含任何<code>self</code>, 可以用来写构造方法.</li>
<li>参数带<code>&amp;self</code>的方法: 不可以修改成员变量.</li>
<li>参数带<code>&amp;mut self</code>的方法: 可以修改成员变量.</li>
</ul>
</li>
<li><p>**构造方法: **一般用<code>new</code>当作方法名, Rust中<code>new</code>不是关键字.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Self代指原结构体类型</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(width: <span class="hljs-type">u32</span>, height: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123; width, height &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>Getter方法:</strong> 方法名称和私有成员变量同名.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">width</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.width;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 函数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>&#125;<br><br><span class="hljs-comment">// 结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T,U&gt; &#123;<br>    x: T,<br>    y: U,<br>&#125;<br><span class="hljs-comment">// 方法</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">x</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.x<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 针对具体类型实现方法</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Point</span>&lt;<span class="hljs-type">f32</span>&gt; &#123;<br><br>&#125;<br><span class="hljs-comment">// trait</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt;;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h3><ul>
<li><p>trait类似于接口, 用来把行为标准和具体实现解耦, 减少冗余代码.</p>
</li>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Summary</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-comment">// impl &lt;trait&gt; for &lt;struct&gt;</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">summarize</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>trait中也可以定义默认方法(与接口不同之处), 实现trait的人可以选择重载.</p>
</li>
<li><p>**孤儿规则(orphan rule, OR): **</p>
<ul>
<li>如果要实现外部定义的trait, 需要将其导入作用域.</li>
<li>可以对自定义类型实现外部trait.</li>
<li>可以对外部类型实现当前作用域自定义的trait.</li>
<li>不允许对外部类型实现外部trait.</li>
<li>**一句话概括: **如果要为类型A实现trait T, 那么A和T的定义至少要有一个在当前作用域.</li>
</ul>
</li>
<li><p>**特征约束: **</p>
<ul>
<li><p>场景: 你传入了一个泛型, 你要求这个泛型必须实现某几个trait.</p>
</li>
<li><p>语法: </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// T: Summary表示T这个泛型必须实现Summary trait</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;<br>    <br>&#125;<br><span class="hljs-comment">// 表示T必须同时实现Summary和Display</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;<br><br><span class="hljs-comment">// where防止特征约束过于复杂</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span><br>    <span class="hljs-keyword">where</span> T: Display + <span class="hljs-built_in">Clone</span>,<br>          U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span><br>&#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>语法糖: <code>impl &lt;trait&gt;</code>表示实现了<code>trait</code>特征的类型</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// impl Summary表示所有实现了Summary trait的结构体</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item: &amp;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span>) &#123;<br><br>&#125;<br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item: &amp;(<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> + Display)) &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>语法糖的限制:</strong> 返回值约束</p>
<ul>
<li>这样写是正确的, 但是, Rust要求函数的返回值只能是一种类型, 假设类型<code>A</code>和类型<code>B</code>都实现了Summary trait, 你写的函数既可能返回<code>A</code>, 又可能返回<code>B</code>, 这种是不允许的, 因为返回值要求只能返回一种类型.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">returns_summarizable</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>特征对象:</strong></p>
<ul>
<li><p>场景: 假设你有一个数组, 这个数组中需要存储所有实现了某个trait的对象.</p>
</li>
<li><p>语法: 使用<code>&amp;dyn trait</code>或者<code>Box&lt;dyn trait&gt;</code>表示实现了trait的对象, 这个类型本质上是引用类型.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Screen</span> &#123;<br>  <span class="hljs-comment">// components存储所有实现了Draw trait的对象的引用</span><br>    <span class="hljs-keyword">pub</span> components: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Draw&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>为什么不定义成<code>dyn trait</code> ?</strong></p>
<ul>
<li>因为特征对象本质上是<strong>动态类型</strong>, 编译时不知道大小, 而Rust要求对象在编译时知道大小.</li>
<li>但是<code>&amp;dyn trait</code>和<code>Box&lt;dyn trait&gt;</code>是在编译时就知道大小的.</li>
</ul>
</li>
<li><p><strong>特征对象的限制:</strong></p>
<ul>
<li>并不是所有的trait都能有特征对象, 只有对象安全的trait才可以有.</li>
</ul>
</li>
<li><p>对象安全的定义:</p>
<ul>
<li><p>trait中方法中没有泛型参数.</p>
</li>
<li><p>trait方法中返回值没有<code>Self</code>.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>特征继承(super trait)</strong></p>
<ul>
<li><p>场景: 有时候在写一个trait时, 需要继承其他trait的功能才能完成这个trait.</p>
</li>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// OutlinePrint: Display表示, 要实现OutlinePrint这个trait, 你还得先实现Display</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">OutlinePrint</span>: Display &#123;<br>&#125;<br><span class="hljs-comment">// 同时继承多个trait</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">CacheableItem</span>: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Default</span> + fmt::<span class="hljs-built_in">Debug</span> + Decodable + Encodable &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>关联类型(associated type)</strong></p>
<ul>
<li><p>场景: 在trait中想使用泛型的场景都可以用关联类型代替, 这样就不用再使用泛型时都带上<code>&lt;T&gt;</code>, 提高可读性</p>
</li>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 泛型</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt;;<br>&#125;<br><span class="hljs-comment">// 实现trait</span><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Iterator</span>&lt;T&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &lt;T&gt; &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>&lt;T&gt;(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt; &#123;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 关联类型</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br><span class="hljs-comment">// 实现trait, 这时候就不用写</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">u32</span>;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>完全限定语法:</strong></p>
<ul>
<li><p>场景: 为一个结构体实现了多个trait, 但是多个trait中有方法重名, 怎么告诉编译器调哪一个?</p>
</li>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">&lt;Type <span class="hljs-keyword">as</span> Trait&gt;::<span class="hljs-title function_ invoke__">function</span>(receiver_if_method, next_arg, ...);<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>  	<span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dog</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>      <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Spot&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>) &#123;   <br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Dog</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">baby_name</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>      <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;puppy&quot;</span>)<br>  &#125;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fly</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>    <br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 调Animal Trait中的baby_name方法</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;A baby dog is called a &#123;&#125;&quot;</span>, &lt;Dog <span class="hljs-keyword">as</span> Animal&gt;::<span class="hljs-title function_ invoke__">baby_name</span>());<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Dog &#123;&#125;;<br>  <span class="hljs-comment">// 默认调用impl Dog中的fly方法</span><br>  a.<span class="hljs-title function_ invoke__">fly</span>();<br>  <span class="hljs-comment">// 如果要调用Animal中的fly</span><br>  &lt;Dog <span class="hljs-keyword">as</span> Animal&gt;::<span class="hljs-title function_ invoke__">fly</span>(&amp;a);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="生命周期约束-1"><a href="#生命周期约束-1" class="headerlink" title="生命周期约束"></a>生命周期约束</h3><ul>
<li><p><strong>结构体的生命周期约束:</strong> 结构体的成员变量如果存在引用, 那么结构体的生命周期一定要小于等于引用成员变量所指向的原变量的生命周期.</p>
</li>
<li><p><strong>生命周期标注语法:</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcept</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ImportantExcerpt&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">level</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>        <span class="hljs-number">3</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>生命周期约束语法:</strong> <code>&#39;a:&#39;b</code>表示<code>&#39;b</code>这个生命周期小于<code>&#39;a</code>这个生命周期.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 假设有这样一个方法</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>: <span class="hljs-symbol">&#x27;b</span>, <span class="hljs-symbol">&#x27;b</span>&gt; ImportantExcept&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">announce_and_return_part</span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>, announcement: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span> &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Attention please: &#123;&#125;&quot;</span>, announcement);<br>        <span class="hljs-keyword">self</span>.part<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>生命周期标注如果和泛型出现在一起, 可以同时写到<code>&lt;&gt;</code>中: <code>fn longest_with_an_announcement&lt;&#39;a, T&gt;</code></p>
</li>
</ul>
<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><ul>
<li>Rust中, 很多元素都有权限, 这个权限是相对于其他mod说明的:<ul>
<li><code>pub</code>权限: 可以在其他mod中导入元素.</li>
<li>不写<code>pub</code>: 就是private权限, 只可以在当前mod中使用权限.</li>
</ul>
</li>
</ul>
<h3 id="多文件编程"><a href="#多文件编程" class="headerlink" title="多文件编程"></a>多文件编程</h3><p>rust中, 一个package可以分为多个binary crate和至多一个libary crate:</p>
<ul>
<li>crate root是<code>src/main.rs</code>和<code>src/lib.rs</code>.</li>
<li>rust编译器只能看到crate root.</li>
</ul>
<p>一般来说, 你需要在crate root中声明依赖的模块, 然后再用<code>use</code>导入元素:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// src/main.rs或src/lib.rs</span><br><span class="hljs-comment">// 声明crate(main.rs)所依赖的module</span><br><span class="hljs-keyword">mod</span> A;<br><span class="hljs-keyword">mod</span> B;<br><span class="hljs-keyword">mod</span> C;<br><br><span class="hljs-keyword">use</span> A::funcA;<br></code></pre></td></tr></table></figure>

<p>对于模块, 你只需要理解下面几点:</p>
<ul>
<li>一个<code>rs</code>文件是一个模块, 其中的元素你可以用<code>pub</code>导出.</li>
<li>一个文件夹中, 你需要创建<code>mod.rs</code>, 然后在其中用<code>pub mod XX;</code>来将文件夹中的所有rust文件导出.</li>
<li>在crate root中需要用<code>mod XX;</code>声明上级模块.</li>
<li>如果在子模块中需要导入上级模块的东西, 可以用<code>use package名字::XXX</code>导入.</li>
</ul>
<h3 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h3><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul>
<li><p>创建Vector:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">vec</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">vec</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">from</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure>
</li>
<li><p>插入元素: <code>push</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">vec.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong><font color="red">注意, <code>push</code>会对<code>vec</code>进行可变借用, 如果前面存在不可变借用, 那么就会报错:</font></strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 报错代码</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = &amp;v[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 对v的不可变借用</span><br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// 对v的可变借用</span><br></code></pre></td></tr></table></figure>

<ul>
<li>由于Vector是变长数组, 如果你<code>push</code>, 会有可能导致扩容, 扩容后, Rust会新分配一块内存, 然后把原来的数据拷贝, 那么之前的不可变引用就会报错.</li>
</ul>
</li>
</ul>
</li>
<li><p>索引元素:</p>
<ul>
<li>第一种, 用下标, <code>vec[2]</code>, 但是如果越界, 程序会发生<code>panic</code>.</li>
<li>第二种, 用<code>vec.get(2)</code>, 返回<code>Option&lt;&amp;&gt;</code></li>
</ul>
</li>
</ul>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li><p>导入包:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br></code></pre></td></tr></table></figure>


</li>
<li><p>创建HashMap:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">hash</span> = HashMap::<span class="hljs-title function_ invoke__">new</span>()<br></code></pre></td></tr></table></figure>
</li>
<li><p>插入值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 注意, 这里x, y会发生所有权转移</span><br><span class="hljs-comment">// 如果插入引用, 需要保证HashMap的生命周期小于等于插入的引用的生命周期</span><br>hash.<span class="hljs-title function_ invoke__">insert</span>(x, y)<br></code></pre></td></tr></table></figure>
</li>
<li><p>根据key判断是否存在键值对:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 传入的Key是&amp;</span><br><span class="hljs-comment">// 返回值是Option&lt;&amp;&gt;</span><br>hash.<span class="hljs-title function_ invoke__">get</span>(&lt;你的key&gt;)<br><br><span class="hljs-comment">// x是原值</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(&amp;x) = hash.<span class="hljs-title function_ invoke__">get</span>(&amp;y) &#123;<br>   <br>&#125;<br><span class="hljs-comment">// x是&amp;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = hash.<span class="hljs-title function_ invoke__">get</span>(&amp;y) &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>遍历key, value:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// key, value不是&amp;</span><br><span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> scores &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);<br>&#125;<br><br><span class="hljs-comment">// key, value是&amp;</span><br><span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> &amp;scores &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);<br>&#125;<br><br><span class="hljs-comment">// key是&amp;, value是&amp;mut, 可以修改原值</span><br><span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> scores &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, key, value);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>查询已有值, 若不存在则插入新值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// x, y都是值, 不是&amp;, 返回&amp;mut, 可以根据z修改哈希表中的值</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = scores.<span class="hljs-title function_ invoke__">entry</span>(x).<span class="hljs-title function_ invoke__">or_insert</span>(y);<br>*z = *z + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><ul>
<li><p>闭包是一种匿名函数, 可以赋值给变量, 也可以捕获闭包之外的作用域中的值.</p>
</li>
<li><p>语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = |x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>  	x + y<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>闭包的一个用法: 简化冗余代码.</strong></p>
<ul>
<li>假设你有一个目的, 有很多种方法实现, 目的留出接口, 那么实现就可以用不同的闭包.</li>
</ul>
</li>
<li><p>闭包可以进行自动类型推导, 但是函数必须要标注类型.</p>
</li>
<li><p><strong>闭包作为结构体成员变量:</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Cacher</span>&lt;T&gt; <span class="hljs-keyword">where</span> T: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>  query: T,<br>  value: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">u32</span>&gt;<br>&#125;<br><span class="hljs-comment">// 调用闭包</span><br>(<span class="hljs-keyword">self</span>.query)(args);<br></code></pre></td></tr></table></figure>

<ul>
<li>其中, <code>Fn(u32) -&gt; u32</code>是一个特征用来规范闭包类型<code>T</code>.</li>
</ul>
</li>
<li><p><strong>闭包作为函数参数:</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;F&gt;(func: F) <span class="hljs-keyword">where</span> F: <span class="hljs-title function_ invoke__">Fn</span>(<span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>闭包的特征, 以及所有权问题:</strong></p>
<ul>
<li><p>闭包能够捕获闭包作用域之外的值, 但是这个捕获就涉及所有权转移的问题.</p>
</li>
<li><p><strong>特征1: <code>FnOnce</code></strong>: 实现这个trait的闭包, 会把参数&#x2F;里面捕获的变量的所有权拿走, 因此只能运行一次.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;F&gt;(func: F) <span class="hljs-keyword">where</span> F: <span class="hljs-title function_ invoke__">FnOnce</span>(<span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span>, &#123;<br>  <span class="hljs-title function_ invoke__">func</span>(<span class="hljs-number">3</span>);<br>  <span class="hljs-comment">// 调用第二次时, x的所有权已经被第一个闭包拿走, 第二个闭包没权利用x</span><br>  <span class="hljs-title function_ invoke__">func</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> 	<span class="hljs-keyword">let</span> <span class="hljs-variable">closure</span> = |z| &#123; z == x.<span class="hljs-title function_ invoke__">len</span>() &#125;;<br>  <span class="hljs-title function_ invoke__">fn_once</span>(closure);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong><code>FnOnce</code>加<code>Copy</code></strong>: 如果闭包trait实现了Copy trait, 那么在使用时, 就会调用闭包的拷贝, 可以运行多次.</p>
<ul>
<li>注意, 如果一个闭包实现了Copy trait, 那么不管其中捕获的变量是否实现Copy trait, 都没有关系, 都会调用闭包的拷贝.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;F&gt;(func: F) <span class="hljs-keyword">where</span> F: <span class="hljs-title function_ invoke__">FnOnce</span>(<span class="hljs-type">usize</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">bool</span> + <span class="hljs-built_in">Copy</span>, &#123;<br>  <span class="hljs-title function_ invoke__">func</span>(<span class="hljs-number">3</span>);<br>  <span class="hljs-comment">// 调用第二次时, x的所有权已经被第一个闭包拿走, 第二个闭包没权利用x</span><br>  <span class="hljs-title function_ invoke__">func</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> 	<span class="hljs-keyword">let</span> <span class="hljs-variable">closure</span> = |z| &#123; z == x.<span class="hljs-title function_ invoke__">len</span>() &#125;;<br>  <span class="hljs-title function_ invoke__">fn_once</span>(closure);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>如何判断一个闭包是否实现了<code>Copy</code>特征?</strong><ul>
<li>如果一个闭包捕获的所有变量的类型都实现了<code>Copy</code>特征, 那么这个闭包就会自动实现Copy特征.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>特征2: <code>FnMut</code></strong>: 以可变引用<code>&amp;mut</code>的方式捕获</p>
<ul>
<li><p>只要闭包声明时带了<code>mut</code>, 那么这个闭包就默认实现了<code>FnMut</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">update_string</span> = |<span class="hljs-type">str</span>| s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-type">str</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>特征3: <code>Fn</code></strong>: 以不可变借用<code>&amp;</code>的方式捕获:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">update_string</span> =  |<span class="hljs-type">str</span>| s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-type">str</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>闭包实现特征的规律:</strong></p>
<ul>
<li>一个闭包可以同时实现多个特征.</li>
<li>所有闭包默认实现<code>FnOnce</code>, 保证一个闭包至少可以被调用一次.</li>
<li>如果闭包内没有对捕获变量进行改变, 那么实现了<code>Fn</code>特征.</li>
<li>如果闭包没有把捕获变量的所有权返回, 那么实现了<code>FnMut</code>特征.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong><code>move</code>关键字:</strong> 定义在参数列表<code>||</code>之前, 表示闭包会强制把捕获变量的所有权拿走, 适用于<strong>闭包生命周期大于捕获变量生命周期</strong>.</p>
</li>
</ul>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><h4 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h4><ul>
<li><p>如果一个值的类型是<code>Option&lt;T&gt;</code>, 说明这个值可能是<code>None</code>.</p>
</li>
<li><p><code>Option&lt;T&gt;</code>的定义:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>  <span class="hljs-title function_ invoke__">Some</span>(T),<br>  <span class="hljs-literal">None</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>构造<code>Option&lt;T&gt;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">value</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">non_value</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>拆解<code>Option&lt;T&gt;</code></p>
<ul>
<li><p>如果确定不会是None, 可以用<code>unwrap()</code>, 如果出现None, 程序就会<code>panic</code>.</p>
</li>
<li><p>用match表达式:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> some_value &#123;<br>    <span class="hljs-title function_ invoke__">Some</span>(value) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value is &#123;&#125;&quot;</span>, value),<br>    <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;There is no value&quot;</span>),<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>用<code>if let</code>表达式:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">value</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(value) = some_value &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The value is &#123;&#125;&quot;</span>, value);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// None</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;There is no value&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>判断是否有值&#x2F;None:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">value1</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">value2</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;some_value is &#123;&#125;&quot;</span>, value1.<span class="hljs-title function_ invoke__">is_some</span>());<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;none_value is &#123;&#125;&quot;</span>, value2.<span class="hljs-title function_ invoke__">is_none</span>());<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2>
      
       <hr><span style="font-style: italic;color: gray;"> 向阳而生, 喜欢聪明的人. </span>
    </div>
</article>







    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©B1ueDrops
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
