<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Rust使用日记 | B1ueDrops</title>
  <meta name="keywords" content="">
  <meta name="description" content="Rust使用日记 | B1ueDrops">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="词汇 hood: 引擎盖  headlight: 车灯  bumper: 保险杠  windshield: 挡风玻璃  windshield wiper: 雨刮器  side view mirror: 左&#x2F;右后视镜  rear(后部) view mirror: 内部的后视镜  dashboard: 仪表盘  steering wheel: 方向盘  trunk: 后备箱">
<meta property="og:type" content="article">
<meta property="og:title" content="汽车英语">
<meta property="og:url" content="https://b1uedrops.github.io/2024/05/17/car-english/index.html">
<meta property="og:site_name" content="B1ueDrops">
<meta property="og:description" content="词汇 hood: 引擎盖  headlight: 车灯  bumper: 保险杠  windshield: 挡风玻璃  windshield wiper: 雨刮器  side view mirror: 左&#x2F;右后视镜  rear(后部) view mirror: 内部的后视镜  dashboard: 仪表盘  steering wheel: 方向盘  trunk: 后备箱">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-17T05:37:34.182Z">
<meta property="article:modified_time" content="2024-05-17T05:40:44.232Z">
<meta property="article:author" content="B1ueDrops">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpeg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpeg"/>
</a>
<div class="author">
    <span>B1ueDrops</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/B1ueDrops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:bluedrops@yeah.net"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2381446488&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(69)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="编程语言">
            
            编程语言
            <small>(11)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="工具/环境">
            
            工具/环境
            <small>(7)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="计算机网络">
            
            计算机网络
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="金融知识">
            
            金融知识
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="脑机接口">
            
            脑机接口
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="软件工程">
            
            软件工程
            <small>(7)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="社会技能">
            
            社会技能
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(15)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="体系结构">
            
            体系结构
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="信号处理">
            
            信号处理
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="AI">
            
            AI
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="English">
            
            English
            <small>(11)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="UNIX编程">
            
            UNIX编程
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="69">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All English "
           href="/2024/05/17/car-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="汽车英语">汽车英语</span>
            <span class="post-date" title="2024-05-17 13:37:34">2024/05/17</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/17/compile-link/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="程序的链接">程序的链接</span>
            <span class="post-date" title="2024-05-17 12:33:47">2024/05/17</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/14/regular_expression/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="正则表达式原理和实战">正则表达式原理和实战</span>
            <span class="post-date" title="2024-05-14 20:14:59">2024/05/14</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/05/14/recursion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="递归系列">递归系列</span>
            <span class="post-date" title="2024-05-14 16:02:10">2024/05/14</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/05/14/probability/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="概率论与数理统计">概率论与数理统计</span>
            <span class="post-date" title="2024-05-14 10:20:01">2024/05/14</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/13/restaurant_english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="饭店英语">饭店英语</span>
            <span class="post-date" title="2024-05-13 20:25:52">2024/05/13</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/05/13/combine_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="组合型的设计模式">组合型的设计模式</span>
            <span class="post-date" title="2024-05-13 20:11:49">2024/05/13</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/12/frontend-lang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前端语言使用日记">前端语言使用日记</span>
            <span class="post-date" title="2024-05-12 21:13:45">2024/05/12</span>
        </a>
        
        
        <a  class="All UNIX编程 "
           href="/2024/05/12/linux_process/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux上的进程控制">Linux上的进程控制</span>
            <span class="post-date" title="2024-05-12 13:03:52">2024/05/12</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/12/other-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="其他地道的英语表达">其他地道的英语表达</span>
            <span class="post-date" title="2024-05-12 12:38:31">2024/05/12</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/12/hotel-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="酒店英语">酒店英语</span>
            <span class="post-date" title="2024-05-12 12:29:02">2024/05/12</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2024/05/11/network_network_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="网络层">网络层</span>
            <span class="post-date" title="2024-05-11 18:21:44">2024/05/11</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2024/05/10/network_application_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="应用层">应用层</span>
            <span class="post-date" title="2024-05-10 20:46:30">2024/05/10</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/10/airport-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机场英语">机场英语</span>
            <span class="post-date" title="2024-05-10 10:12:57">2024/05/10</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/09/english-writing/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语写作背诵文章">英语写作背诵文章</span>
            <span class="post-date" title="2024-05-09 21:11:19">2024/05/09</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/09/practical-go/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Go语言使用日记">Go语言使用日记</span>
            <span class="post-date" title="2024-05-09 20:48:25">2024/05/09</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/05/09/database-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostgreSQL数据库教程">PostgreSQL数据库教程</span>
            <span class="post-date" title="2024-05-09 20:24:37">2024/05/09</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/05/09/cache-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cache的基础知识与设计策略">Cache的基础知识与设计策略</span>
            <span class="post-date" title="2024-05-09 20:12:19">2024/05/09</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/05/09/sort-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基础排序算法和应用">基础排序算法和应用</span>
            <span class="post-date" title="2024-05-09 17:10:04">2024/05/09</span>
        </a>
        
        
        <a  class="All 社会技能 "
           href="/2024/04/26/secure_drive/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="安全驾驶知识">安全驾驶知识</span>
            <span class="post-date" title="2024-04-26 19:53:53">2024/04/26</span>
        </a>
        
        
        <a  class="All 金融知识 "
           href="/2024/04/26/quant/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基金及量化投资">基金及量化投资</span>
            <span class="post-date" title="2024-04-26 13:42:05">2024/04/26</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2024/04/21/network_tcp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="传输层">传输层</span>
            <span class="post-date" title="2024-04-21 15:16:42">2024/04/21</span>
        </a>
        
        
        <a  class="All 信号处理 "
           href="/2024/04/20/fourier/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="傅立叶级数与变换">傅立叶级数与变换</span>
            <span class="post-date" title="2024-04-20 18:36:34">2024/04/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/04/14/two_pointer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="双指针系列">双指针系列</span>
            <span class="post-date" title="2024-04-14 19:46:01">2024/04/14</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/13/practical-rust/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust使用日记">Rust使用日记</span>
            <span class="post-date" title="2024-04-13 17:05:26">2024/04/13</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/04/13/ai_basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AI的一些基础概念">AI的一些基础概念</span>
            <span class="post-date" title="2024-04-13 16:43:26">2024/04/13</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/04/13/transformer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="简单理解Transformer">简单理解Transformer</span>
            <span class="post-date" title="2024-04-13 12:36:45">2024/04/13</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/12/rust_async/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust的异步编程">Rust的异步编程</span>
            <span class="post-date" title="2024-04-12 14:09:37">2024/04/12</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/07/python_many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python用到什么学什么">Python用到什么学什么</span>
            <span class="post-date" title="2024-04-07 10:46:59">2024/04/07</span>
        </a>
        
        
        <a  class="All 脑机接口 "
           href="/2024/04/06/eeg_device/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="脑电的原理">脑电的原理</span>
            <span class="post-date" title="2024-04-06 10:35:04">2024/04/06</span>
        </a>
        
        
        <a  class="All 社会技能 "
           href="/2024/04/05/eq/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="培养高情商的一些策略">培养高情商的一些策略</span>
            <span class="post-date" title="2024-04-05 10:25:28">2024/04/05</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/02/rust_leetcode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="用Rust实现Leetcode算法题">用Rust实现Leetcode算法题</span>
            <span class="post-date" title="2024-04-02 12:59:13">2024/04/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/30/binary-tree/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二叉树/二叉搜索树全系列">二叉树/二叉搜索树全系列</span>
            <span class="post-date" title="2024-03-30 17:07:34">2024/03/30</span>
        </a>
        
        
        <a  class="All UNIX编程 "
           href="/2024/03/30/multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多进程/多线程编程模型">多进程/多线程编程模型</span>
            <span class="post-date" title="2024-03-30 16:47:20">2024/03/30</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/30/profile/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="软件的性能分析">软件的性能分析</span>
            <span class="post-date" title="2024-03-30 13:49:01">2024/03/30</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/28/linkedlist/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="链表系列">链表系列</span>
            <span class="post-date" title="2024-03-28 09:53:10">2024/03/28</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/24/data-struct/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构系列">数据结构系列</span>
            <span class="post-date" title="2024-03-24 14:10:22">2024/03/24</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/23/vscode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="vscode插件配置">vscode插件配置</span>
            <span class="post-date" title="2024-03-23 15:50:58">2024/03/23</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/command_line/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shell脚本现用现学">Shell脚本现用现学</span>
            <span class="post-date" title="2024-03-22 12:50:32">2024/03/22</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/cpp-many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++之用到什么学什么">C++之用到什么学什么</span>
            <span class="post-date" title="2024-03-22 11:31:11">2024/03/22</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/linear-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性DP">线性DP</span>
            <span class="post-date" title="2024-03-20 18:11:22">2024/03/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/tree-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="树形DP">树形DP</span>
            <span class="post-date" title="2024-03-20 18:10:56">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-method/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Methodology">英语科技论文写作模型-Methodology</span>
            <span class="post-date" title="2024-03-20 16:53:17">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-abstract/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Abstract">英语科技论文写作模型-Abstract</span>
            <span class="post-date" title="2024-03-20 16:49:54">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-conclusion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Conclusion">英语科技论文写作模型-Conclusion</span>
            <span class="post-date" title="2024-03-20 16:49:46">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-results/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Results">英语科技论文写作模型-Results</span>
            <span class="post-date" title="2024-03-20 16:49:31">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/19/sci-writing-introduction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Introduction">英语科技论文写作模型-Introduction</span>
            <span class="post-date" title="2024-03-19 10:16:07">2024/03/19</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/03/10/ai-cnn/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CNN的一些基础知识">CNN的一些基础知识</span>
            <span class="post-date" title="2024-03-10 15:57:42">2024/03/10</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/10/catalan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡特兰数系列">卡特兰数系列</span>
            <span class="post-date" title="2024-03-10 12:47:19">2024/03/10</span>
        </a>
        
        
        <a  class="All UNIX编程 "
           href="/2024/03/05/concurrent_sketch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="并发编程的概述">并发编程的概述</span>
            <span class="post-date" title="2024-03-05 15:00:50">2024/03/05</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/03/knapsack/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="背包问题的模板总结">背包问题的模板总结</span>
            <span class="post-date" title="2024-03-03 16:22:21">2024/03/03</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/03/02/virtualmem/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="虚拟内存的基础知识和设计">虚拟内存的基础知识和设计</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/sim-plus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="高精度加减乘除">高精度加减乘除</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/prefix-sum-diff/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前缀和/差分">前缀和/差分</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/other-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="冷门算法/模拟题">冷门算法/模拟题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/interval/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="区间问题">区间问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/02/go-concurrent/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="使用goroutine实现并发算法题">使用goroutine实现并发算法题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/03/02/cache-coherence/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="缓存一致性">缓存一致性</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/binary-search/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二分系列">二分系列</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/02/jetbrains/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jetbrains系列IDE的配置">Jetbrains系列IDE的配置</span>
            <span class="post-date" title="2024-03-02 19:00:15">2024/03/02</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/02/tmux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tmux键位配置">tmux键位配置</span>
            <span class="post-date" title="2024-03-02 13:16:32">2024/03/02</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/01/clean_code/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码整洁之道">代码整洁之道</span>
            <span class="post-date" title="2024-03-01 14:30:08">2024/03/01</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/01/software_rule/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面向对象设计的基本原则">面向对象设计的基本原则</span>
            <span class="post-date" title="2024-03-01 14:30:02">2024/03/01</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/29/lazygit/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="lazygit的一些常见用法">lazygit的一些常见用法</span>
            <span class="post-date" title="2024-02-29 17:44:04">2024/02/29</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/28/yabai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="yabai窗口管理器键位配置">yabai窗口管理器键位配置</span>
            <span class="post-date" title="2024-02-28 13:01:35">2024/02/28</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/27/joshuto/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="joshuto的键位配置">joshuto的键位配置</span>
            <span class="post-date" title="2024-02-27 19:43:49">2024/02/27</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/02/26/behaviour_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="行为型的设计模式">行为型的设计模式</span>
            <span class="post-date" title="2024-02-26 20:11:27">2024/02/26</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/26/vimium/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Chrome中vimium键位">Chrome中vimium键位</span>
            <span class="post-date" title="2024-02-26 20:03:26">2024/02/26</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/02/25/build_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创建型的设计模式">创建型的设计模式</span>
            <span class="post-date" title="2024-02-25 15:27:36">2024/02/25</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-practical-rust" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Rust使用日记</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="编程语言">编程语言</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-05-19 14:31:43'>2024-04-13 17:05</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Rust%E4%BB%8B%E7%BB%8D"><span class="toc-text">Rust介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rustc"><span class="toc-text">rustc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0"><span class="toc-text">整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="toc-text">浮点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6"><span class="toc-text">字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94"><span class="toc-text">布尔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unit-Type"><span class="toc-text">Unit Type</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98-%E5%BC%95%E7%94%A8-%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-text">可变, 引用, 所有权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84"><span class="toc-text">元组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87"><span class="toc-text">切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-text">控制流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trait"><span class="toc-text">Trait</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%A7%84%E5%88%99"><span class="toc-text">孤儿规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#newtype"><span class="toc-text">newtype</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F"><span class="toc-text">特征约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F"><span class="toc-text">泛型特征约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#trait%E7%89%B9%E5%BE%81%E7%BA%A6%E6%9D%9F"><span class="toc-text">trait特征约束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AF%B9%E8%B1%A1"><span class="toc-text">特征对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E7%B1%BB%E5%9E%8B"><span class="toc-text">关联类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E9%99%90%E5%AE%9A%E8%AF%AD%E6%B3%95"><span class="toc-text">完全限定语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Option"><span class="toc-text">Option</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector"><span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B"><span class="toc-text">多文件编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mod%E6%A0%91%E7%8A%B6%E7%BB%93%E6%9E%84"><span class="toc-text">mod树状结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86-use"><span class="toc-text">权限管理&#x2F;use</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">格式化输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Display"><span class="toc-text">Display</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Debug"><span class="toc-text">Debug</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%B6%88%E8%B4%B9%E8%80%85-%E6%94%B6%E9%9B%86%E8%80%85"><span class="toc-text">迭代器消费者&#x2F;收集者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Deref"><span class="toc-text">Deref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Drop"><span class="toc-text">Drop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Box"><span class="toc-text">Box&lt;T&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rc-Arc"><span class="toc-text">Rc&lt;T&gt;&#x2F;Arc&lt;T&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RefCell"><span class="toc-text">RefCell&lt;T&gt;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="toc-text">创建线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Send-Sync"><span class="toc-text">Send&#x2F;Sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mutex"><span class="toc-text">Mutex&lt;T&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Condvar"><span class="toc-text">Condvar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel"><span class="toc-text">channel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O"><span class="toc-text">I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Read-Write"><span class="toc-text">Read&#x2F;Write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E5%BC%82%E5%B8%B8"><span class="toc-text">I&#x2F;O异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BufReader-BufWriter"><span class="toc-text">BufReader&#x2F;BufWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9CI-O"><span class="toc-text">网络I&#x2F;O</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-Client-Server"><span class="toc-text">TCP Client&#x2F;Server</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F"><span class="toc-text">类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sized-Sized"><span class="toc-text">Sized&#x2F;?Sized</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-text">异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await"><span class="toc-text">async&#x2F;.await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future"><span class="toc-text">Future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pin-Unpin"><span class="toc-text">Pin&#x2F;Unpin</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cargo%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86"><span class="toc-text">cargo项目管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E4%B8%8E%E6%96%87%E6%A1%A3"><span class="toc-text">注释与文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">单元测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsafe-Rust"><span class="toc-text">Unsafe Rust</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-text">裸指针</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Rust介绍"><a href="#Rust介绍" class="headerlink" title="Rust介绍"></a>Rust介绍</h2><blockquote>
<p>Rust的优势?</p>
</blockquote>
<ul>
<li>**Zero Cost Abstraction: ** Rust引入的一些机制 (例如所有权机制&#x2F;泛型), 并不会引入额外的运行时开销.</li>
</ul>
<h2 id="rustc"><a href="#rustc" class="headerlink" title="rustc"></a><code>rustc</code></h2><ul>
<li><p>rustc是Rust编译器.</p>
</li>
<li><p>rustc通过目标三元组(Target Triplet)来描述运行平台, 格式是: <code>CPU架构-厂商-OS-运行时库</code>.</p>
<ul>
<li>可以通过<code>rustc --version --verbose</code>查看:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">rustc 1.76.0 (07dca489a 2024-02-04)<br>binary: rustc<br>commit-hash: 07dca489ac2d933c78d3c5158e3f43beefeb02ce<br>commit-date: 2024-02-04<br>host: aarch64-apple-darwin &lt;- 运行平台<br>release: 1.76.0<br>LLVM version: 17.0.6<br></code></pre></td></tr></table></figure>

<ul>
<li>使用<code>rustc --print target-list</code>可以查看这个版本的<code>rustc</code>总共可以支持多少个host.<ul>
<li>如果想要添加一个平台, 可以用: <code>rustup target add riscv64gc-unknown-none-elf</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://rust-lang.github.io/api-guidelines/naming.html">https://rust-lang.github.io/api-guidelines/naming.html</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>元素</th>
<th>命名方式</th>
</tr>
</thead>
<tbody><tr>
<td>局部变量</td>
<td>snake_case</td>
</tr>
<tr>
<td>函数</td>
<td>snake_case</td>
</tr>
<tr>
<td>方法</td>
<td>snake_case</td>
</tr>
<tr>
<td>模块(mod)</td>
<td>snake_case</td>
</tr>
<tr>
<td>结构体</td>
<td>UpperCamelCase</td>
</tr>
<tr>
<td>Trait</td>
<td>UpperCamelCase</td>
</tr>
<tr>
<td>枚举</td>
<td>UpperCamelCase</td>
</tr>
<tr>
<td>常量</td>
<td><code>SCREAM_SNAKE_CASE</code></td>
</tr>
</tbody></table>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量和<strong>不可变的变量</strong>有很大的不同.</p>
<ul>
<li><p>常量需要使用<code>const</code>关键字, 并且<strong>必须标注类型</strong>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">&lt;<span class="hljs-keyword">pub</span>&gt; <span class="hljs-keyword">const</span> MAX_NUM: <span class="hljs-type">i32</span> = <span class="hljs-number">1000_i32</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>常量可以定义在任意作用域, 包括全局作用域.</p>
</li>
<li><p>常量必须绑定到<strong>常量表达式</strong>, 必须在编译时期就要算出来.</p>
</li>
<li><p>数字的字面值可以用<code>_</code>分割.</p>
</li>
<li><p>尽量让程序中所有的硬编码值都变成常量, 方便后续维护&#x2F;提高可读性.</p>
</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ul>
<li><p>整数类型:</p>
<table>
<thead>
<tr>
<th>位数</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody><tr>
<td>8</td>
<td><code>i8</code></td>
<td><code>u8</code></td>
</tr>
<tr>
<td>16</td>
<td><code>i16</code></td>
<td><code>u16</code></td>
</tr>
<tr>
<td>32</td>
<td><code>i32</code></td>
<td><code>u32</code></td>
</tr>
<tr>
<td>64</td>
<td><code>i64</code></td>
<td><code>u64</code></td>
</tr>
<tr>
<td>128</td>
<td><code>i128</code></td>
<td><code>u128</code></td>
</tr>
<tr>
<td>架构</td>
<td><code>isize</code></td>
<td><code>usize</code></td>
</tr>
</tbody></table>
</li>
<li><p>Rust整数的默认类型是<code>i32</code>.</p>
</li>
<li><p>整数类型的字面值可以使用类型后缀:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-number">100_u8</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>其他进制的字面值:</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>进制</th>
<th>字面值</th>
</tr>
</thead>
<tbody><tr>
<td>二进制</td>
<td><code>0b1000_0000</code></td>
</tr>
<tr>
<td>八进制</td>
<td><code>0o77</code></td>
</tr>
<tr>
<td>十六进制</td>
<td><code>0xffff_ffff</code></td>
</tr>
</tbody></table>
<ul>
<li><p>将整数按照其他进制打印:</p>
<ul>
<li>二进制:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#b&#125;&quot;</span>, x);<br></code></pre></td></tr></table></figure>

<ul>
<li>十六进制:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#x&#125;&quot;</span>, x);<br></code></pre></td></tr></table></figure>

<ul>
<li>使用0填充, 最小宽度是<code>m</code>打印十六进制:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:#0mx&#125;&quot;</span>, x);<br></code></pre></td></tr></table></figure>
</li>
<li><p>整数溢出问题:</p>
<ul>
<li>$n$位无符号数范围: $[0, 2^n - 1]$</li>
<li>$n$位有符号数范围: $[-2^{n-1}, 2^{n-1}-1]$​​</li>
<li>Rust在debug模式下, 遇到整数溢出会<code>panic</code>, 在release模式下, 不会<code>panic</code>, 直接按照循环溢出处理.</li>
</ul>
</li>
</ul>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul>
<li><p>浮点数类型: <code>f32</code>和<code>f64</code>, 默认是<code>f64</code>类型.</p>
</li>
<li><p>浮点数只实现了<code>std::cmp::PartialEq</code>, 并且不能直接使用<code>&lt;, &lt;=</code>进行比较.</p>
<ul>
<li>如果要比较, 需要<code>(0.1_f64 + 0.2 - 0.3).abs() &lt; 0.00001</code></li>
</ul>
</li>
<li><p>特殊的浮点数: <code>NaN</code>.</p>
<ul>
<li>判断一个浮点数是否是<code>NaN</code>: <code>x.is_nan()</code></li>
<li>与<code>NaN</code>进行运算都会得到<code>NaN</code>.</li>
</ul>
</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul>
<li>基本类型转换: <code>as</code><ul>
<li>例如: <code>let a = 3.2 as u8;</code></li>
<li>注意整数之间转换需要注意范围.</li>
<li>类型转换永远是显式的, Rust永远不会偷偷地将一种类型转换为另一种类型.</li>
</ul>
</li>
</ul>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><ul>
<li><p>字符类型: <code>char</code></p>
<ul>
<li><p>字符的字面值是<code>&#39;a&#39;</code>.</p>
</li>
<li><p>所有的Unicode值, 都可以作为Rust中的char.</p>
</li>
<li><p>由于Unicode值最多用4个字节进行编码, 因此, Rust中的字符类型占用4个字节.</p>
</li>
<li><p>如果某个字符的Unicode值用不了4个字节, 那么可以用<code>u8</code>来存储:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// a是u8类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-string">b&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>打印一个变量所占的内存空间(单位是字节):</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, std::mem::<span class="hljs-title function_ invoke__">size_of_val</span>(&amp;a));<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h3><ul>
<li>布尔类型: <code>bool</code>:<ul>
<li>只有两个字面值<code>true</code>和<code>false</code>.</li>
</ul>
</li>
</ul>
<h3 id="Unit-Type"><a href="#Unit-Type" class="headerlink" title="Unit Type"></a><code>Unit Type</code></h3><ul>
<li><p>单元类型 (unit type): <code>()</code></p>
<ul>
<li>这个类型用来占位, 不占用任何内存.</li>
<li>本质上就是一个空的元组.</li>
<li><code>main</code>函数和<code>println!</code>的返回值是<code>()</code>.</li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p>函数的定义:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>每一个参数, 以及返回值都需要标注类型.</li>
</ul>
</li>
<li><p>函数体:</p>
<ul>
<li>函数体由一系列Statement (语句)以及最后的Expression (表达式)组成.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">add_with_extra</span>(x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = x + <span class="hljs-number">1</span>; <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = y + <span class="hljs-number">5</span>; <span class="hljs-comment">// 语句</span><br>    x + y <span class="hljs-comment">// 表达式</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>语句会返回<code>()</code>类型, 最后的表达式是函数返回的结果.</li>
<li>如果要在函数中间强制返回结果, 可以使用<code>return</code>.</li>
</ul>
</li>
<li><p>函数返回<code>()</code>可以代表函数没有返回值, 但是没有返回值的函数在rust中叫做diverge function:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dead_end</span>() <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>  <span class="hljs-title function_ invoke__">panic</span>(<span class="hljs-string">&quot;End of program&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>返回值是<code>!</code>时, 这个函数就是diverge function, 表示没有返回值.</li>
<li>这种函数一般会导致程序<code>panic</code>.</li>
</ul>
</li>
</ul>
<h2 id="可变-引用-所有权"><a href="#可变-引用-所有权" class="headerlink" title="可变, 引用, 所有权"></a>可变, 引用, 所有权</h2><ul>
<li><p>可变性:</p>
<ul>
<li>如果一个变量的值在后面可能会发生变化, 应该用<code>mut</code>修饰:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>所有权:</p>
<ul>
<li>Rust中, 每一个值都被一个变量所拥有, 这个变量有这个值的所有权(ownership).</li>
<li>一个值只能拥有一个所有者.</li>
<li>当所有者离开作用域时, 值会被释放.</li>
</ul>
</li>
<li><p>Rust中, 当一个变量赋值&#x2F;当作函数参数传递时, 如果对应类型没有实现<code>Copy</code> trait, 则会发生所有权的转移.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a;<br><span class="hljs-comment">// 此后, a不可使用, 否则会panic</span><br></code></pre></td></tr></table></figure>

<ul>
<li>所有权的检查是在编译时期进行的, 对运行时的性能没有影响.</li>
<li>实现了<code>Copy</code> trait的类型有:<ul>
<li>整数.</li>
<li>浮点数.</li>
<li>字符.</li>
<li>布尔.</li>
<li>所有元素都实现了<code>Copy trait</code>的元组.</li>
<li>不可变引用<code>&amp;T</code>.</li>
</ul>
</li>
<li>所有权的转移会涉及到变量地址的改变.</li>
</ul>
</li>
<li><p>引用: 引用变量可以看作对原变量值的租借(borrowing), 租借不会引起所有权的转变, 分为两种类型:</p>
<ul>
<li><p>不可变引用<code>&amp;T</code>: 可以使用原变量的值, 但是不可以改变值.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = &amp;a;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可变引用<code>&amp;mut T</code>: 可以读&#x2F;写原变量的值, 要求原变量必须可变<code>mut</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = &amp;<span class="hljs-keyword">mut</span> a;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>借用规则:</strong></p>
<ul>
<li><p>不可以对不可变数据进行可变借用.</p>
</li>
<li><p>同一作用域, 同一个值, 只能进行一次可变引用<code>&amp;mut T</code>的借用.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = &amp;<span class="hljs-keyword">mut</span> v[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = &amp;<span class="hljs-keyword">mut</span> v[<span class="hljs-number">1</span>];<br><span class="hljs-comment">// 报错</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, b, c);<br></code></pre></td></tr></table></figure>
</li>
<li><p>同一作用域, 同一个值, 不能同时进行可变引用和不可变引用的借用.</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = &amp;v[<span class="hljs-number">0</span>];<br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 报错</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, b);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><ul>
<li><p>元组类型: <code>(T, U, E)</code>, 其中<code>T, U, E</code>是类型.</p>
<ul>
<li>创建元组:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">tup</span>: (<span class="hljs-type">i32</span>, <span class="hljs-type">f64</span>, <span class="hljs-type">u8</span>) = (<span class="hljs-number">1</span>, <span class="hljs-number">1.1</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>解构元组:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> (x, y, z) = tup;<br><span class="hljs-comment">// 用.0/.1/.2访问元素</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">z</span> = tup.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>借助元组, 可以实现函数返回多个元素:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">length</span>(s: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">String</span>, <span class="hljs-type">usize</span>) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">length</span> = s.<span class="hljs-title function_ invoke__">len</span>();<br>  (s, length)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br>  <span class="hljs-keyword">let</span> (s, l) = <span class="hljs-title function_ invoke__">length</span>(a);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><ul>
<li><p>切片类型: <code>[T]</code> (<code>str</code>也是切片类型)</p>
<ul>
<li>切片可以表示对一个集合中的部分数据.</li>
<li>在Rust中, 切片是一个动态类型(DST), 在编译时无法获取类型大小, 因此在代码中没法直接使用.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> : <span class="hljs-type">str</span> = <span class="hljs-string">&quot;haha&quot;</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>对于切片的访问, 只能通过切片的引用<code>&amp;[T]</code>来进行访问(引用已知大小).</li>
</ul>
</li>
<li><p>创建切片的语法: <code>&amp;s[a..b]</code>, 获取<code>s</code>中<code>[a, b)</code>区间范围的数据 (<code>s</code>可以是数组, 或者是<code>String</code>类型).</p>
<ul>
<li><code>&amp;s[..]</code>获取全部.</li>
<li><code>&amp;s[..b]</code>获取<code>[0, b)</code>.</li>
<li><code>&amp;s[a..]</code>获取<code>[a, s.len)</code>.</li>
</ul>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li><p>字符串类型: <code>&amp;str</code></p>
<ul>
<li>在Rust中, 语言层面只提供了<code>&amp;str</code>类型作为字符串.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// a是&amp;str类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-string">&quot;hahaha&quot;</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>字符串字面值<code>&quot;hahaha&quot;</code>被硬编码在二进制文件中, 并且不可变, <code>&amp;str</code>就是对这个不可变的值的引用.</p>
</li>
<li><p><code>&amp;str</code>类型不可以用索引进行访问.</p>
</li>
<li><p>对<code>&amp;str</code>取切片引用, 得到的还是<code>&amp;str</code>类型:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-string">&quot;hahaha&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = &amp;a[..];<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>更方便的字符串类型: <code>String</code></p>
<ul>
<li><p><code>String</code>定义在标准库<code>std</code>中.</p>
</li>
<li><p>字符串创建:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-string">&quot;haha&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p>字符串修改 (需要定义字符串为<code>mut</code>): 参考文档.</p>
</li>
<li><p><code>String</code>采用<code>UTF-8</code>进行编码, 底层采用<code>Vec&lt;u8&gt;</code>进行实现:</p>
<ul>
<li><code>String</code>类型也不可以用索引进行访问.</li>
<li><code>String</code>类型可以取切片, 切片的类型是<code>&amp;str</code>.</li>
<li><code>String</code>类型取切片时, <font color="red">一定注意, 索引的边界要在字符的边界上</font>.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;中国人&quot;</span>);<br><span class="hljs-comment">// 报错, 一个中文字符占3个字节, [0..2]正好在&#x27;中&#x27;的内部</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = &amp;a[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure>

<ul>
<li>如果想获取<code>String</code>中的第<code>n</code>个字符, 可以使用如下方法:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br><span class="hljs-comment">// b是Option&lt;char&gt;类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">nth</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 遍历每一个字符 (a.chars()返回一个迭代器)</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">c</span> <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>  <span class="hljs-comment">// c是char类型</span><br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, c);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul>
<li><p>结构体类型:</p>
<ul>
<li>定义结构体:<ul>
<li>每一个参数都需要显式标注类型.</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>  name: <span class="hljs-type">String</span>,<br>  age: <span class="hljs-type">u32</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>例化结构体:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stu</span> = Student &#123;<br>  name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>),<br>  age: <span class="hljs-number">18</span><br>&#125;;<br><br><span class="hljs-comment">// 如果变量和结构体字段重名, 那么可以简化:</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">name</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stu</span> = Student &#123;<br>  name,<br>  age: <span class="hljs-number">18</span><br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>结构体的可变性: 如果结构体变量被设置为<code>mut</code>, 那么其中的每个字段都是可变.</p>
</li>
<li><p>元组结构体: 只有<code>struct</code>名字, 没有字段名字的结构体:</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">black</span> = <span class="hljs-title function_ invoke__">Color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 访问元素</span><br>black.<span class="hljs-number">0</span><br>black.<span class="hljs-number">1</span><br>black.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>



<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul>
<li><p>枚举类型: <code>enum</code></p>
<ul>
<li>定义枚举:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddr</span> &#123;<br>  IPv4,<br>  IPv6<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>访问枚举:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = IpAddr::IPv4;<br></code></pre></td></tr></table></figure>
</li>
<li><p>枚举中的元素可以和一个值绑定:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddr</span> &#123;<br>  <span class="hljs-title function_ invoke__">IPv4</span>(<span class="hljs-type">String</span>),<br>  <span class="hljs-title function_ invoke__">IPv6</span>(<span class="hljs-type">String</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>构造&#x2F;获取其中的值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = IpAddr::<span class="hljs-title function_ invoke__">IPv4</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>));<br><br><span class="hljs-keyword">if</span> IpAddr::<span class="hljs-title function_ invoke__">IPv4</span>(s) = a &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>数组类型: <code>[T; num]</code></p>
<ul>
<li><p>数组是定长的, 创建语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure>
</li>
<li><p>标注类型:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure>
</li>
<li><p>创建一个包含多个重复值的数组:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// a = [3, 3, 3, 3, 3]</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = [<span class="hljs-number">3</span>; <span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure>

<ul>
<li>注意: 如果采用这种写法, 数组中的元素需要实现<code>Copy trait</code>, 如果没有实现, 需要用<code>std::array::from_fn</code>.</li>
</ul>
</li>
</ul>
</li>
<li><p>可以通过索引访问数组元素.</p>
<ul>
<li>Rust会在编译时和运行时都检查数组越界, 运行时出现会直接<code>panic</code>.</li>
</ul>
</li>
<li><p>打印数组可以用<code>&#123;:#?&#125;</code>.</p>
</li>
<li><p>可以创建数组的切片:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span>: [<span class="hljs-type">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">slice</span>: &amp;[<span class="hljs-type">i32</span>] = &amp;a[<span class="hljs-number">1</span>..<span class="hljs-number">3</span>];<br><span class="hljs-comment">// 字面值比较</span><br><span class="hljs-built_in">assert_eq!</span>(slice, &amp;[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><ul>
<li><p><code>Range</code>:</p>
<ul>
<li><code>Range&lt;T&gt;</code>是一个序列, 可以用<code>a..b</code>构造, 表示<code>[a, b)</code></li>
<li><code>for</code>循环可以使用<code>Range</code>来遍历集合.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..a.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a[i]<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>for</code>循环与迭代器的语法糖: </p>
<ul>
<li><p>如果要转移元素的所有权:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// item为T类型</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> collection &#123;<br>  <br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> collection.<span class="hljs-title function_ invoke__">into_iter</span>() &#123;<br>  <br>&#125;<br><span class="hljs-comment">// 如果需要索引</span><br><span class="hljs-keyword">for</span> (i, item) <span class="hljs-keyword">in</span> collection.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果要用元素的不可变借用:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// item为&amp;T类型</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;collection &#123;<br>  <br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> collection.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果要用元素的可变借用:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// item为&amp;mut T类型</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> collection &#123;<br>  <br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> collection.<span class="hljs-title function_ invoke__">iter_mut</span>() &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>for</code>循环遍历的性能问题:</p>
<ul>
<li>用迭代器遍历性能大于用索引, 因为索引访问需要引入判断数组越界访问.</li>
</ul>
</li>
</ul>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><ul>
<li><p>模式匹配也是一种控制流, 它有两个功能:</p>
<ul>
<li>解构变量.</li>
<li>根据变量的不同值, 采用不同的控制流.</li>
</ul>
</li>
<li><p>模式可以是如下内容:</p>
<ul>
<li>字面值.</li>
<li>解构的枚举值, 元组, 结构体.</li>
</ul>
</li>
<li><p><code>match</code>表达式:</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">match</span> VALUE &#123;<br>    PATTERN =&gt; EXPRESSION,<br>    PATTERN =&gt; EXPRESSION,<br>    _ =&gt; EXPRESSION,<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>一个例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 例子</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Coin</span> &#123;<br>	A, B, C, D, E<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">value_in_cents</span>(coin: Coin) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123;<br>  <span class="hljs-keyword">match</span> coin &#123;<br>    Coin::A =&gt; <span class="hljs-number">1</span>,<br>    Coin::B =&gt; <span class="hljs-number">2</span>,<br>    <span class="hljs-comment">// | 表示两种情况</span><br>    Coin::C | Coin::D =&gt; &#123; <span class="hljs-number">3</span> &#125;,<br>    Coin::D =&gt; <span class="hljs-number">4</span>,<br>    _ =&gt; &#123; <span class="hljs-number">5</span> &#125;,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>用<code>match</code>来解构枚举值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>  <span class="hljs-title function_ invoke__">Some</span>(T),<br>  <span class="hljs-literal">None</span>,<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-keyword">match</span> a &#123;<br>  <span class="hljs-title function_ invoke__">Some</span>(x) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = x;<br>    b<br>  &#125;,<br>  <span class="hljs-literal">None</span> =&gt; &#123;<br>    <span class="hljs-number">0</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>if let</code>表达式: 只关心一种匹配情况的<code>match</code>:</p>
  <figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = a &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = x;<br>  b<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p>方法是绑定在类型上的一系列函数, 方法可以访问类型中的元素.</p>
<ul>
<li>用<code>impl</code>定义方法:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br> 	name: <span class="hljs-type">String</span>,<br>  age: <span class="hljs-type">usize</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">name</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">self</span>.name<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>impl</code>可以分为多个, 可以按照逻辑组织<code>impl</code>.</li>
</ul>
</li>
<li><p>方法的类型:</p>
<ul>
<li>关联函数: 方法签名中没有<code>self, &amp;self, &amp;mut self</code>.<ul>
<li>用来实现构造函数.</li>
</ul>
</li>
<li>其他方法: 方法签名中带有<code>self, &amp;self, &amp;mut self</code>.</li>
</ul>
</li>
<li><p>方法的所有权问题:</p>
<ul>
<li><code>self</code>: 会拿走类型变量的所有权, 调用后原变量不可用.</li>
<li><code>&amp;self</code>: 对原变量采用不可变借用.</li>
<li><code>&amp;mut self</code>: 对原变量采用可变借用, 可以修改变量的字段值.</li>
</ul>
</li>
<li><p>自动解引用(<code>Deref trait</code>): </p>
<ul>
<li>如果方法中的参数是<code>&amp;self, &amp;mut self</code>, 在访问变量时, 应该加上解引用<code>(*stu).name</code>.</li>
<li>但是, Rust会自动解引用, 因此可以直接<code>stu.name</code>访问.</li>
<li>本质上是Rust对<code>Self</code>这种类型实现了<code>Deref trait</code>.</li>
</ul>
</li>
<li><p>为枚举实现方法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Weekday</span> &#123;<br>  Monday, Thuesday, Wednesday<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Weekday</span> &#123;<br>  <br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show_mood</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>    <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> &#123;<br>      <span class="hljs-keyword">Self</span>::Monday =&gt; &#123;&#125;,<br>      <span class="hljs-keyword">Self</span>::Thuesday =&gt; &#123;&#125;,<br>      <span class="hljs-comment">//...</span><br>    &#125;<br>  &#125;<br>  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul>
<li><p>泛型可以在函数, 结构体, 枚举, 方法中使用.</p>
</li>
<li><p>泛型需要在函数名&#x2F;结构体名&#x2F;枚举名&#x2F;方法名后面声明泛型参数<code>T</code>, 然后再使用:</p>
<ul>
<li><p>函数:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>结构体:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span>&lt;T, U&gt; &#123;<br>  x: T,<br>  y: U<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>枚举:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>  <span class="hljs-title function_ invoke__">Ok</span>(T),<br>  <span class="hljs-title function_ invoke__">Err</span>(E)<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>方法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;<br>  <br>&#125;<br><span class="hljs-comment">// 如果方法要针对某种具体的类型</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Point</span>&lt;<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>&gt; &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a><code>Trait</code></h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul>
<li><p>Trait是一种类型, 里面包含了若干个方法, 用来定义一个对象所必须满足的行为:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Show</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以将某一个Trait绑定到一个类型上:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>  name: <span class="hljs-type">String</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Show</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">self</span>.name<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Trait中可以提供默认实现的方法, 绑定的类型可以选择是否重载这个方法.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Show</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Read more!&quot;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="孤儿规则"><a href="#孤儿规则" class="headerlink" title="孤儿规则"></a>孤儿规则</h3><ul>
<li>如果你要为一个类型<code>T</code>实现一个Trait, 那么Trait和<code>T</code>至少有一个需要定义在当前作用域.<ul>
<li>不能为外部的类型实现外部的Trait.</li>
</ul>
</li>
</ul>
<h4 id="newtype"><a href="#newtype" class="headerlink" title="newtype"></a><code>newtype</code></h4><ul>
<li><p>newtype可以绕过孤儿规则, 为外部类型实现外部trait.</p>
</li>
<li><p>使用方法:</p>
<ul>
<li>用一个元组结构体作为<code>Wrapper</code>, 包裹其中的外部类型.</li>
<li>为这个元组结构体实现外部trait.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Wrapper</span>(<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt;);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Display</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Wrapper</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-comment">// 之后可以使用Wrapper代替外部类型</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="特征约束"><a href="#特征约束" class="headerlink" title="特征约束"></a>特征约束</h3><h4 id="泛型特征约束"><a href="#泛型特征约束" class="headerlink" title="泛型特征约束"></a>泛型特征约束</h4><ul>
<li><p>泛型参数<code>T</code>在声明的时候, 可以限制这个泛型<code>T</code>必须实现某几种特征:</p>
<ul>
<li><p>实现一种特征:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>实现两种特征: <code>+</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T: Summary + Display&gt;(item: &amp;T) &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>实现好几种特征: <code>where</code>表达式</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T, U&gt;(item: &amp;T, other: &amp;U)<br>	<span class="hljs-keyword">where</span> T: Display + <span class="hljs-built_in">Clone</span>,<br>				U: Summary + Display<br>&#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>在方法中进行特征约束的时候, 只需要在第一个<code>&lt;&gt;</code>中进行特征约束即可:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T: Display&gt; Point&lt;T&gt; &#123;&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>语法糖: <code>impl A</code></p>
<ul>
<li><p>表示实现了<code>A</code>这个Trait的对象.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item: &amp;<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span>) &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>约束多个特征:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>(item: &amp;(<span class="hljs-keyword">impl</span> <span class="hljs-title class_">Summary</span> + Display)) &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>注意: <code>impl A</code>一般不可以作为函数返回值的类型:</p>
<ul>
<li><p>函数可能返回<code>T</code>这个具体类型的变量, 也可能返回<code>U</code>这个具体类型的变量, 都符合<code>impl A</code>的定义(假设类型<code>T</code>和<code>U</code>都实现了<code>A</code>这个trait), 但是函数返回值只能是一个具体类型(在编译时确定).</p>
</li>
<li><p>函数返回值一般采用特征对象作为类型标注.</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>静态分发 (static dispatch):  无论是泛型的特征约束, 还是<code>impl A</code>, 都会在编译期处理完成, 编译器会为每一个泛型分配一个具体类型, 这就是静态分发.</p>
</li>
</ul>
<h4 id="trait特征约束"><a href="#trait特征约束" class="headerlink" title="trait特征约束"></a>trait特征约束</h4><ul>
<li><p>如果你要求: 一种类型在实现一个trait时, 需要先实现另一个trait, 可以使用trait特征约束:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 实现Show trait之前, 你需要为类型实现Display和Clone</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Show</span>: Display + <span class="hljs-built_in">Clone</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="特征对象"><a href="#特征对象" class="headerlink" title="特征对象"></a>特征对象</h3><ul>
<li><p>特征对象也表示实现了某个trait的对象, 但是与泛型的特征约束不同, 这个对象的具体类型在运行时才能确定下来.</p>
</li>
<li><p>特征对象类型: <code>dyn A</code></p>
<ul>
<li>注意, 特征对象只能在运行时才能确定大小, 因此需要用引用<code>&amp;</code>或者<code>Box&lt;T&gt;</code>的形式使用.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 定义一个trait</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Show</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><br><span class="hljs-comment">// 两个对象实现了这个trait</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Show</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">self</span>.name<br>  &#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Show</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-keyword">self</span>.name<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个函数, 参数是实现了Show trait的对象</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_show</span>(people: &amp;<span class="hljs-keyword">dyn</span> Show) &#123; people.<span class="hljs-title function_ invoke__">show</span>(); &#125;<br><span class="hljs-comment">// 或者使用Box&lt;dyn Show&gt;</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">call_show</span>(people: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Show&gt;) &#123; people.<span class="hljs-title function_ invoke__">show</span>(); &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>不是所有的trait都可以有特征对象, 需要满足对象安全(object safety)条件:</p>
<ul>
<li>trait中的方法没有泛型参数<code>T</code>.</li>
<li>trait的返回值不能是<code>Self</code>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么要满足对象安全条件, 才能拥有特征对象?</p>
</blockquote>
<h3 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h3><ul>
<li><p>在trait中一般不使用泛型, 一般用关联类型代替.</p>
</li>
<li><p>关联类型用<code>type</code>定义, 也可以用泛型约束.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Show</span> &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> : Display + <span class="hljs-built_in">Clone</span>;<br>  <br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br><br><span class="hljs-comment">// 实现Show trait</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Show</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-comment">// 指定具体的关联类型</span><br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = <span class="hljs-type">String</span>;<br>  <br>  <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>关联类型采用<code>Self::A</code>进行索引.</li>
</ul>
</li>
</ul>
<h3 id="完全限定语法"><a href="#完全限定语法" class="headerlink" title="完全限定语法"></a>完全限定语法</h3><ul>
<li><p>如果一个类型实现了多个trait, 不同trait中有方法同名, 那么这个类型的对象在调用方法时, 可以使用完全限定语法(Fully Qualified Syntax)规定调用哪个方法.</p>
<ul>
<li>格式是: <code>&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// trait1</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Show1</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><span class="hljs-comment">// trait2</span><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Show2</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span>;<br>&#125;<br><span class="hljs-comment">// implement trait1 and trait2 for a type</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Show1</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;&#125;<br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Show2</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">show</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">stu</span> := Student &#123;&#125;;<br>  <span class="hljs-comment">// 调用trait1中的show</span><br>  &lt;Student <span class="hljs-keyword">as</span> Show1&gt;::<span class="hljs-title function_ invoke__">show</span>(&amp;stu);<br>  <span class="hljs-comment">// 调用trait2中的show</span><br>  &lt;Student <span class="hljs-keyword">as</span> Show2&gt;::<span class="hljs-title function_ invoke__">show</span>(&amp;stu);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Option"><a href="#Option" class="headerlink" title="Option"></a><code>Option</code></h2><ul>
<li><p>在Rust中, 如果一个变量可能为<code>None</code>, 那么它的类型应该是<code>Option&lt;T&gt;</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>  <span class="hljs-title function_ invoke__">Some</span>(T),<br>  <span class="hljs-literal">None</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以利用<code>match</code>表达式和<code>if let</code>对<code>Option&lt;T&gt;</code>进行解构.</p>
</li>
<li><p><code>Option&lt;T&gt;</code>提供的解构方法:</p>
<ul>
<li><p><code>unwrap()</code>:</p>
<ul>
<li>对<code>Some(T)</code>: 可以直接拿到<code>T</code>类型的值.</li>
<li>对<code>None</code>: 程序<code>panic</code>.</li>
</ul>
</li>
<li><p><code>expect(&quot;错误信息&quot;)</code>:</p>
<ul>
<li>与<code>unwrap()</code>用法相同, 但是可以自定制<code>panic</code>后的错误信息.</li>
</ul>
</li>
<li><p>如果想从<code>Option&lt;T&gt;</code>中拿到<code>&amp;T</code>类型: 使用<code>as_ref()</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-title function_ invoke__">Some</span>(T);<br><span class="hljs-comment">// b是&amp;T类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a.<span class="hljs-title function_ invoke__">as_ref</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果想从<code>Option&lt;T&gt;</code>中拿到<code>&amp;mut T</code>类型: 使用<code>as_mut()</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-title function_ invoke__">Some</span>(T);<br><span class="hljs-comment">// b是&amp;mut T类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a.<span class="hljs-title function_ invoke__">as_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li><p>Rust中的错误分为两种:</p>
<ul>
<li>可恢复的错误: Rust提供了<code>Result&lt;T, E&gt;</code>类型.</li>
<li>不可恢复的错误: Rust提供了<code>panic!</code>宏.</li>
</ul>
</li>
<li><p><code>panic!</code>宏使用: <code>panic!(&quot;错误信息&quot;)</code></p>
<ul>
<li><p><code>panic</code>有两种处理模式:</p>
<ul>
<li><code>unwind</code>: 程序会展开调用栈, 并且依次清理函数中的数据 (工作量较大).</li>
<li><code>abort</code>: 程序直接终止调用栈, 数据由OS回收.</li>
</ul>
</li>
<li><p>在<code>release</code>模式下, 需要用<code>abort</code>模式 (可以让二进制文件更小), 在<code>Cargo.toml</code>中加上:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[profile.release]</span><br><span class="hljs-attr">panic</span> = <span class="hljs-string">&#x27;abort&#x27;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>panic</code>可能发生在源码中, 如果要定位源码的位置, 需要运行时将<code>RUST_BACKTRACE</code>设置为1.</p>
</li>
<li><p><code>panic</code>的底层原理:</p>
<ul>
<li><p>在Rust中, 处理<code>panic!</code>的函数叫做<code>panic_handler</code>, 采用<code>#[panic_handler]</code>来进行标注:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> core::panic::PanicInfo;<br><br><span class="hljs-comment">// PanicInfo会保存程序的错误位置</span><br><span class="hljs-meta">#[panic_handler]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">panic</span>(_info: &amp;PanicInfo) <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><code>Result&lt;T, E&gt;</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>  <span class="hljs-comment">// 操作成功返回T类型</span><br>  <span class="hljs-title function_ invoke__">Ok</span>(T),<br>  <span class="hljs-comment">// 操作失败返回E类型</span><br>  <span class="hljs-title function_ invoke__">Err</span>(E)<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>处理<code>Result&lt;T, E&gt;</code>的几种方法:</p>
<ul>
<li><p><code>match</code>表达式:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>  <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>  <span class="hljs-comment">// 错误类型</span><br>  <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Error opening file &#123;&#125;&quot;</span>, error);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>unwrap()</code>: 直接提取<code>Ok(T)</code>中的<code>T</code>, 如果失败就会直接<code>panic</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>expect()</code>: 在<code>unwrap()</code>的基础上, 可以自定制错误信息:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;错误信息&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>向上传递错误:</p>
<ul>
<li><p>在遇到错误的时候, 直接<code>return Err(e)</code>.</p>
</li>
<li><p>函数的返回值需要变成<code>Result&lt;T, E&gt;</code>.</p>
</li>
<li><p>Rust中还提供了<code>?</code>宏, 专门用来传播错误:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>如果函数返回<code>Ok(T)</code>, 那么<code>T</code>就会自动赋值给<code>f</code>.</p>
</li>
<li><p>如果返回<code>Err(e)</code>, 那么函数就会直接<code>return Err(e);</code></p>
</li>
<li><p>如果一个函数内部有<code>?</code>, 那么最后函数需要写一个返回值<code>Ok(T)</code>.</p>
</li>
<li><p>如果在<code>main</code>函数中需要使用<code>?</code>, 那么<code>main</code>函数的签名需要是:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Box&lt;dyn Error&gt;表示任何可能的错误类型</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>?</code>函数会隐式调用<code>From</code>函数, 将返回错误类型自动转换为函数签名所定义的错误类型.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a><code>Vector</code></h3><ul>
<li><p>Vector的类型是<code>Vec&lt;T&gt;</code>, 是由标准库提供的.</p>
<ul>
<li><p>可以存储多个值, 这些值的类型都必须相同.</p>
</li>
<li><p>如果要存放不同的数据类型, 那么可以用枚举:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Data</span> &#123;<br>  <span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-type">i32</span>),<br>  <span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-type">f64</span>),<br>  <span class="hljs-title function_ invoke__">String</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<br>  Data::<span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-number">3</span>),<br>  Data::<span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-number">3.3</span>),<br>  Data::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;3&quot;</span>),<br>];<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建<code>Vec</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用初始值创建<code>Vec</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>
</li>
<li><p>添加元素: <code>push</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>当<code>Vec&lt;T&gt;</code>离开作用域时, 会被清理掉, 但是其中的元素也会被清理掉.</p>
<ul>
<li>如果其他的地方有<code>Vec</code>中元素的索引, 就会发生问题.</li>
</ul>
</li>
<li><p>访问<code>Vec</code>中元素的两种方式:</p>
<ul>
<li>索引: 如果索引超出范围, 程序就会<code>panic</code>.</li>
<li><code>get方法</code>: 返回值是<code>Option&lt;T&gt;</code>, 如果越界会返回<code>None</code>.</li>
</ul>
</li>
<li><p><code>Vec&lt;T&gt;</code>的<code>length</code>与<code>capacity</code>:</p>
<ul>
<li><p><code>length</code>表示<code>Vec&lt;T&gt;</code>中的元素个数, 而<code>capacity</code>表示<code>Vec&lt;T&gt;</code>中底层数组的容量.</p>
</li>
<li><p>可以通过预先分配一定的<code>capacity</code>, 来减少动态数组扩容, 提高性能:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a><code>HashMap</code></h3><ul>
<li><p>引入:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br></code></pre></td></tr></table></figure>
</li>
<li><p>创建哈希表:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hashmap</span>: HashMap&lt;T, U&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure>

<ul>
<li>HashMap中, 所有的Key必须是同一种类型, 所有的Value必须是同一种类型.</li>
<li>数据存储在Heap上.</li>
</ul>
</li>
<li><p>添加元素: <code>insert</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span>: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">i32</span>&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>map.<span class="hljs-title function_ invoke__">insert</span>(a, b);<br></code></pre></td></tr></table></figure>
</li>
<li><p>HashMap的所有权问题:</p>
<ul>
<li>如果类型实现了Copy trait, 那么值会被复制到HashMap中.</li>
<li>对于有所有权的值, 所有权会转移到HashMap中, 例如调用<code>insert</code>.</li>
<li>如果将变量的引用插入HashMap, 那么HashMap有效的期间, 必须保证插入的引用有效.</li>
</ul>
</li>
<li><p>根据键获取值: <code>get</code></p>
<ul>
<li>参数: <code>&amp;T</code></li>
<li>返回值: <code>Option&lt;&amp;V&gt;</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 传入&amp;T, 返回Option&lt;&amp;U&gt;</span><br>hashmap.<span class="hljs-title function_ invoke__">get</span>(&amp;key);<br></code></pre></td></tr></table></figure>
</li>
<li><p>遍历HashMap:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// k, v都是&amp;T, &amp;U类型</span><br><span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> &amp;hashmap &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>更新HashMap: </p>
<ul>
<li><p>首先判断Key是否存在:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> hashmap.<span class="hljs-title function_ invoke__">contains</span>(&amp;key) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果key存在:</p>
<ul>
<li><p>如果要用新值覆盖, 直接再次<code>insert</code>即可.</p>
</li>
<li><p>如果要基于原来的值计算新值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 得到原来的值的&amp;mut</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = hashmap.<span class="hljs-title function_ invoke__">entry</span>(&amp;key).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 然后用*origin就可以基于原值计算</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果key不存在, 直接<code>insert</code>插入即可.</p>
</li>
</ul>
</li>
</ul>
<h2 id="多文件编程"><a href="#多文件编程" class="headerlink" title="多文件编程"></a>多文件编程</h2><h3 id="mod树状结构"><a href="#mod树状结构" class="headerlink" title="mod树状结构"></a><code>mod</code>树状结构</h3><ul>
<li><p>Rust中, 一个<code>.rs</code>文件是一个<code>mod</code>, 名字和文件名一样.</p>
<ul>
<li><code>mod</code>中可以包含各种元素, 例如常量, 函数, 结构体, trait等.</li>
</ul>
</li>
<li><p>在Rust的文件中, 声明<code>mod</code>的语句是:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// A.rs</span><br><span class="hljs-keyword">mod</span> B;<br><br><span class="hljs-comment">// 声明+定义的方式</span><br><span class="hljs-keyword">mod</span> B &#123;<br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">add</span>(a: <span class="hljs-type">i32</span>, b: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123; a + b &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>这个语句的含义是, A这个<code>mod</code>的子节点是B.</li>
</ul>
</li>
<li><p>Rust中, 一个文件夹也可以是一个<code>mod</code>, 需要在文件夹中添加<code>mod.rs</code>, 然后在其中声明文件夹内的所有<code>mod</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// mod.rs</span><br><span class="hljs-keyword">mod</span> A;<br><span class="hljs-keyword">mod</span> C;<br><span class="hljs-keyword">mod</span> D;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>mod</code>的根节点是<code>src/main.rs</code>或者是<code>src/lib.rs</code>, 根节点的名称叫做<code>crate</code>.</p>
</li>
</ul>
<h3 id="权限管理-use"><a href="#权限管理-use" class="headerlink" title="权限管理&#x2F;use"></a>权限管理&#x2F;<code>use</code></h3><ul>
<li><p>如果一个<code>mod</code>中的元素需要被其他<code>mod</code>导入, 需要在前面加上<code>pub</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> MAX_NUM: <span class="hljs-type">i32</span> = <span class="hljs-number">1000</span>;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">notify</span>&lt;T&gt;(item: &amp;T) &#123;&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果需要导入其他<code>mod</code>中的元素, 可以使用<code>use</code>关键字:</p>
<ul>
<li><p>首先确定你用<code>mod</code>声明语句建立好了<code>mod</code>树.</p>
</li>
<li><p>使用绝对路径: 从<code>crate</code>开始向下找:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> crate::A::B;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用相对路径:</p>
<ul>
<li><code>super</code>: 表示当前<code>mod</code>的父亲<code>mod</code>.</li>
<li><code>self</code>: 表示当前<code>mod</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><ul>
<li><p><code>format!</code>可以用来生成<code>String</code>类型的格式化字符串:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;world&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, a, b);<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>println!()</code>用来打印输出:</p>
<ul>
<li><code>&#123;&#125;</code>占位符适合实现了<code>Display</code> trait的类型.</li>
<li><code>&#123;:?&#125;</code>或者<code>&#123;:#?&#125;</code>适合实现了<code>Debug</code> trait的类型.</li>
</ul>
</li>
</ul>
<h3 id="Display"><a href="#Display" class="headerlink" title="Display"></a><code>Display</code></h3><ul>
<li><p><code>Display</code>这个trait一般用来更加美化地输出一个类型信息:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">usize</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Display</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> std::fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> std::fmt::<span class="hljs-type">Result</span> &#123;<br>      <span class="hljs-comment">// 第二个参数是格式化字符串, 后面是具体的参数</span><br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;Student Name &#123;&#125;, Student age &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.age)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a><code>Debug</code></h3><ul>
<li><p><code>Debug</code>用来输出与这个类型有关的调试信息:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">usize</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::<span class="hljs-built_in">Debug</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    name: <span class="hljs-type">String</span>,<br>    age: <span class="hljs-type">usize</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Debug</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-comment">// 实现方式和Display相同</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> std::fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> std::fmt::<span class="hljs-type">Result</span> &#123;<br>        <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;Student Name &#123;&#125;, Student age &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.name, <span class="hljs-keyword">self</span>.age)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li><p>闭包是一种可以使用调用者作用域变量的匿名函数.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">|param1, param2, param3, ...| &#123;<br>  Statement1;<br>  Statement2;<br>  <span class="hljs-comment">//...</span><br>  Expression<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = |x: <span class="hljs-type">i32</span>, y: <span class="hljs-type">i32</span>| &#123;<br>  	x + y<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>闭包的所有权问题:</p>
<ul>
<li>闭包内可以使用调用者作用域的变量, 但是变量的所有权可能会发生转移, 里面涉及三个trait:<ul>
<li><code>FnOnce</code>: 闭包内会拿走外部作用域变量的所有权, 因此这个闭包只能运行一次.</li>
<li><code>Fn</code>: 以不可变借用捕获外部作用域的变量.</li>
<li><code>FnMut</code>: 以可变借用捕获外部作用域的变量.</li>
</ul>
</li>
</ul>
</li>
<li><p>闭包的类型表达式:</p>
<ul>
<li>闭包一般用<code>impl A</code>或者<code>Box(dyn A)</code>标注类型, 例如:<ul>
<li><code>Box&lt;dyn FnOnce(i32, i32) -&gt; i32&gt;</code>.</li>
<li><code>Box&lt;dyn Fn(i32, i32) -&gt; i32&gt;</code>.</li>
<li><code>Box&lt;dyn FnMut(i32, i32) -&gt; i32&gt;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>如何确定一个闭包实现了哪个trait ?</p>
</blockquote>
<ul>
<li><p>取决于这个闭包内, 如何使用外部变量.</p>
<ul>
<li>所有闭包默认实现了<code>FnOnce</code>, 确保闭包能够调用一次.</li>
<li>如果闭包内没有对变量进行改变, 那么就实现了<code>Fn</code>.</li>
<li>如果闭包内对变量进行了改变, 并且没有返回变量的所有权, 那么就实现了<code>FnMut</code>.</li>
</ul>
</li>
<li><p><code>move</code>关键字:</p>
<ul>
<li><p><code>move</code>关键字可以强制闭包夺取外部变量的所有权.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, v);<br>&#125;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>为什么需要<code>move</code>关键字:</p>
<ul>
<li>有些情况下, 闭包的生命周期可能比外部变量的更长 (例如多线程).</li>
<li>如果不夺去所有权的话, 外部变量被回收内存后, 闭包中再使用这个变量的引用就会出问题.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li><p>与迭代器相关的trait一共有两个:</p>
<ul>
<li><p><code>Iterator</code>: 如果一个类型实现了这个trait, 那么它就是迭代器:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>IntoIterator</code>: 如果一个集合实现了这个trait, 那么它就可以转化为迭代器.</p>
</li>
</ul>
</li>
<li><p>将集合转化为迭代器的方法:</p>
<ul>
<li><code>into_iter()</code>: 返回的元素类型是<code>T</code>, 会拿走集合变量的所有权.</li>
<li><code>iter()</code>: 返回的元素类型是<code>&amp;T</code>, 是集合变量的不可变引用.</li>
<li><code>iter_mut()</code>: 返回的元素类型是<code>&amp;mut T</code>, 是集合变量的可变引用.</li>
</ul>
</li>
</ul>
<h3 id="迭代器消费者-收集者"><a href="#迭代器消费者-收集者" class="headerlink" title="迭代器消费者&#x2F;收集者"></a>迭代器消费者&#x2F;收集者</h3><ul>
<li><p>如果要对一个集合中的元素进行运算, 并且将运算结果打包成一个新的集合, 可以使用迭代器消费者&#x2F;收集者.</p>
</li>
<li><p>迭代器消费者负责运算, 生成新的迭代器</p>
<ul>
<li>迭代器消费者的参数可以是闭包类型.</li>
<li>常见的迭代器消费者有<code>map, zip</code>等.</li>
</ul>
</li>
<li><p>迭代器收集者负责将迭代器转换为指定类型的集合, 一般用<code>collect</code>函数.</p>
<ul>
<li>使用<code>collect</code>函数时, 一般需要进行类型标注.</li>
</ul>
</li>
<li><p><code>map + collect</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v1</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// _是什么类型会自动推断</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">v2</span>: <span class="hljs-type">Vec</span>&lt;_&gt; = v1.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|x| x + <span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">collect</span>(); <br></code></pre></td></tr></table></figure>
</li>
<li><p><code>zip + collect</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">keys</span> = [<span class="hljs-string">&quot;h1&quot;</span>,<span class="hljs-string">&quot;h2&quot;</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">values</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">hashmap</span>: HashMap&lt;_, _&gt; = keys.<span class="hljs-title function_ invoke__">into_iter</span>().<span class="hljs-title function_ invoke__">zip</span>(values.<span class="hljs-title function_ invoke__">into_iter</span>()).<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>String</code>字符串逆序:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>: <span class="hljs-type">String</span> = a.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">rev</span>().<span class="hljs-title function_ invoke__">collect</span>();<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="Deref"><a href="#Deref" class="headerlink" title="Deref"></a><code>Deref</code></h3><ul>
<li><p><code>Deref</code>是一个trait, 实现了这个trait的类型可以具有智能指针的行为.</p>
<ul>
<li>一个类型为<code>T</code>的对象, 如果实现了<code>Deref&lt;Target=U&gt;</code>, 那么在使用<code>&amp;T/&amp;mut T</code>类型或者<code>Box&lt;T&gt;</code>类型的引用时, 就会被自动转换成<code>&amp;U</code>.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Deref</span> &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span>;<br>  <span class="hljs-comment">// deref函数负责将原始类型的引用, 转换为Target类型的不可变引用</span><br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">Self</span>::Target;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>如果需要将<code>&amp;mut T</code>自动转换为<code>&amp;mut U</code>, 需要<code>DerefMut&lt;Target=U&gt;</code> trait.</li>
</ul>
</li>
<li><p><code>Deref</code>的优势:</p>
<ul>
<li><p>如果一个类型实现了<code>Deref</code>, 那么它的引用当作参数传递时, 会根据函数的签名自动解引用到对应的数据类型:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(s: &amp;<span class="hljs-type">str</span>) &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, s);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>));<br>  <span class="hljs-comment">// &amp;String类型会连续调用deref转换成&amp;str.</span><br>  <span class="hljs-title function_ invoke__">display</span>(&amp;s);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a><code>Drop</code></h3><ul>
<li><p>如果一个类型实现了<code>Drop</code>这个trait, 那么这个类型的变量在超出作用域后, 会自动执行一段代码.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">XXX</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>Drop</code> trait一般用于回收内存资源, 以及做一些收尾工作.</li>
</ul>
</li>
<li><p>Rust基本为几乎所有的类型实现了<code>Drop</code>, 因此超过作用域后, 内存资源都会被释放:</p>
<ul>
<li>变量按照逆序进行释放.</li>
<li>结构体中的变量按照顺序进行释放.</li>
</ul>
</li>
<li><p>手动提前释放: 可以使用<code>std::mem::drop</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br><span class="hljs-comment">// drop函数会拿走变量的所有权</span><br><span class="hljs-title function_ invoke__">drop</span>(a);<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果一个类型实现了<code>Copy</code>, 那么它就不能实现<code>Drop</code>.</p>
</li>
</ul>
<h3 id="Box"><a href="#Box" class="headerlink" title="Box&lt;T&gt;"></a><code>Box&lt;T&gt;</code></h3><ul>
<li><p><code>Box&lt;T&gt;</code>是一个智能指针类型, 可以强制让<code>T</code>类型的数据存储在堆上, 并且返回值的引用.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 3存储在堆上</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li>注意: <code>Box::new(T)</code>会拿走原始数据的所有权.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br><span class="hljs-comment">// s的所有权转移到s_box</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">s_box</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(s);<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>Box&lt;T&gt;</code>的使用场景:</p>
<ul>
<li>特征对象<code>Box&lt;dyn T&gt;</code>.</li>
<li>将动态类型转换成已知大小的类型.</li>
<li>实现了<code>Copy</code> trait的数据过大, 转移所有权时需要避免拷贝:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>([<span class="hljs-number">10</span>; <span class="hljs-number">1000</span>]);<br><span class="hljs-comment">// 此时arr所有权转移到arr_new, 并没有发生数据拷贝</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr_new</span> = arr;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Rc-Arc"><a href="#Rc-Arc" class="headerlink" title="Rc&lt;T&gt;/Arc&lt;T&gt;"></a><code>Rc&lt;T&gt;/Arc&lt;T&gt;</code></h3><ul>
<li><p><code>Rc&lt;T&gt;</code>可以实现对于一个值, 有多个不可变引用, 并且只有所有不可变引用都被<code>drop</code>后, 值才会被<code>drop</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-comment">// 第一个引用, a</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>));<br><span class="hljs-comment">// 第二个引用</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a);<br></code></pre></td></tr></table></figure>

<ul>
<li><code>Rc&lt;T&gt;</code>变量同时实现了<code>Deref</code>和<code>Drop</code>.</li>
<li><code>Rc&lt;T&gt;</code>类型没有实现<code>Send</code> trait, 因此无法在多线程间传递.</li>
</ul>
</li>
<li><p><code>Arc&lt;T&gt;</code>是实现了<code>Send</code>的<code>Rc&lt;T&gt;</code>, 可以在多线程之间传递所有权.</p>
<ul>
<li>用法和<code>Rc&lt;T&gt;</code>一致.</li>
<li>所在的包是<code>std::sync::Arc</code>.</li>
<li><code>Arc&lt;T&gt;</code>采用了原子指令维护引用计数, 因此有一定的性能损耗.</li>
</ul>
</li>
</ul>
<h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell&lt;T&gt;"></a><code>RefCell&lt;T&gt;</code></h3><ul>
<li><p><code>RefCell&lt;T&gt;</code>可以对不可变的变量进行可变借用.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::cell::RefCell;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">val</span> = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">10</span>);<br>*val.<span class="hljs-title function_ invoke__">borrow_mut</span>() += <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用<code>RefCell&lt;T&gt;</code>依然要遵循Rust的借用规则, 如果不遵循, 会在运行时<code>panic</code>, 而不会编译器出错.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>));<br><span class="hljs-comment">// 报错, 不可变引用和可变引用同时存在</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = s.<span class="hljs-title function_ invoke__">borrow</span>();<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = s.<span class="hljs-title function_ invoke__">borrow_mut</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>Rc&lt;T&gt;</code>可以和<code>RefCell&lt;T&gt;</code>一起使用, 实现可变引用和不可变引用同时存在.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(RefCell::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>)));<br><br><span class="hljs-comment">// 对RefCell的多个不可变引用</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;s);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;s);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;s);<br><br><span class="hljs-comment">// RefCell对内部的值进行可变借用</span><br>c.<span class="hljs-title function_ invoke__">borrow_mut</span>().<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;world&quot;</span>);<br><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, *s.<span class="hljs-title function_ invoke__">borrow</span>());<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>RefCell&lt;T&gt;</code>没有实现<code>Send</code> trait, 不能在多线程环境下使用.</p>
</li>
</ul>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><ul>
<li>Rust中的线程库是<code>std::thread</code>.</li>
</ul>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><ul>
<li><p>创建线程可以使用<code>thread::spawn</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>  &#125;);<br>  <br>  handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>由于Rust在编译时不确定线程会存活多久, 因此闭包中需要强制用<code>move</code>把外部变量的所有权拿走.</li>
<li><code>main</code>线程需要等待所有子线程结束后再退出, 因此需要对子线程调用<code>join().unwrap()</code>.</li>
</ul>
</li>
</ul>
<h3 id="Send-Sync"><a href="#Send-Sync" class="headerlink" title="Send/Sync"></a><code>Send/Sync</code></h3><ul>
<li>如果一个类型<code>T</code>实现了<code>Send</code>特征, 那么这个类型可以在线程之间传递所有权.<ul>
<li>也就是说, 一个值, 如果有办法让多个线程都能读&#x2F;写到 (不保证多个线程有值的引用.), 那么对应类型就实现了<code>Send</code>.</li>
</ul>
</li>
<li>如果一个类型<code>T</code>实现了<code>Sync</code>特征, 那么这个类型可以在线程之间, 通过引用进行共享.</li>
<li>特征约束: 如果<code>&amp;T</code>实现了<code>Send</code>特征, 那么<code>T</code>就实现了<code>Sync</code>特征.</li>
<li>Rust中, 绝大部分类型都实现了<code>Send/Sync</code> trait, 可以通过<code>#[derive()]</code>进行自动实现.<ul>
<li>没有实现的: <code>Rc</code>, <code>RefCell</code>.</li>
</ul>
</li>
</ul>
<h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex&lt;T&gt;"></a><code>Mutex&lt;T&gt;</code></h3><ul>
<li><p>Rust中的互斥锁是<code>std::sync::Mutex</code>, 可以保证一个线程修改临界区数据时, 不会被其他线程打断.</p>
</li>
<li><p><code>Mutex&lt;T&gt;</code>本质上是一种智能指针, 可以通过<code>Mutex&lt;T&gt;</code>创建数据的可变引用, 并且通过这个可变引用修改数据时, 不会被其他线程打断.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 上锁, 获取可变引用进行修改</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">value</span> = m.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>*value += <span class="hljs-number">2</span><br><span class="hljs-comment">// 超过作用域后释放锁</span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>Mutex&lt;T&gt;</code>实现了<code>Sync</code> trait, 可以让多个线程以引用的形式共享一个<code>Mutex</code>.</li>
<li><code>Mutex</code>有一个泛型约束, 要求<code>T</code>实现<code>Send</code> trait, 因为这个值不能仅仅停留在一个线程, 需要在多个线程中都能获取到.</li>
</ul>
</li>
<li><p>如果一个类型<code>T</code>的数据要在多线程间共享, 那么应该使用<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>类型.</p>
<ul>
<li><code>Arc</code>实现了<code>Send</code> trait, 可以在一个线程中对<code>Mutex&lt;T&gt;</code>创建多个不可变引用, 并且将这些引用转移到不同线程.</li>
<li><code>Mutex&lt;T&gt;</code>实现了<code>Sync</code> trait, 可以让多个线程以引用的形式共享.</li>
<li><code>Mutex&lt;T&gt;</code>还可以保证在线程中, 以可变引用的形式修改临界区数据<code>T</code>时, 不会被其他线程打断.</li>
</ul>
</li>
</ul>
<p>一个例子: 多线程从1数到10</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::sync::Arc;<br><span class="hljs-keyword">use</span> std::sync::Mutex;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">m_main</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">handles</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">m</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;m_main);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">handle</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">value</span> = m.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            *value += <span class="hljs-number">1</span>;<br>        &#125;);<br>        handles.<span class="hljs-title function_ invoke__">push</span>(handle);<br>    &#125;<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">handle</span> <span class="hljs-keyword">in</span> handles &#123;<br>        handle.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, m_main.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Condvar"><a href="#Condvar" class="headerlink" title="Condvar"></a><code>Condvar</code></h3><ul>
<li>条件变量<code>Condvar</code>在<code>std::sync::Condvar</code>中, 可以保证一个线程在另一个线程满足一定条件后再执行.</li>
<li>由于<code>Condvar</code>也要在多个线程中共享, 因此也需要配合<code>Arc&lt;T&gt;</code>一起使用.</li>
<li>使用方式:<ul>
<li>首先创建<code>Arc&lt;Condvar&gt;</code>类型的条件变量, 然后<code>clone</code>到两个线程.</li>
<li>其中一个线程中, 调用<code>wait</code>阻塞线程, 并且暂时释放锁.</li>
<li>在另一个线程中, 如果满足条件, 调用<code>notify</code>唤醒线程.</li>
</ul>
</li>
</ul>
<p>一个例子: 等待计数器为10时, 唤醒线程:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::time::Duration;<br><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Mutex, Condvar&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cond</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Condvar::<span class="hljs-title function_ invoke__">new</span>());<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter1</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;counter);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">counter2</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;counter);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cond1</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;cond);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cond2</span> = Arc::<span class="hljs-title function_ invoke__">clone</span>(&amp;cond);<br><br>    <span class="hljs-comment">// 等待counter变成10</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">m</span> = counter1.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-keyword">if</span> *m != <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;counter is not 10, wait...&quot;</span>);<br>            m = cond1.<span class="hljs-title function_ invoke__">wait</span>(m).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        &#125;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;counter is &#123;&#125;&quot;</span>, *m);<br>    &#125;);<br><br>    <span class="hljs-comment">// 将counter变成10</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">m</span> = counter2.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123;<br>            *m = *m + <span class="hljs-number">1</span>;<br>          <span class="hljs-comment">// 1s加1次</span><br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>        cond2.<span class="hljs-title function_ invoke__">notify_one</span>();<br>    &#125;);<br>    handle1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    handle2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a><code>channel</code></h3><ul>
<li><code>channel</code>可以用于本地两个线程之间的通信, 采用的是生产者-消费者模型.</li>
<li>Rust中使用最多的是多生产者, 单消费者的<code>channel</code>, 在<code>std::sync::mpsc</code>中.</li>
</ul>
<p>例子: 一个线程发送消息给另一个线程:<br>  <figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::thread;<br><span class="hljs-keyword">use</span> std::sync::mpsc;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><br>    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::<span class="hljs-title function_ invoke__">channel</span>();<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle1</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        tx.<span class="hljs-title function_ invoke__">send</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">handle2</span> = thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = rx.<span class="hljs-title function_ invoke__">recv</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Receiver got &#123;&#125;&quot;</span>, value);<br>    &#125;);<br>    handle1.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>    handle2.<span class="hljs-title function_ invoke__">join</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure></p>
<ul>
<li>其中, <code>tx, rx</code>分别是<code>mpsc::Sender&lt;T&gt;</code>和<code>mpsc::Receiver&lt;T&gt;</code>类型, 具体类型编译器会推导.</li>
<li>如果需要多个发送者, 只需要将<code>tx.clone()</code>即可.</li>
<li>调用<code>send</code>时, 原数据如果没有实现<code>Copy</code> trait, 会被夺走所有权.</li>
</ul>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a><code>I/O</code></h2><ul>
<li>Rust中, 与I&#x2F;O相关的元素大部分在<code>std::io</code>中.</li>
</ul>
<h3 id="Read-Write"><a href="#Read-Write" class="headerlink" title="Read/Write"></a><code>Read/Write</code></h3><ul>
<li><p>对于I&#x2F;O来说, 最重要的两个trait是<code>Read/Write</code>, 它们在<code>std::io::&#123;Read, Write&#125;</code>.</p>
<ul>
<li><p><code>Read</code>: 实现了这个trait的类型叫做<code>Reader</code>, 可以使用<code>read</code>方法, 把数据读取到<code>&amp;mut [u8]</code>中.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 返回值是成功写入的字节数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;<span class="hljs-keyword">mut</span> [<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">usize</span>&gt;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>Write</code>: 实现了这个trait的类型叫做<code>Writer</code>, 可以用<code>write</code>把数据写入<code>&amp;mut [u8]</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 返回值是成功写入的字节数</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">write</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, buf: &amp;[<span class="hljs-type">u8</span>]) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">usize</span>&gt;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>除了<code>read</code>和<code>write</code>, <code>Read/Write</code> trait中还提供了很多封装的方法, 用来将数据从<code>reader/writer</code>读取&#x2F;写入.</p>
</li>
</ul>
<h3 id="I-O异常"><a href="#I-O异常" class="headerlink" title="I/O异常"></a><code>I/O</code>异常</h3><ul>
<li><p><code>I/O</code>异常定义在<code>std::io::Result&lt;T&gt;</code>, 定义是:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span>&lt;T&gt; = <span class="hljs-type">Result</span>&lt;T, std::io::Error&gt;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>处理<code>I/O</code>异常的一般方法:</p>
<ul>
<li>在<code>I/O</code>操作后面用<code>?</code>.</li>
<li><code>I/O</code>操作所在函数的返回值就是<code>io::Result&lt;T&gt;</code>.</li>
</ul>
</li>
</ul>
<h3 id="BufReader-BufWriter"><a href="#BufReader-BufWriter" class="headerlink" title="BufReader/BufWriter"></a><code>BufReader/BufWriter</code></h3><ul>
<li>对于一个<code>reader/writer</code>, 如果你需要多次调用<code>read/write</code>方法, 那么就会涉及多次系统调用, 性能较低.</li>
<li>这时可以使用<code>BufReader/BufWriter</code>, 在每一次读&#x2F;写时, 都会把一些多的数据读取到<code>Buffer</code>中, 下一次<code>read/write</code>就可以从<code>Buffer</code>中进行操作, 可以提高性能.</li>
</ul>
<blockquote>
<p>例子: 读取一个文件的每一行</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> std::io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>  <br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;log.txt&quot;</span>)?;<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">reader</span> = BufReader::<span class="hljs-title function_ invoke__">new</span>(f);<br>  <br>  <span class="hljs-keyword">for</span> <span class="hljs-variable">line</span> <span class="hljs-keyword">in</span> reader.<span class="hljs-title function_ invoke__">lines</span>() &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="网络I-O"><a href="#网络I-O" class="headerlink" title="网络I/O"></a>网络<code>I/O</code></h3><ul>
<li>网络<code>I/O</code>的包大部分在<code>std::net</code>中.</li>
</ul>
<h4 id="TCP-Client-Server"><a href="#TCP-Client-Server" class="headerlink" title="TCP Client/Server"></a><code>TCP Client/Server</code></h4><ul>
<li><p>如果要构建<code>TCP Server</code>, 需要使用<code>std::net::TcpListener</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;127.0.0.1:9999&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br><br><span class="hljs-comment">// 接收</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">stream</span> <span class="hljs-keyword">in</span> listener.<span class="hljs-title function_ invoke__">incoming</span>() &#123;<br>  <span class="hljs-comment">// stream是reader和writer</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stream</span> = stream.<span class="hljs-title function_ invoke__">unwrap</span>();<br>  <span class="hljs-title function_ invoke__">handle_connection</span>(&amp;<span class="hljs-keyword">mut</span> stream);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>对<code>stream</code>调用<code>read/write</code>相当于通过<code>TCP</code>协议发送消息.</li>
</ul>
</li>
<li><p>如果要构建<code>TCP Client</code>, 需要使用<code>std::net::TcpStream</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stream</span> = TcpStream::<span class="hljs-title function_ invoke__">connect</span>(<span class="hljs-string">&quot;127.0.0.1:9999&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br><span class="hljs-comment">// stream也是reader/writer</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul>
<li><p>在Rust中, 每一个变量都会有自己的生命周期, 只有在生命周期时, 使用引用变量<code>&amp;T/&amp;mut T</code>才有效.</p>
</li>
<li><p>在函数&#x2F;方法&#x2F;结构体中, 有隐含的生命周期约束:</p>
<ul>
<li>函数&#x2F;方法的参数如果是引用, 那么引用参数对应的原变量的生命周期, 必须大于等于返回值变量的生命周期.</li>
<li>结构体的字段如果是引用, 那么字段对应的原变量的生命周期, 必须大于等于结构体变量的生命周期.</li>
</ul>
</li>
<li><p>但是, 在定义这种函数&#x2F;结构体时, 往往无法在编译时确定生命周期的大小关系, 这时候就需要手动标注生命周期:</p>
<ul>
<li><p>标注生命周期的函数:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>  <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>    x<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    y<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>结构体:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>  part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>生命周期消除语法: 有的时候, 函数参数是引用&#x2F;结构体字段是引用并不需要标注, Rust可以采用消除语法来自动进行标注, 规则如下:</p>
<ul>
<li>每一个引用参数都会获得自己的生命周期参数<code>&#39;a</code>.</li>
<li>如果只有一个输入生命周期(函数的引用参数&#x2F;结构体的引用字段), 那么这个引用参数<code>&#39;a</code>就会自动被标注到所有的输出生命周期中.</li>
<li>如果有多个输入生命周期, 但是有一个是<code>&amp;self/&amp;mut self</code>, 那么<code>&amp;self/&amp;mut self</code>的生命周期会被标注到所有的输出生命周期中.</li>
</ul>
</li>
</ul>
<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><h3 id="Sized-Sized"><a href="#Sized-Sized" class="headerlink" title="Sized/?Sized"></a><code>Sized/?Sized</code></h3><ul>
<li><code>Sized</code> trait表示一个类型在编译时期可以知道大小.<ul>
<li>所有的泛型参数, 在使用时, 均隐式进行了泛型约束: <code>T: Sized</code>.</li>
</ul>
</li>
<li><code>?Sized</code> trait表示一个类型可能是静态类型, 也可能动态类型.<ul>
<li>如果要使用动态类型, 需要<code>T: ?Sized</code>.</li>
</ul>
</li>
</ul>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><ul>
<li><p>异步编程包括两个元素: <code>Future</code>以及<code>Executor</code>:</p>
<ul>
<li><code>Future</code>可以理解为是一个异步任务.</li>
<li><code>Executor</code>是<code>Future</code>的执行器, 负责调度多个<code>Future</code>进行执行.</li>
<li>当<code>Future</code>被阻塞时, <code>Executor</code>可以调度其他的<code>Future</code>执行.</li>
</ul>
</li>
<li><p>Rust中最好的异步运行环境是<code>tokio</code>, 在<code>Cargo.toml</code>中加入:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1&quot;</span>, features = [<span class="hljs-string">&quot;full&quot;</span>] &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/.await"></a><code>async/.await</code></h3><ul>
<li><p>使用<code>async</code>标注的函数&#x2F;语法块, 调用后, 会产生一个<code>Future</code>对象.</p>
</li>
<li><p>在<code>async</code>函数&#x2F;语法块内部, 调用其他的<code>async</code>函数可以使用<code>.await</code>:</p>
<ul>
<li>调用<code>.await</code>后, 只有等被调用的函数结束之后, 才能继续执行外层函数, <code>.await</code>可以规定<code>Future</code>之间执行的顺序.</li>
</ul>
</li>
</ul>
<p>例子: 异步打印1, 2, 3:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_one</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_two</span>() &#123;<br>    <span class="hljs-title function_ invoke__">print_one</span>().<span class="hljs-keyword">await</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_three</span>() &#123;<br>    <span class="hljs-title function_ invoke__">print_two</span>().<span class="hljs-keyword">await</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    tokio::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-title function_ invoke__">print_three</span>()).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a><code>Future</code></h3><h3 id="Pin-Unpin"><a href="#Pin-Unpin" class="headerlink" title="Pin/Unpin"></a><code>Pin/Unpin</code></h3><p>在Rust中, 一个变量的内存地址是可能会被移动的. 这种移动会引发一些问题, 考虑以下几个场景:</p>
<ul>
<li><p>场景1: <strong>裸指针自引用结构体</strong></p>
<ul>
<li><p>考虑如下这个自引用结构体:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SelfRef</span> &#123;<br>  value: <span class="hljs-type">String</span>,<br>  <span class="hljs-comment">// 这个裸指针指向成员变量value</span><br>  pointer_to_value: *<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果<code>value</code>在内存中的位置发生了移动, 那么<code>pointer_to_value</code>存储的内存地址就不对了.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>构造一个样例, 来解释变量在栈内存中的移动?</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> &#123;<br>    data: <span class="hljs-type">usize</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SelfRef</span> &#123;<br>    data: Data,<br>    data_ref: *<span class="hljs-keyword">const</span> Data<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SelfRef</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(data: Data) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            data,<br>            data_ref: std::ptr::<span class="hljs-title function_ invoke__">null</span>()<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.data_ref = &amp;<span class="hljs-keyword">self</span>.data;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_info</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Actual Data Address: &#123;:p&#125;, Actual Data Content: &#123;&#125;, Value of data_ref: &#123;:p&#125;&quot;</span>,<br>            &amp;<span class="hljs-keyword">self</span>.data,<br>            <span class="hljs-keyword">self</span>.data.data,<br>            <span class="hljs-keyword">self</span>.data_ref<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在函数中, 将SelfRef变量的所有权返回, 那么原始变量在</span><br><span class="hljs-comment">// 栈中的内存会发生移动</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test</span>() <span class="hljs-punctuation">-&gt;</span> SelfRef &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">self_ref</span> = SelfRef::<span class="hljs-title function_ invoke__">new</span>(Data &#123; data: <span class="hljs-number">1</span> &#125;);<br>    self_ref.<span class="hljs-title function_ invoke__">init</span>();<br>    self_ref.<span class="hljs-title function_ invoke__">print_info</span>();<br>    self_ref<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">self_ref</span> = <span class="hljs-title function_ invoke__">test</span>();<br>    self_ref.<span class="hljs-title function_ invoke__">print_info</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段程序的运行结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Actual Data Address: 0x16eec2288, Actual Data Content: 1, Value of data_ref: 0x16eec2288<br>Actual Data Address: 0x16eec22b0, Actual Data Content: 1, Value of data_ref: 0x16eec2288<br></code></pre></td></tr></table></figure>

<p>很明显, <code>Actual Data Address</code>已经发生了改变, 但是<code>Value of data_ref</code>没有改变, 再使用<code>data_ref</code>就会发生不可预期的错误.</p>
<blockquote>
<p>构造一个样例, 解释变量在堆内存中的移动?</p>
</blockquote>
<h2 id="cargo项目管理"><a href="#cargo项目管理" class="headerlink" title="cargo项目管理"></a><code>cargo</code>项目管理</h2><h3 id="注释与文档"><a href="#注释与文档" class="headerlink" title="注释与文档"></a>注释与文档</h3><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul>
<li>假设你在你的<code>.rs</code>文件中写好了函数, 现在需要测试函数的功能.</li>
<li>直接在<code>.rs</code>文件的最后, 加上这些: 其中<code>test_XXX1()</code>就是针对某个函数的测试函数.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>  <br>  <span class="hljs-keyword">use</span> super::*;<br>  <br>  <span class="hljs-comment">// 测试函数, 可以写多个</span><br>  <span class="hljs-meta">#[test]</span><br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_XXX1</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(...);<br>  &#125;<br>  <br>  <span class="hljs-meta">#[test]</span><br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_XXX2</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(...);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>写好之后, 直接使用<code>cargo test</code>就可以进行测试.</li>
</ul>
<h2 id="Unsafe-Rust"><a href="#Unsafe-Rust" class="headerlink" title="Unsafe Rust"></a><code>Unsafe Rust</code></h2><h3 id="裸指针"><a href="#裸指针" class="headerlink" title="裸指针"></a>裸指针</h3><ul>
<li><p>Rust中, 裸指针(raw pointer)分为一下两种类型:</p>
<ul>
<li><p><code>*const T</code>: 不能通过裸指针修改原数据.</p>
</li>
<li><p><code>*mut T</code>: 可以通过裸指针修改原数据.</p>
</li>
</ul>
</li>
<li><p>打印变量的地址, 首先把它转成裸指针, 然后用<code>&#123;:p&#125;</code>打印.</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">ptr</span> = &amp;a <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> T;<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:p&#125;&quot;</span>, ptr);<br></code></pre></td></tr></table></figure>

      
       <hr><span style="font-style: italic;color: gray;"> 向阳而生, 喜欢聪明的人. </span>
    </div>
</article>







    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©B1ueDrops
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
