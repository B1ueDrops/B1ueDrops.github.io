<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Rust使用日记 | B1ueDrops</title>
  <meta name="keywords" content="">
  <meta name="description" content="Rust使用日记 | B1ueDrops">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="向阳而生, 喜欢聪明的人.">
<meta property="og:type" content="website">
<meta property="og:title" content="B1ueDrops">
<meta property="og:url" content="https://b1uedrops.github.io/about.html">
<meta property="og:site_name" content="B1ueDrops">
<meta property="og:description" content="向阳而生, 喜欢聪明的人.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-02-09T08:49:59.399Z">
<meta property="article:modified_time" content="2024-02-09T08:49:59.394Z">
<meta property="article:author" content="B1ueDrops">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpeg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpeg"/>
</a>
<div class="author">
    <span>B1ueDrops</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/B1ueDrops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:bluedrops@yeah.net"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2381446488&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(69)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="编程语言">
            
            编程语言
            <small>(12)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="工具/环境">
            
            工具/环境
            <small>(7)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="计算机网络">
            
            计算机网络
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="金融知识">
            
            金融知识
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="脑机接口">
            
            脑机接口
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="软件工程">
            
            软件工程
            <small>(7)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="社会技能">
            
            社会技能
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(15)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="体系结构">
            
            体系结构
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="信号处理">
            
            信号处理
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="AI">
            
            AI
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="English">
            
            English
            <small>(10)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="UNIX编程">
            
            UNIX编程
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="69">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All 编程语言 "
           href="/2024/05/17/compile-link/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="程序的链接">程序的链接</span>
            <span class="post-date" title="2024-05-17 12:33:47">2024/05/17</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/14/regular_expression/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="正则表达式原理和实战">正则表达式原理和实战</span>
            <span class="post-date" title="2024-05-14 20:14:59">2024/05/14</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/05/14/recursion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="递归系列">递归系列</span>
            <span class="post-date" title="2024-05-14 16:02:10">2024/05/14</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/05/14/probability/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="概率论与数理统计">概率论与数理统计</span>
            <span class="post-date" title="2024-05-14 10:20:01">2024/05/14</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/13/restaurant_english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="饭店相关英语">饭店相关英语</span>
            <span class="post-date" title="2024-05-13 20:25:52">2024/05/13</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/05/13/combine_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="组合型的设计模式">组合型的设计模式</span>
            <span class="post-date" title="2024-05-13 20:11:49">2024/05/13</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/12/frontend-lang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前端语言使用日记">前端语言使用日记</span>
            <span class="post-date" title="2024-05-12 21:13:45">2024/05/12</span>
        </a>
        
        
        <a  class="All UNIX编程 "
           href="/2024/05/12/linux_process/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux上的进程控制">Linux上的进程控制</span>
            <span class="post-date" title="2024-05-12 13:03:52">2024/05/12</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/12/other-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="其他地道的英语表达">其他地道的英语表达</span>
            <span class="post-date" title="2024-05-12 12:38:31">2024/05/12</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/12/hotel-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="酒店相关英语">酒店相关英语</span>
            <span class="post-date" title="2024-05-12 12:29:02">2024/05/12</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2024/05/11/network_network_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="网络层">网络层</span>
            <span class="post-date" title="2024-05-11 18:21:44">2024/05/11</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2024/05/10/network_application_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="应用层">应用层</span>
            <span class="post-date" title="2024-05-10 20:46:30">2024/05/10</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/10/airport-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机场相关英语">机场相关英语</span>
            <span class="post-date" title="2024-05-10 10:12:57">2024/05/10</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/09/english-writing/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语写作背诵文章">英语写作背诵文章</span>
            <span class="post-date" title="2024-05-09 21:11:19">2024/05/09</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/09/practical-go/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Go语言使用日记">Go语言使用日记</span>
            <span class="post-date" title="2024-05-09 20:48:25">2024/05/09</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/05/09/database-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostgreSQL数据库教程">PostgreSQL数据库教程</span>
            <span class="post-date" title="2024-05-09 20:24:37">2024/05/09</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/05/09/cache-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cache的基础知识与设计策略">Cache的基础知识与设计策略</span>
            <span class="post-date" title="2024-05-09 20:12:19">2024/05/09</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/05/09/sort-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基础排序算法和应用">基础排序算法和应用</span>
            <span class="post-date" title="2024-05-09 17:10:04">2024/05/09</span>
        </a>
        
        
        <a  class="All 社会技能 "
           href="/2024/04/26/secure_drive/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="安全驾驶知识">安全驾驶知识</span>
            <span class="post-date" title="2024-04-26 19:53:53">2024/04/26</span>
        </a>
        
        
        <a  class="All 金融知识 "
           href="/2024/04/26/quant/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基金及量化投资">基金及量化投资</span>
            <span class="post-date" title="2024-04-26 13:42:05">2024/04/26</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2024/04/21/network_tcp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="传输层">传输层</span>
            <span class="post-date" title="2024-04-21 15:16:42">2024/04/21</span>
        </a>
        
        
        <a  class="All 信号处理 "
           href="/2024/04/20/fourier/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="傅立叶级数与变换">傅立叶级数与变换</span>
            <span class="post-date" title="2024-04-20 18:36:34">2024/04/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/04/14/two_pointer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="双指针系列">双指针系列</span>
            <span class="post-date" title="2024-04-14 19:46:01">2024/04/14</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/13/practical-rust/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust使用日记">Rust使用日记</span>
            <span class="post-date" title="2024-04-13 17:05:26">2024/04/13</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/04/13/ai_basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AI的一些基础概念">AI的一些基础概念</span>
            <span class="post-date" title="2024-04-13 16:43:26">2024/04/13</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/04/13/transformer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="简单理解Transformer">简单理解Transformer</span>
            <span class="post-date" title="2024-04-13 12:36:45">2024/04/13</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/12/rust_async/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust的异步编程">Rust的异步编程</span>
            <span class="post-date" title="2024-04-12 14:09:37">2024/04/12</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/07/python_many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python用到什么学什么">Python用到什么学什么</span>
            <span class="post-date" title="2024-04-07 10:46:59">2024/04/07</span>
        </a>
        
        
        <a  class="All 脑机接口 "
           href="/2024/04/06/eeg_device/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="脑电的原理">脑电的原理</span>
            <span class="post-date" title="2024-04-06 10:35:04">2024/04/06</span>
        </a>
        
        
        <a  class="All 社会技能 "
           href="/2024/04/05/eq/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="培养高情商的一些策略">培养高情商的一些策略</span>
            <span class="post-date" title="2024-04-05 10:25:28">2024/04/05</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/04/rust_multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust多线程编程模型">Rust多线程编程模型</span>
            <span class="post-date" title="2024-04-04 12:38:50">2024/04/04</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/02/rust_leetcode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="用Rust实现Leetcode算法题">用Rust实现Leetcode算法题</span>
            <span class="post-date" title="2024-04-02 12:59:13">2024/04/02</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/01/rust_system/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust基础系统总结">Rust基础系统总结</span>
            <span class="post-date" title="2024-04-01 19:24:52">2024/04/01</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/30/binary-tree/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二叉树/二叉搜索树全系列">二叉树/二叉搜索树全系列</span>
            <span class="post-date" title="2024-03-30 17:07:34">2024/03/30</span>
        </a>
        
        
        <a  class="All UNIX编程 "
           href="/2024/03/30/multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多进程/多线程编程模型">多进程/多线程编程模型</span>
            <span class="post-date" title="2024-03-30 16:47:20">2024/03/30</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/30/profile/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="软件的性能分析">软件的性能分析</span>
            <span class="post-date" title="2024-03-30 13:49:01">2024/03/30</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/28/linkedlist/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="链表系列">链表系列</span>
            <span class="post-date" title="2024-03-28 09:53:10">2024/03/28</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/24/data-struct/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构系列">数据结构系列</span>
            <span class="post-date" title="2024-03-24 14:10:22">2024/03/24</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/23/vscode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="vscode插件配置">vscode插件配置</span>
            <span class="post-date" title="2024-03-23 15:50:58">2024/03/23</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/command_line/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shell脚本现用现学">Shell脚本现用现学</span>
            <span class="post-date" title="2024-03-22 12:50:32">2024/03/22</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/cpp-many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++之用到什么学什么">C++之用到什么学什么</span>
            <span class="post-date" title="2024-03-22 11:31:11">2024/03/22</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/linear-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性DP">线性DP</span>
            <span class="post-date" title="2024-03-20 18:11:22">2024/03/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/tree-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="树形DP">树形DP</span>
            <span class="post-date" title="2024-03-20 18:10:56">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-method/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Methodology">英语科技论文写作模型-Methodology</span>
            <span class="post-date" title="2024-03-20 16:53:17">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-abstract/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Abstract">英语科技论文写作模型-Abstract</span>
            <span class="post-date" title="2024-03-20 16:49:54">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-conclusion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Conclusion">英语科技论文写作模型-Conclusion</span>
            <span class="post-date" title="2024-03-20 16:49:46">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-results/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Results">英语科技论文写作模型-Results</span>
            <span class="post-date" title="2024-03-20 16:49:31">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/19/sci-writing-introduction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Introduction">英语科技论文写作模型-Introduction</span>
            <span class="post-date" title="2024-03-19 10:16:07">2024/03/19</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/03/10/ai-cnn/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CNN的一些基础知识">CNN的一些基础知识</span>
            <span class="post-date" title="2024-03-10 15:57:42">2024/03/10</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/10/catalan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡特兰数系列">卡特兰数系列</span>
            <span class="post-date" title="2024-03-10 12:47:19">2024/03/10</span>
        </a>
        
        
        <a  class="All UNIX编程 "
           href="/2024/03/05/concurrent_sketch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="并发编程的概述">并发编程的概述</span>
            <span class="post-date" title="2024-03-05 15:00:50">2024/03/05</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/03/knapsack/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="背包问题的模板总结">背包问题的模板总结</span>
            <span class="post-date" title="2024-03-03 16:22:21">2024/03/03</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/03/02/virtualmem/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="虚拟内存的基础知识和设计">虚拟内存的基础知识和设计</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/sim-plus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="高精度加减乘除">高精度加减乘除</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/prefix-sum-diff/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前缀和/差分">前缀和/差分</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/other-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="冷门算法/模拟题">冷门算法/模拟题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/interval/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="区间问题">区间问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/03/02/cache-coherence/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="缓存一致性">缓存一致性</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/binary-search/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二分系列">二分系列</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/02/jetbrains/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jetbrains系列IDE的配置">Jetbrains系列IDE的配置</span>
            <span class="post-date" title="2024-03-02 19:00:15">2024/03/02</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/02/tmux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tmux键位配置">tmux键位配置</span>
            <span class="post-date" title="2024-03-02 13:16:32">2024/03/02</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/01/clean_code/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码整洁之道">代码整洁之道</span>
            <span class="post-date" title="2024-03-01 14:30:08">2024/03/01</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/01/software_rule/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面向对象设计的基本原则">面向对象设计的基本原则</span>
            <span class="post-date" title="2024-03-01 14:30:02">2024/03/01</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/29/lazygit/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="lazygit的一些常见用法">lazygit的一些常见用法</span>
            <span class="post-date" title="2024-02-29 17:44:04">2024/02/29</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/28/yabai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="yabai窗口管理器键位配置">yabai窗口管理器键位配置</span>
            <span class="post-date" title="2024-02-28 13:01:35">2024/02/28</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/27/joshuto/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="joshuto的键位配置">joshuto的键位配置</span>
            <span class="post-date" title="2024-02-27 19:43:49">2024/02/27</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/02/26/behaviour_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="行为型的设计模式">行为型的设计模式</span>
            <span class="post-date" title="2024-02-26 20:11:27">2024/02/26</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/26/vimium/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Chrome中vimium键位">Chrome中vimium键位</span>
            <span class="post-date" title="2024-02-26 20:03:26">2024/02/26</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/02/25/build_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创建型的设计模式">创建型的设计模式</span>
            <span class="post-date" title="2024-02-25 15:27:36">2024/02/25</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-practical-rust" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Rust使用日记</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="编程语言">编程语言</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-05-17 12:30:21'>2024-04-13 17:05</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Rust%E4%BB%8B%E7%BB%8D"><span class="toc-text">Rust介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rustc"><span class="toc-text">rustc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text">命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%88%87%E7%89%87"><span class="toc-text">字符串&#x2F;切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cargo"><span class="toc-text">Cargo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#package-crate-module"><span class="toc-text">package, crate, module</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98-%E5%BC%95%E7%94%A8-%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-text">可变, 引用, 所有权</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-text">结构体和方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-text">模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Option"><span class="toc-text">Option</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O"><span class="toc-text">I&#x2F;O</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#trait"><span class="toc-text">trait</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector"><span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A3%B8%E6%8C%87%E9%92%88"><span class="toc-text">裸指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tokio"><span class="toc-text">tokio</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%94%81"><span class="toc-text">异步锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">异步客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tokio-I-O"><span class="toc-text">tokio I&#x2F;O</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pin-Unpin"><span class="toc-text">Pin&#x2F;Unpin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rust%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-text">Rust标准库</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Rust介绍"><a href="#Rust介绍" class="headerlink" title="Rust介绍"></a>Rust介绍</h2><blockquote>
<p>Rust的优势?</p>
</blockquote>
<ul>
<li>**Zero Cost Abstraction: ** Rust引入的一些机制 (例如所有权机制), 并不会引入额外的运行时开销.</li>
</ul>
<h2 id="rustc"><a href="#rustc" class="headerlink" title="rustc"></a>rustc</h2><ul>
<li><p>rustc是Rust编译器.</p>
</li>
<li><p>rustc通过目标三元组(Target Triplet)来描述运行平台, 格式是: <code>CPU架构-厂商-OS-运行时库</code>.</p>
<ul>
<li>可以通过<code>rustc --version --verbose</code>查看:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">rustc 1.76.0 (07dca489a 2024-02-04)<br>binary: rustc<br>commit-hash: 07dca489ac2d933c78d3c5158e3f43beefeb02ce<br>commit-date: 2024-02-04<br>host: aarch64-apple-darwin &lt;- 运行平台<br>release: 1.76.0<br>LLVM version: 17.0.6<br></code></pre></td></tr></table></figure>

<ul>
<li>使用<code>rustc --print target-list</code>可以查看这个版本的<code>rustc</code>总共可以支持多少个host.<ul>
<li>如果想要添加一个平台, 可以用: <code>rustup target add riscv64gc-unknown-none-elf</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://rust-lang.github.io/api-guidelines/naming.html">https://rust-lang.github.io/api-guidelines/naming.html</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>元素</th>
<th>命名方式</th>
</tr>
</thead>
<tbody><tr>
<td>局部变量</td>
<td>snake_case</td>
</tr>
<tr>
<td>函数</td>
<td>snake_case</td>
</tr>
<tr>
<td>方法</td>
<td>snake_case</td>
</tr>
<tr>
<td>结构体</td>
<td>UpperCamelCase</td>
</tr>
<tr>
<td>Trait</td>
<td>UpperCamelCase</td>
</tr>
<tr>
<td>枚举</td>
<td>UpperCamelCase</td>
</tr>
<tr>
<td>模块(mod)</td>
<td>snake_case</td>
</tr>
</tbody></table>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量和<strong>不可变的变量</strong>有很大的不同.</p>
<ul>
<li><p>常量需要使用<code>const</code>关键字, 并且<strong>必须标注类型</strong>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">&lt;<span class="hljs-keyword">pub</span>&gt; <span class="hljs-keyword">const</span> MAX_NUM: <span class="hljs-type">i32</span> = <span class="hljs-number">1000_i32</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>常量可以定义在任意作用域, 包括全局作用域.</p>
</li>
<li><p>常量必须绑定到<strong>常量表达式</strong>, 必须在编译时期就要算出来.</p>
</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul>
<li><p>整数的类型转换一定要保证<strong>小转大</strong>.</p>
<ul>
<li>$n$位无符号数范围: $[0, 2^n - 1]$</li>
<li>$n$位有符号数范围: $[-(2^{n}-1), 2^{n-1}-1]$​</li>
</ul>
</li>
<li><p>字符转成ASCII码: <code>let c = &#39;a&#39; as u8;</code></p>
</li>
<li><p>除了<code>byte</code>, 其他整数类型都可以使用类型后缀, 例如<code>57_u8, 128_i32</code>.</p>
</li>
<li><p>debug模式下会在编译时刻检查整数溢出, 但是release模式不会.</p>
</li>
<li><p>打印变量的地址, 首先把它转成裸指针:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">ptr</span> = &amp;&lt;变量名&gt; <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> &lt;变量类型&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>打印裸指针用<code>&#123;:p&#125;</code>.</li>
</ul>
</li>
</ul>
<h2 id="字符串-切片"><a href="#字符串-切片" class="headerlink" title="字符串&#x2F;切片"></a>字符串&#x2F;切片</h2><ul>
<li><p>Rust中字符串用<code>UTF-8</code>编码.</p>
</li>
<li><p>Rust中, 语言层面只提供了一种字符串类型, 就是<code>&amp;str</code>, 就是切片.</p>
<ul>
<li><code>&amp;str</code>本质上就是对存储在其他地方, <code>UTF-8</code>编码的字符串的引用.<ul>
<li>字符串字面值就存在于二进制文件中.</li>
</ul>
</li>
</ul>
</li>
<li><p><code>String</code>本质上是对<code>Vec&lt;u8&gt;</code>的封装.</p>
</li>
<li><p>创建字符串:</p>
<ul>
<li><p><code>String::from()</code>函数.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;haha &#123;&#125;&quot;</span>, b));<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>to_string()</code>方法: 适用于实现了Display trait的数据类型, 包括<code>&amp;str</code>.</p>
</li>
</ul>
</li>
<li><p>从<code>String</code>类型字符串中获取字符:</p>
</li>
</ul>
 <figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">a.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">nth</span>(index); <span class="hljs-comment">// 返回Option, 自己处理</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>更新String:</p>
<ul>
<li><p>将字符附加到<code>String</code>: <code>push</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>s.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&#x27;l&#x27;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>将<code>&amp;str</code>附加到<code>String</code>: <code>push_str</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>s.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;bar&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>String</code>字符串拼接:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = s1 + &amp;s2<br></code></pre></td></tr></table></figure>

<ul>
<li>注意, 拼接的后面必须都是<code>&amp;String/&amp;str</code>类型, 因为<code>+</code>本质上是调用了类似<code>fn add(self, a: &amp;str, ...)</code>这样签名的函数.</li>
<li>注意, 拼接之后, <code>s1</code>所有权就没有了, 后面不能再使用.</li>
</ul>
</li>
</ul>
</li>
<li><p>访问字符串:</p>
<ul>
<li><code>String</code>类型不能通过索引访问(没有实现Integer trait).</li>
</ul>
</li>
<li><p>因为索引访问的是<code>u8</code>, 而不是字符.</p>
<ul>
<li>Rust中有两种看待字符串的方法:<ul>
<li>字节数组: <code>a.bytes()</code></li>
<li>字符数组: <code>a.chars()</code></li>
</ul>
</li>
<li>遍历字符串中的字符:</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// a可以是String或者&amp;str</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">ch</span> <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">chars</span>() &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>


<ul>
<li><p>字符串逆序:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// a是String类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = a.<span class="hljs-title function_ invoke__">chars</span>().<span class="hljs-title function_ invoke__">rev</span>().collect::&lt;<span class="hljs-type">String</span>&gt;();<br></code></pre></td></tr></table></figure>
</li>
<li><p>字符串转整数:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;42&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">n1</span>: <span class="hljs-type">u64</span> = s1.<span class="hljs-title function_ invoke__">parse</span>()?;<br></code></pre></td></tr></table></figure>
</li>
<li><p>在使用<code>match</code>做字符串<code>&amp;str</code>匹配时, 需要在匹配后面加上<code>_</code>的处理, 例如:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">inst_struct</span> = <span class="hljs-keyword">match</span> inst.<span class="hljs-title function_ invoke__">as_str</span>() &#123;<br>    <span class="hljs-string">&quot;0110111&quot;</span> =&gt; &#123;<br>        Inst &#123;<br>            hex: inst,<br>            name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;lui&quot;</span>),<br>            rd: <span class="hljs-number">0_u8</span>,<br>            rs1: <span class="hljs-number">0_u8</span>,<br>            rs2: <span class="hljs-number">0_u8</span>,<br>        &#125;<br>    &#125;,<br>  <span class="hljs-comment">// 如果所有的都没匹配到</span><br>    _ =&gt; &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Not implemented&quot;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>字符串切片:</strong> <code>&amp;str</code></p>
<ul>
<li><p>切片用来创造数组&#x2F;字符串某一部分的<strong>不可变引用</strong>.</p>
</li>
<li><p>创建方法是: <code>&amp;s[startIndex..endIndex]</code>, 选取的区间是<code>[startIndex, endIndex - 1]</code>.</p>
</li>
<li><p>从0开始: <code>&amp;s[ ..endIndex]</code></p>
</li>
<li><p>直到结尾: <code>&amp;s[0 ..]</code></p>
</li>
<li><p>选取全部: <code>&amp;s[ .. ]</code></p>
</li>
<li><p>注意: 切片索引访问的不是字符, 而是<code>u8</code>, 需要保证访问的索引在每一个字符的边界位置, 例如下面代码会报错:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-string">&quot;中国人&quot;</span>;<br><span class="hljs-comment">// 中文在UTF-8中占3个字节, [0..2]正好在&#x27;中&#x27;的里面</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果一个函数用字符串当作参数, 类型尽量定义成<code>&amp;str</code>, 让API更加通用.</p>
</li>
</ul>
<h2 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h2><ul>
<li><p>默认的<code>cargo build</code>是用<strong>debug级别</strong>进行编译, 可以用<code>cargo build --release</code>进行release级别的编译.</p>
<ul>
<li>如果要跑benchmark, 一定要用<code>release</code>级别, 因为debug级别会增加很多影响性能的东西.</li>
</ul>
</li>
<li><p>更新依赖: <code>cargo update</code>.</p>
</li>
<li><p>cargo下载的包在<code>CARGO_HOME</code>下.</p>
<ul>
<li>默认下载到<code>~/.cargo</code>.</li>
</ul>
</li>
<li><p>✨检查代码编译是否正确用<code>cargo check</code>, 比<code>cargo build</code>快很多.</p>
</li>
<li><p>cargo添加完dependency后, 下载包用: <code>cargo build</code></p>
</li>
<li><p>cargo交叉编译的配置:</p>
<ul>
<li><p>在项目中新建<code>.cargo</code>文件夹, 创建<code>config</code>文件, 写入:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">[build]<br>target = <span class="hljs-string">&quot;riscv64gc-unknown-none-elf&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>cargo build</code>就会生成目标平台的二进制文件.</p>
</li>
</ul>
</li>
</ul>
<h2 id="package-crate-module"><a href="#package-crate-module" class="headerlink" title="package, crate, module"></a>package, crate, module</h2><ul>
<li><p>Rust中, 默认导入了<code>std::prelude</code>, 里面包含了常用的函数, 包括<code>println!</code>.</p>
</li>
<li><p>Rust的引入规范:</p>
<ul>
<li>引入函数时, 引入到父级模块, 然后用<code>父级模块::函数名</code>调用, 用于区分是哪个作用域中的函数.</li>
<li>引入struct, enum这种时, 引入到自身, 因为引入到父级模块的话就太难写了.</li>
</ul>
</li>
<li><p>如果有多个可执行文件, 可以放到<code>src/bin</code>中, 运行某个可执行文件就用: <code>cargo run --bin &lt;可执行文件名字&gt;</code></p>
</li>
<li><p>crate是Rust中最小的编译单元, 分为两种类型:</p>
<ul>
<li><code>binary crate</code>: 编译生成二进制文件.</li>
<li><code>library crate</code>: 为其他程序提供服务.</li>
</ul>
</li>
<li><p>crate是一颗由<code>mod</code>组成的树状结构:</p>
<ul>
<li>树的根是一个叫做<code>crate</code>的模块, 在概念上, 叫做crate root, 它由定义在<code>src/main.rs</code>和<code>src/lib.rs</code>中的元素组成.</li>
<li>如果要在mod和mod之间建立父子关系, 需要在父模块中使用<code>mod XXX;</code>来声明子模块.</li>
<li>Rust中, 一个文件夹如果里面有<code>mod.rs</code>, 那么会被看成是和文件夹同名的mod, mod中的元素就是在<code>mod.rs</code>中的元素.</li>
<li>Rust中, 一个文件默认也被看成一个和文件同名的mod.</li>
</ul>
</li>
<li><p>如果要在某一个mod中引入其他mod中的元素, 可以使用<code>use</code>:</p>
<ul>
<li>如果使用绝对路径, 需要从<code>crate::</code>开始引入.</li>
<li>如果使用相对路径, <code>super::</code>表示父亲mod.</li>
</ul>
</li>
</ul>
<h2 id="可变-引用-所有权"><a href="#可变-引用-所有权" class="headerlink" title="可变, 引用, 所有权"></a>可变, 引用, 所有权</h2><ul>
<li><p>Stack和Heap:</p>
<ul>
<li><p>Stack用来存储编译时已知大小的数据.</p>
</li>
<li><p>访问Stack一般比访问Heap快, 因为Heap还需要定位指针, 而Stack一直维护栈顶, 访问内存次数较少.</p>
</li>
</ul>
</li>
<li><p><strong>借用规则:</strong></p>
<ul>
<li><p>同一作用域内, 对于同一个数据, 只能存在一个可变引用.</p>
</li>
<li><p>同一作用域内, 对于同一个数据, 可变引用和不可变引用不能同时存在.</p>
<ul>
<li><p>有一个<code>Vec</code>的场景:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-comment">// 可变引用</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">first</span> = &amp;v[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 不可变引用</span><br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">6</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;first&#125;&quot;</span>);<br><span class="hljs-comment">// 这段代码会报错</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>**一个场景: **假设你有一个函数, 使用了变量<code>a</code>的不可变引用, 得到一个结果, 如果你后来改变了<code>a</code>, 那么得到的这个结果就可能会失效 (例如给定字符串计算长度, 你改了字符串, 这个长度结果肯定就不对), Rust不允许这种情况发生, 后面不能改(也就是不能使用不可变引用来修改).</p>
<ul>
<li>也就是说, 通过不可变引用, <strong>还能保证一个变量<code>x</code>和对应的函数<code>f(x)</code>随时可以保持关系</strong>.</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Race condition</strong>发生的条件: Rust的借用规则可以从根本上避免出现race condition</p>
<ul>
<li>两个&#x2F;多个指针同时访问一块内存数据.</li>
<li>至少有一个指针尝试写入数据.</li>
<li>没有机制来同步指针对内存数据的访问.</li>
</ul>
</li>
<li><p>根据Rust的所有权机制, 自引用结构体很难构造, 例如:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SelfRef</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    mystr: <span class="hljs-type">String</span>,<br>    mystr_ref: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">hello</span> = <span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">self_ref</span> = SelfRef &#123;<br>        mystr_ref: &amp;hello,<br>        mystr: hello<br>    &#125;;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, self_ref);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>这个代码编译错误, <code>hello</code>的所有权会移动到<code>self_ref.mystr</code>上, 这个时候, <code>&amp;hello</code>这个不可变借用就会失效.</li>
</ul>
</li>
<li><p>当你定义一个变量的时候, 你就需要问自己, 这个变量会不会在未来可变, 如果可变就定义成<code>mut</code>.</p>
</li>
<li><p>函数的返回值一般都会把所有权返回, 可用不可变变量接收&#x2F;<code>mut</code>接收 (如果返回引用需要处理生命周期).</p>
</li>
<li><p>注意, 当一个变量的所有权转移后, 这个变量值的可变性可能改变, <strong>可以用所有权转移的方式改变一个原本不能被改变的值</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">b</span> = a;<br>b.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;haha&quot;</span>); <span class="hljs-comment">// 不会报错</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>看一个结构体成员方法时, 注意方法参数:</p>
<ul>
<li><code>self</code>: 会直接拿走结构体变量的所有权, 结构体变量后面就不能用了.</li>
<li><code>&amp;self</code>: 没事, 随便用.</li>
<li><code>&amp;mut self</code>: 结构体成员可能会发生变化, 具体什么变化看函数实现.</li>
</ul>
</li>
<li><p>结构体中的<code>new</code>关联方法中,  参数列表一般都不用引用, <strong>直接拿走原变量的所有权</strong>, 让所有权转移到结构体成员变量中.</p>
</li>
<li><p>注意, 你在用<code>for .. in</code>遍历数组时, 会调用<code>into_iter()</code>, 这个方法会拿走原始变量的所有权, 因此需要考虑原始变量是否实现了<code>Copy trait</code>.</p>
</li>
<li><p>如果你看到一个变量是<code>&amp;mut</code>类型, 那么<strong>你一定要记得, 这个类型没有实现<code>Copy trait</code></strong>, 需要注意所有权.</p>
</li>
<li><p>所有权移动时, 一般会涉及变量地址的改变.</p>
</li>
</ul>
<h2 id="结构体和方法"><a href="#结构体和方法" class="headerlink" title="结构体和方法"></a>结构体和方法</h2><ul>
<li><p>定义<code>struct</code>: 需要为所有Field指明名称和类型:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">User</span> &#123;<br>  name: <span class="hljs-type">String</span>,<br>  sign_in_count: <span class="hljs-type">u64</span>,<br>  active: <span class="hljs-type">bool</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>结尾没有<code>;</code>.</li>
</ul>
</li>
<li><p>实例化:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user</span> = User &#123;<br>  active: <span class="hljs-literal">true</span>,<br>  sign_in_count: <span class="hljs-number">554</span>,<br>  name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>)<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>创建实例时, 必须同时为所有的字段都赋值.</li>
</ul>
</li>
<li><p>访问&#x2F;修改<code>struct</code>用<code>.</code>, 例如<code>user.name</code>.</p>
</li>
<li><p>一旦一个<code>struct</code>变量是<code>mut</code>, 那么它的所有字段都是<code>mut</code>.</p>
</li>
<li><p>当字段的名字和字段 对应值的变量名是一样的时候, 就可以简写:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">active</span> = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">user</span> = User &#123;<br>  active,<br>  sign_in_count: <span class="hljs-number">554</span>,<br>  name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>struct</code>更新语法: 当你想基于某一个已有的结构体创建一个新结构体时, 可以用<code>..</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">user</span> = User &#123;<br>  active: <span class="hljs-literal">true</span>,<br>  sign_in_count: <span class="hljs-number">554</span>,<br>  name: <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>)<br>&#125;;<br><span class="hljs-comment">// 没有更新语法</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>  active: <span class="hljs-literal">false</span>,<br>  sign_in_count: user.sign_in_count,<br>  name: user.name<br>&#125;<br><span class="hljs-comment">// 更新语法..</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">user2</span> = User &#123;<br>  active: <span class="hljs-literal">false</span>,<br>  ..user<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>tuple struct</code>: <code>struct</code>有名字, 但是字段没有名字:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">black</span> = <span class="hljs-title function_ invoke__">Color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 访问元素</span><br>black.<span class="hljs-number">0</span><br>black.<span class="hljs-number">1</span><br>black.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<ul>
<li>Rust函数也可以有多个返回值, 返回值用tuple包裹即可.</li>
</ul>
</li>
<li><p>方法和函数不同, 方法一般定义在<code>impl</code>内部, 并且参数一般含有<code>self/&amp;self/&amp;mut self</code>.</p>
<ul>
<li><code>self</code>会夺去结构体变量的所有权.</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>  width: <span class="hljs-type">u32</span>,<br>  height: <span class="hljs-type">u32</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">area</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u32</span> &#123;<br>    <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>可以在<code>impl</code>块中, 不包含<code>self</code>, 这叫做<strong>关联函数</strong>, 不是方法, 例如<code>String::from()</code>.</p>
<ul>
<li><p>使用时, 用<code>::</code>调用.</p>
</li>
<li><p>一般用于构造器:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">square</span>(size: <span class="hljs-type">u32</span>) <span class="hljs-punctuation">-&gt;</span> &#123;<br>    Rectangle &#123;<br>      width: size,<br>      height: size<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rectangle::<span class="hljs-title function_ invoke__">square</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>给结构体&#x2F;枚举加上<code>Debug</code>宏:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br></code></pre></td></tr></table></figure>

<ul>
<li>在调试时, 可以使用<code>&#123;:?&#125;</code>或者<code>&#123;:#?&#125;</code>进行输出, <code>&#123;:#?&#125;</code>的输出更优美一些.</li>
</ul>
</li>
</ul>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul>
<li><p>定义枚举, 例如IP地址分为IPv4和IPv6:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>  V4,<br>  V6<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用: <code>let four = IpAddrKind::V4</code>.</li>
</ul>
</li>
<li><p>Rust中, 允许将任意类型的数据附加到枚举的元素中:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>  <span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-type">String</span>),<br>  <span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>每个元素可以存储不同类型的值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>  <span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>),<br>  <span class="hljs-title function_ invoke__">V6</span>(<span class="hljs-type">String</span>)<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">home</span> = IpAddrKind::<span class="hljs-title function_ invoke__">V4</span>(<span class="hljs-number">127</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>为枚举定义方法: 和<code>struct</code>一样, 也用<code>impl</code>关键字</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">IpAddrKind</span> &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Option枚举:</p>
<ul>
<li><p>在Rust中没有Null.</p>
</li>
<li><p>定义在<code>std::prelude</code>中.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span>&lt;T&gt; &#123;<br>  <span class="hljs-title function_ invoke__">Some</span>(T),<br>  <span class="hljs-literal">None</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果一个值可能存在, 也可能不存在(为<code>None</code>), 那么就应该是<code>Option</code>类型.</p>
</li>
<li><p>如果你要声明一个变量是<code>None</code>, 那么需要显式声明类型:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">absent_number</span>: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-literal">None</span>;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><ul>
<li><p><code>match</code>表达式允许一个值和一系列模式进行匹配, 并且执行匹配成功的代码.</p>
<ul>
<li>模式可以是变量名, 字面值, 或者通配符.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Coin</span> &#123;<br>  A,<br>  B,<br>  C,<br>  D,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">value_in_cents</span>(coin: Coin) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123;<br>  <span class="hljs-keyword">match</span> coin &#123;<br>    Coin::A =&gt; <span class="hljs-number">1</span>,<br>    Coin::B =&gt; <span class="hljs-number">2</span>,<br>    <span class="hljs-comment">// 加了花括号, 后面不用,</span><br>    Coin::C =&gt; &#123;<br>    &#125;<br>    Coin::D =&gt; <span class="hljs-number">4</span>,<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><code>match</code>匹配的分支可以绑定到被匹配 对象的部分值.</p>
<ul>
<li>可以从enum中拿到值:</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Coin</span> &#123;<br>  A,<br>  B,<br>  C,<br>  <span class="hljs-title function_ invoke__">D</span>(<span class="hljs-type">u8</span>),<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">value_in_cents</span>(coin: Coin) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">u8</span> &#123;<br>  <span class="hljs-keyword">match</span> coin &#123;<br>    Coin::A =&gt; <span class="hljs-number">1</span>,<br>    Coin::B =&gt; <span class="hljs-number">2</span>,<br>    <span class="hljs-comment">// 加了花括号, 后面不用,</span><br>    Coin::C =&gt; &#123;<br>      <span class="hljs-number">3</span><br>    &#125;<br>    Coin::<span class="hljs-title function_ invoke__">D</span>(value) =&gt; &#123;<br>     		<span class="hljs-built_in">println!</span>(value); <br>      	value<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
<li><p><code>match</code>匹配必须穷举所有的可能.</p>
<ul>
<li><code>_</code>代替其余没有被列出来的值.</li>
</ul>
</li>
</ul>
</li>
<li><p><code>if let</code>处理只关心一种匹配, 不关心其他匹配的情况:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-number">3</span>) = v &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;three&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;others&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h2><ul>
<li><p>如果一个变量在之后可能被设置为None, 那么:</p>
<ul>
<li><p>在定义时:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 注意, 一定是mut</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span>: <span class="hljs-type">Option</span>&lt;T&gt; = <span class="hljs-title function_ invoke__">Some</span>(...);<br></code></pre></td></tr></table></figure>
</li>
<li><p>后期, 如果要把取<code>a</code>的值, 并且把<code>a</code>设置为None, 那么就用: <code>let b = a.take().unwrap();</code>, <code>take()</code>方法会直接让原来<code>Option</code>变量变成<code>None</code>.</p>
</li>
<li><p>此时, <code>a.is_none()</code>的返回值就是True.</p>
</li>
</ul>
</li>
<li><p>快速接收<code>Option</code>变量: <code>if let</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = a &#123;<br>  <span class="hljs-comment">// x就是其中的值</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 如果是None怎么处理</span><br>&#125;<br><br><span class="hljs-comment">// 如果要使用可变的值</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(<span class="hljs-keyword">mut</span> x) = a &#123;<br>  <br>&#125;<br><span class="hljs-comment">// 从Some(T)中拿到不可变引用:</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = a.<span class="hljs-title function_ invoke__">as_ref</span>() &#123;<br>  <br>&#125;<br><span class="hljs-comment">// 可变引用</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = a.<span class="hljs-title function_ invoke__">as_mut</span>() &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>if let</code>会拿走<code>Some(x)</code>中<code>x</code>的所有权, 叫做partially move, 同样, <code>match</code>也会拿走, 模式匹配时可以考虑<code>as_ref()/as_mut()</code></li>
</ul>
</li>
<li><p>注意, 使用<code>a.unwrap()</code>会拿走<code>a</code>的所有权(如果没有实现Copy trait), 可以考虑实现<code>clone()</code>.</p>
</li>
<li><p>从<code>Option</code>中获取其中<strong>值的引用</strong>: 假设<code>x</code>是<code>Option&lt;T&gt;</code>类型的变量</p>
<ul>
<li><strong>不可变引用</strong>: <code>x.as_ref().unwrap()</code>.</li>
<li><strong>可变引用</strong>:  <code>x.as_mut().unwrap()</code>.</li>
</ul>
</li>
<li><p>注意, 假设<code>x</code>是<code>&amp;Option&lt;T&gt;</code>类型, <code>x.unwrap()</code>也会拿走<code>x</code>的所有权, 因为这里会隐式调用<code>Deref</code> trait中的<code>deref</code>方法.</p>
<ul>
<li>也需要用<code>as_ref()</code>或者<code>as_mut()</code>, 防止所有权转移.</li>
</ul>
</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li><p>Rust中的错误分为两种:</p>
<ul>
<li>可恢复的错误: Rust提供了<code>Result&lt;T, E&gt;</code>类型.</li>
<li>不可恢复的错误: Rust提供了<code>panic!</code>宏.</li>
</ul>
</li>
<li><p><code>panic!</code>宏使用: <code>panic!(&quot;错误信息&quot;)</code></p>
<ul>
<li><p><code>panic</code>有两种处理模式:</p>
<ul>
<li><code>unwind</code>: 程序会展开调用栈, 并且依次清理函数中的数据 (工作量较大).</li>
<li><code>abort</code>: 程序直接终止调用栈, 数据由OS回收.</li>
</ul>
</li>
<li><p>在<code>release</code>模式下, 需要用<code>abort</code>模式 (可以让二进制文件更小), 在<code>Cargo.toml</code>中加上:</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[profile.release]</span><br><span class="hljs-attr">panic</span> = <span class="hljs-string">&#x27;abort&#x27;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>panic</code>可能发生在源码中, 如果要定位源码的位置, 需要运行时将<code>RUST_BACKTRACE</code>设置为1.</p>
</li>
</ul>
</li>
<li><p><code>Result&lt;T, E&gt;</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>  <span class="hljs-comment">// 操作成功返回T类型</span><br>  <span class="hljs-title function_ invoke__">Ok</span>(T),<br>  <span class="hljs-comment">// 操作失败返回E类型</span><br>  <span class="hljs-title function_ invoke__">Err</span>(E)<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>处理<code>Result&lt;T, E&gt;</code>的几种方法:</p>
<ul>
<li><p><code>match</code>表达式:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>  <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>  <span class="hljs-comment">// 错误类型</span><br>  <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; &#123;<br>    <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Error opening file &#123;&#125;&quot;</span>, error);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>unwrap()</code>: 直接提取<code>Ok(T)</code>中的<code>T</code>, 如果失败就会直接<code>panic</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>expect()</code>: 在<code>unwrap()</code>的基础上, 可以自定制错误信息:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;错误信息&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>向上传递错误:</p>
<ul>
<li><p>在遇到错误的时候, 直接<code>return Err(e)</code>.</p>
</li>
<li><p>函数的返回值需要变成<code>Result&lt;T, E&gt;</code>.</p>
</li>
<li><p>Rust中还提供了<code>?</code>宏, 专门用来传播错误:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>如果函数返回<code>Ok(T)</code>, 那么<code>T</code>就会自动赋值给<code>f</code>.</p>
</li>
<li><p>如果返回<code>Err(e)</code>, 那么函数就会直接<code>return Err(e);</code></p>
</li>
<li><p>如果一个函数内部有<code>?</code>, 那么最后函数需要写一个返回值<code>Ok(T)</code>.</p>
</li>
<li><p>如果在<code>main</code>函数中需要使用<code>?</code>, 那么<code>main</code>函数的签名需要是:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Box&lt;dyn Error&gt;表示任何可能的错误类型</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>?</code>函数会隐式调用<code>From</code>函数, 将返回错误类型自动转换为函数签名所定义的错误类型.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h2><ul>
<li><p>I&#x2F;O的元素主要在<code>std::io</code>中.</p>
</li>
<li><p>其中, 最重要的两个traits是<code>Read</code>和<code>Write</code>, 分别在<code>std::io::&#123;Read, Write&#125;</code>中.</p>
<ul>
<li>实现了<code>Read</code> traits的叫<code>reader</code>, 可以调用<code>read</code>方法将reader中的数据读到buffer中, 返回成功读取的字节数.</li>
<li>实现了<code>Write</code> traits的叫<code>writer</code>, 可以通过<code>write</code>方法将buffer中的内容写入到<code>writer</code>中, 返回成功写入的字节数.</li>
</ul>
</li>
<li><p>从标准输入读取<code>String</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">new</span>();<br>io::<span class="hljs-title function_ invoke__">stdin</span>().<span class="hljs-title function_ invoke__">read_line</span>(&amp;<span class="hljs-keyword">mut</span> a).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>Rust中, 默认的<code>./</code>是在你cargo项目的根路径.</p>
</li>
<li><p><code>b&quot;hello&quot;</code>是<code>&amp;[u8]</code>类型(切片).</p>
</li>
<li><p>使用I&#x2F;O操作时, 一般会发生Error, 返回值一般是: <code>io::Result&lt;T&gt;</code>.</p>
<ul>
<li>这个是在<code>std::io</code>里定义的一个别名, 全称还是<code>Result&lt;T, Error&gt;</code>.</li>
</ul>
</li>
<li><p>读取一个文件的每一行:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::BufReader;<br><span class="hljs-keyword">use</span> std::io::&#123;<span class="hljs-keyword">self</span>, BufRead, Read, Write&#125;;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;./foo.txt&quot;</span>)?;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">reader</span> = BufReader::<span class="hljs-title function_ invoke__">new</span>(f);<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">line</span> <span class="hljs-keyword">in</span> reader.<span class="hljs-title function_ invoke__">lines</span>() &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, line.<span class="hljs-title function_ invoke__">unwrap</span>());<br>    &#125;<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>TCP Server:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::&#123;Read, Write&#125;;<br><span class="hljs-keyword">use</span> std::net::TcpListener;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><br>    <span class="hljs-comment">// 监听</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;127.0.0.1:3000&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br><br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">stream</span> <span class="hljs-keyword">in</span> listener.<span class="hljs-title function_ invoke__">incoming</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stream</span> = stream.<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buffer</span> = [<span class="hljs-number">0</span>; <span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">// 读取到buffer</span><br>        stream.<span class="hljs-title function_ invoke__">read</span>(&amp;<span class="hljs-keyword">mut</span> buffer).<span class="hljs-title function_ invoke__">unwrap</span>();<br>        <span class="hljs-comment">// 给客户端返回buffer</span><br>        stream.<span class="hljs-title function_ invoke__">write</span>(&amp;<span class="hljs-keyword">mut</span> buffer).<span class="hljs-title function_ invoke__">unwrap</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>TCP Client:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::io::&#123;Read, Write&#125;;<br><span class="hljs-keyword">use</span> std::net::TcpStream;<br><span class="hljs-keyword">use</span> std::<span class="hljs-type">str</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">stream</span> = TcpStream::<span class="hljs-title function_ invoke__">connect</span>(<span class="hljs-string">&quot;127.0.0.1:3000&quot;</span>).<span class="hljs-title function_ invoke__">unwrap</span>();<br>  <span class="hljs-comment">// 发送消息</span><br>  stream.<span class="hljs-title function_ invoke__">write</span>(<span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-title function_ invoke__">as_bytes</span>()).<span class="hljs-title function_ invoke__">unwrap</span>();<br>  <br>	<span class="hljs-comment">// 接收消息</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buffer</span> = [<span class="hljs-number">0</span>; <span class="hljs-number">5</span>];<br>  stream.<span class="hljs-title function_ invoke__">read</span>(&amp;<span class="hljs-keyword">mut</span> buffer).<span class="hljs-title function_ invoke__">unwrap</span>();<br>  <br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Response from server:&#123;:?&#125;&quot;</span>, <span class="hljs-type">str</span>::<span class="hljs-title function_ invoke__">from_utf8</span>(&amp;buffer).<span class="hljs-title function_ invoke__">unwrap</span>());<br>  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h2><ul>
<li><p>PartialEq采用了离散数学中对Equivalence Relation的定义.</p>
<ul>
<li><p>如果一个关系是Equivalence Relation, 那么需要满足自反性(reflexivity, <code>a = a</code>), 对称性(symmetry, <code>a = b -&gt; b = a</code>)以及传递性(transivity <code>a = b &amp;&amp; b = c -&gt; a = c</code>).</p>
</li>
<li><p>如果一个关系不满足自反性, 那么这个关系就是Partial Equivalence Relation, 例如浮点数中的<code>NaN</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-type">f64</span>::NAN;<br><span class="hljs-built_in">assert!</span>(x != x);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>给结构体实现<code>Default </code>trait, 可以在使用时获取一个默认值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Default</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">default</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>    <span class="hljs-comment">// 构造默认值</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>可以使用<code>Student::default()</code>返回一个<code>Student</code>类型的默认值.</li>
</ul>
</li>
<li><p>如果一个结构体需要比较操作:</p>
<ul>
<li>如果结构体成员都可以进行比较, 用<code>#[derive(Eq)]</code></li>
<li>如果出现了不满足自反性的成员, 用<code>#[derive(PartialEq)]</code>.</li>
<li>比较结构体本质上是对每一个成员进行比较.</li>
<li>一般<strong>枚举</strong>应该都需要比较, 定义枚举时需要考虑.</li>
</ul>
</li>
<li><p>给结构体&#x2F;枚举实现<code>From</code>  trait可以通过<code>into()</code>和类型标注转换为对应的结构体类型, 例如:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug, PartialEq)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Method</span> &#123;<br>    Get,<br>    Post,<br>    Uninitialized,<br>&#125;<br><span class="hljs-comment">// &amp;str到Method类型的转换</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">From</span>&lt;&amp;<span class="hljs-type">str</span>&gt; <span class="hljs-keyword">for</span> <span class="hljs-title class_">Method</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">from</span>(s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">match</span> s &#123;<br>            <span class="hljs-string">&quot;GET&quot;</span> =&gt; Method::Get,<br>            <span class="hljs-string">&quot;POST&quot;</span> =&gt; Method::Post,<br>            _ =&gt; Method::Uninitialized,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 可以用如下方法进行类型转换</span><br><span class="hljs-comment">// &quot;GET&quot;.into()</span><br><span class="hljs-comment">// Method::from(&quot;GET&quot;)</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><ul>
<li><p>Vector的类型是<code>Vec&lt;T&gt;</code>, 是由标准库提供的.</p>
<ul>
<li><p>可以存储多个值, 这些值的类型都必须相同.</p>
</li>
<li><p>如果要存放不同的数据类型, 那么可以用枚举:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Data</span> &#123;<br>  <span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-type">i32</span>),<br>  <span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-type">f64</span>),<br>  <span class="hljs-title function_ invoke__">String</span>(<span class="hljs-type">String</span>),<br>&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<br>  Data::<span class="hljs-title function_ invoke__">Int</span>(<span class="hljs-number">3</span>),<br>  Data::<span class="hljs-title function_ invoke__">Float</span>(<span class="hljs-number">3.3</span>),<br>  Data::<span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;3&quot;</span>),<br>];<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建<code>Vec</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用初始值创建<code>Vec</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">v</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>
</li>
<li><p>添加元素: <code>push</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">v</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>v.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>当<code>Vec&lt;T&gt;</code>离开作用域时, 会被清理掉, 但是其中的元素也会被清理掉.</p>
<ul>
<li>如果其他的地方有<code>Vec</code>中元素的索引, 就会发生问题.</li>
</ul>
</li>
<li><p>访问<code>Vec</code>中元素的两种方式:</p>
<ul>
<li>索引: 如果索引超出范围, 程序就会<code>panic</code>.</li>
<li><code>get方法</code>: 返回值是<code>Option&lt;T&gt;</code>, 如果越界会返回<code>None</code>.</li>
</ul>
</li>
<li><p><code>Vec</code>的各种遍历方式:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// 只有下标</span><br><span class="hljs-comment">// a.len()返回值是usize, i也是usize, 考虑溢出</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..a.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>  	<span class="hljs-comment">// a[i]</span><br>&#125;<br><br><span class="hljs-comment">// T</span><br><span class="hljs-keyword">for</span> &amp;item <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>  <span class="hljs-comment">// item是T类型</span><br>&#125;<br><br><span class="hljs-comment">// &amp;T</span><br><span class="hljs-keyword">for</span> <span class="hljs-variable">item</span> <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>() &#123;<br>  <br>&#125;<br><span class="hljs-comment">// 带下标&amp;T</span><br><span class="hljs-keyword">for</span> (i, item) <span class="hljs-keyword">in</span> a.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>() &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul>
<li><p>引入:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br></code></pre></td></tr></table></figure>
</li>
<li><p>创建哈希表:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hashmap</span>: HashMap&lt;T, U&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br></code></pre></td></tr></table></figure>

<ul>
<li>HashMap中, 所有的Key必须是同一种类型, 所有的Value必须是同一种类型.</li>
<li>数据存储在Heap上.</li>
</ul>
</li>
<li><p>添加元素: <code>insert</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">map</span>: HashMap&lt;<span class="hljs-type">String</span>, <span class="hljs-type">i32</span>&gt; = HashMap::<span class="hljs-title function_ invoke__">new</span>();<br>map.<span class="hljs-title function_ invoke__">insert</span>(a, b);<br></code></pre></td></tr></table></figure>
</li>
<li><p>HashMap的所有权问题:</p>
<ul>
<li>如果类型实现了Copy trait, 那么值会被复制到HashMap中.</li>
<li>对于有所有权的值, 所有权会转移到HashMap中, 例如调用<code>insert</code>.</li>
<li>如果将变量的引用插入HashMap, 那么HashMap有效的期间, 必须保证插入的引用有效.</li>
</ul>
</li>
<li><p>根据键获取值: <code>get</code></p>
<ul>
<li>参数: <code>&amp;T</code></li>
<li>返回值: <code>Option&lt;&amp;V&gt;</code></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 传入&amp;T, 返回Option&lt;&amp;U&gt;</span><br>hashmap.<span class="hljs-title function_ invoke__">get</span>(&amp;key);<br></code></pre></td></tr></table></figure>
</li>
<li><p>遍历HashMap:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// k, v都是&amp;T, &amp;U类型</span><br><span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> &amp;hashmap &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>更新HashMap: </p>
<ul>
<li><p>首先判断Key是否存在:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> hashmap.<span class="hljs-title function_ invoke__">contains</span>(&amp;key) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果key存在:</p>
<ul>
<li><p>如果要用新值覆盖, 直接再次<code>insert</code>即可.</p>
</li>
<li><p>如果要基于原来的值计算新值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 得到原来的值的&amp;mut</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">origin</span> = hashmap.<span class="hljs-title function_ invoke__">entry</span>(&amp;key).<span class="hljs-title function_ invoke__">or_insert</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 然后用*origin就可以基于原值计算</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如果key不存在, 直接<code>insert</code>插入即可.</p>
</li>
</ul>
</li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul>
<li><p>一个类型, 如果实现了<code>Iterator</code> trait, 那么它就是一个迭代器类型.</p>
</li>
<li><p><code>Iterator</code> trait的内容如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">trait</span> <span class="hljs-title class_">Iterator</span> &#123;<br>  <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span>;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt;;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>一个集合如果实现了<code>IntoIterator</code> trait, 那么它就能够通过<code>into_iter(), iter(), iter_mut()</code>方法变成迭代器:</p>
<ul>
<li><code>into_iter()</code>会拿走集合变量的所有权, 调用<code>next()</code>返回的类型是<code>Some(T)</code>.</li>
<li><code>iter()</code>使用集合的不可变引用, 调用<code>next()</code>返回<code>Some(&amp;T)</code>.</li>
<li><code>iter_mut()</code>使用集合的可变引用, 调用<code>next()</code>返回<code>Some(&amp;mut T)</code>, 可以通过它修改集合中的元素.</li>
</ul>
</li>
<li><p>**注意: **<code>next()</code>方法会改变迭代器的状态, 如果一个迭代器变量需要用到<code>next()</code>方法, 就需要<code>mut</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a.<span class="hljs-title function_ invoke__">iter</span>();<br><span class="hljs-comment">// 代码会报错, 需要将b定义成mut</span><br>b.<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br></code></pre></td></tr></table></figure>



</li>
<li></li>
</ul>
<h2 id="裸指针"><a href="#裸指针" class="headerlink" title="裸指针"></a>裸指针</h2><p>Rust中, 裸指针(raw pointer)分为一下两种类型:</p>
<ul>
<li><code>*const T</code>: 不能通过裸指针修改原数据.</li>
<li><code>*mut T</code>: 可以通过裸指针修改原数据.</li>
</ul>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><ul>
<li><p>快速单元测试的框架, 在你写的函数里面用:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>  <br>  <span class="hljs-keyword">use</span> super::*;<br>  <br>  <span class="hljs-comment">// 测试函数, 可以写多个</span><br>  <span class="hljs-meta">#[test]</span><br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_XXX1</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(...);<br>  &#125;<br>  <br>  <span class="hljs-meta">#[test]</span><br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">test_XXX2</span>() &#123;<br>    <span class="hljs-built_in">assert_eq!</span>(...);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="tokio"><a href="#tokio" class="headerlink" title="tokio"></a>tokio</h2><ul>
<li>引入包:</li>
</ul>
<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[dependencies]</span><br><span class="hljs-attr">tokio</span> = &#123; version = <span class="hljs-string">&quot;1&quot;</span>, features = [<span class="hljs-string">&quot;full&quot;</span>] &#125;<br></code></pre></td></tr></table></figure>



<h3 id="异步锁"><a href="#异步锁" class="headerlink" title="异步锁"></a>异步锁</h3><ul>
<li>默认情况下, <code>tokio</code>的任务调度器是<strong>多线程</strong>, 这样, 你就需要考虑一个问题:<ul>
<li>使用<code>.await</code>时, 任务可能会被阻塞, tokio可能会把任务调度到另一个线程中执行.</li>
<li>这样, 与<code>.await</code>在同一个作用域的所有变量, 都会被封装成一个状态, 在线程间传递, 如果在线程间传递, 那么这些变量就需要实现<code>Send</code> trait.</li>
<li>最典型的例子是, 如果你在<code>.await</code>之前, <strong>在同一作用域内</strong>用<code>std::sync::Mutex</code>获取了互斥锁, 由于<code>MutexGuard&lt;T&gt;</code>没有实现Send trait, 就会报错.</li>
<li>一个解决方案是, 让<code>.await</code>调用的作用域在获取Mutex作用域之后, 另一个解决方案是使用<strong>异步锁</strong>.</li>
</ul>
</li>
<li><strong>异步锁: <code>tokio::sync::Mutex</code></strong>:<ul>
<li>如果在<code>.await</code>之间获取了<code>std::sync::Mutex</code>, 那么调用<code>.await</code>后, 任务会被阻塞, 但是锁没有被释放, 这时候如果另一个任务尝试获取锁, 就会产生死锁.</li>
<li>使用tokio的异步锁可以在<code>.await</code>作用域内获取锁, 但是会有性能开销.</li>
</ul>
</li>
</ul>
<h3 id="异步客户端"><a href="#异步客户端" class="headerlink" title="异步客户端"></a>异步客户端</h3><ul>
<li>**tokio实现异步客户端的思路: **<ul>
<li><p>首先, <code>spawn</code>一个manager异步任务, 这个任务负责管理所有客户端, 相当于客户端的proxy.</p>
</li>
<li><p>然后, 在众多客户端和manager之间建立一个<code>tokio::sync::mpsc</code>.</p>
<ul>
<li>众多<code>tx</code>由众多客户端拿到, 客户端用<code>tx</code>给manager发送打包好的命令.</li>
<li><code>rx</code>由manager拿到, 负责接收客户端发送来的命令.</li>
</ul>
</li>
<li><p>然后, 在客户端内部, 建立一个<code>tokio::sync::oneshot</code> (单生产者, 单消费者, 一次发送一个任务)</p>
<ul>
<li><code>oneshot_tx</code>会被客户端打包到命令中, 发送给manager, manager收到之后会通过<code>oneshot_tx</code>把服务器发送来的东西返回给客户端.</li>
<li><code>oneshot_rx</code>给客户端用来接收manager返回过来的命令.</li>
</ul>
</li>
<li><p>manager通过connection资源与服务器交互.</p>
</li>
</ul>
</li>
</ul>
<h3 id="tokio-I-O"><a href="#tokio-I-O" class="headerlink" title="tokio I&#x2F;O"></a>tokio I&#x2F;O</h3><ul>
<li><p>tokio I&#x2F;O的包主要在: <code>tokio::io</code>中, 和<code>std::io</code>的用法基本一致, 区别在于tokio中的I&#x2F;O操作是异步的.</p>
</li>
<li><p>其中, 最重要的两个traits是<code>AsyncReadExt</code>和<code>AsyncWriteExt</code>, 实现了这两个trait可以使用异步的<code>read</code>和<code>write</code>.</p>
</li>
<li><p>异步echo服务端:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> tokio::io;<br><span class="hljs-keyword">use</span> tokio::net::TcpListener;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">listener</span> = TcpListener::<span class="hljs-title function_ invoke__">bind</span>(<span class="hljs-string">&quot;127.0.0.1:6142&quot;</span>).<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-keyword">loop</span> &#123;<br>        <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> socket, _) = listener.<span class="hljs-title function_ invoke__">accept</span>().<span class="hljs-keyword">await</span>?;<br>        tokio::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;<br>            <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> rd, <span class="hljs-keyword">mut</span> wr) = socket.<span class="hljs-title function_ invoke__">split</span>();<br>            <span class="hljs-comment">// 异步将reader的内容copy到writer中, copy以后writer就直接发送了</span><br>            <span class="hljs-keyword">if</span> io::<span class="hljs-title function_ invoke__">copy</span>(&amp;<span class="hljs-keyword">mut</span> rd, &amp;<span class="hljs-keyword">mut</span> wr).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">is_err</span>() &#123;<br>                <span class="hljs-built_in">eprintln!</span>(<span class="hljs-string">&quot;failed to copy&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>异步echo客户端:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> tokio::net::TcpStream;<br><span class="hljs-keyword">use</span> tokio::io::&#123;<span class="hljs-keyword">self</span>, AsyncReadExt, AsyncWriteExt&#125;;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> io::<span class="hljs-type">Result</span>&lt;()&gt; &#123;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">socket</span> = TcpStream::<span class="hljs-title function_ invoke__">connect</span>(<span class="hljs-string">&quot;127.0.0.1:6142&quot;</span>).<span class="hljs-keyword">await</span>?;<br>  	<span class="hljs-comment">// 分离reader和writer, 适合同时实现了AsyncRead和AsyncWrite的对象</span><br>    <span class="hljs-keyword">let</span> (<span class="hljs-keyword">mut</span> rd, <span class="hljs-keyword">mut</span> wr) = socket.<span class="hljs-title function_ invoke__">split</span>();<br><br>    tokio::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> <span class="hljs-keyword">move</span> &#123;<br>        wr.<span class="hljs-title function_ invoke__">write_all</span>(<span class="hljs-string">b&quot;hello\r\n&quot;</span>) .<span class="hljs-keyword">await</span>?;<br>        wr.<span class="hljs-title function_ invoke__">write_all</span>(<span class="hljs-string">b&quot;hello\r\n&quot;</span>).<span class="hljs-keyword">await</span>?;<br>        Ok::&lt;_, io::Error&gt;(())<br>    &#125;);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buf</span> = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">0</span>; <span class="hljs-number">128</span>];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">n</span> = rd.<span class="hljs-title function_ invoke__">read</span>(&amp;<span class="hljs-keyword">mut</span> buf).<span class="hljs-keyword">await</span>?;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;GOT &#123;:?&#125;&quot;</span>, &amp;buf[..n]);<br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Pin-Unpin"><a href="#Pin-Unpin" class="headerlink" title="Pin&#x2F;Unpin"></a>Pin&#x2F;Unpin</h2><p>在Rust中, 一个变量的内存地址是可能会被移动的. 这种移动会引发一些问题, 考虑以下几个场景:</p>
<ul>
<li><p>场景1: <strong>裸指针自引用结构体</strong></p>
<ul>
<li><p>考虑如下这个自引用结构体:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SelfRef</span> &#123;<br>  value: <span class="hljs-type">String</span>,<br>  <span class="hljs-comment">// 这个裸指针指向成员变量value</span><br>  pointer_to_value: *<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果<code>value</code>在内存中的位置发生了移动, 那么<code>pointer_to_value</code>存储的内存地址就不对了.</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>构造一个样例, 来解释变量在栈内存中的移动?</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span> &#123;<br>    data: <span class="hljs-type">usize</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SelfRef</span> &#123;<br>    data: Data,<br>    data_ref: *<span class="hljs-keyword">const</span> Data<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SelfRef</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(data: Data) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            data,<br>            data_ref: std::ptr::<span class="hljs-title function_ invoke__">null</span>()<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.data_ref = &amp;<span class="hljs-keyword">self</span>.data;<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">print_info</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<br>            <span class="hljs-string">&quot;Actual Data Address: &#123;:p&#125;, Actual Data Content: &#123;&#125;, Value of data_ref: &#123;:p&#125;&quot;</span>,<br>            &amp;<span class="hljs-keyword">self</span>.data,<br>            <span class="hljs-keyword">self</span>.data.data,<br>            <span class="hljs-keyword">self</span>.data_ref<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在函数中, 将SelfRef变量的所有权返回, 那么原始变量在</span><br><span class="hljs-comment">// 栈中的内存会发生移动</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">test</span>() <span class="hljs-punctuation">-&gt;</span> SelfRef &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">self_ref</span> = SelfRef::<span class="hljs-title function_ invoke__">new</span>(Data &#123; data: <span class="hljs-number">1</span> &#125;);<br>    self_ref.<span class="hljs-title function_ invoke__">init</span>();<br>    self_ref.<span class="hljs-title function_ invoke__">print_info</span>();<br>    self_ref<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">self_ref</span> = <span class="hljs-title function_ invoke__">test</span>();<br>    self_ref.<span class="hljs-title function_ invoke__">print_info</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段程序的运行结果如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Actual Data Address: 0x16eec2288, Actual Data Content: 1, Value of data_ref: 0x16eec2288<br>Actual Data Address: 0x16eec22b0, Actual Data Content: 1, Value of data_ref: 0x16eec2288<br></code></pre></td></tr></table></figure>

<p>很明显, <code>Actual Data Address</code>已经发生了改变, 但是<code>Value of data_ref</code>没有改变, 再使用<code>data_ref</code>就会发生不可预期的错误.</p>
<blockquote>
<p>构造一个样例, 解释变量在堆内存中的移动?</p>
</blockquote>
<h2 id="Rust标准库"><a href="#Rust标准库" class="headerlink" title="Rust标准库"></a>Rust标准库</h2><ul>
<li><p>Rust的标准库<code>std</code>需要有操作系统的支持, 但是Rust也提供了一个不需要操作系统支持的精简版<code>std</code>, 叫做<code>core</code>.</p>
</li>
<li><p>如果要让应用程序移除标准库<code>std</code>的支持, 需要干这几件事情:</p>
<ul>
<li><p>加上<code>#![no_std]</code>.</p>
</li>
<li><p>提供<code>panic_handler</code>, <code>std</code>中用<code>#[panic_handler]</code>来标记<code>panic!</code>宏要对接的函数:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> core::panic::PanicInfo;<br><br><span class="hljs-comment">// PanicInfo会保存程序的错误位置</span><br><span class="hljs-meta">#[panic_handler]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">panic</span>(_info: &amp;PanicInfo) <span class="hljs-punctuation">-&gt;</span> ! &#123;<br>    <span class="hljs-keyword">loop</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>start</code>语义项: </p>
<ul>
<li>Rust标准库<code>std</code>和操作系统对接, 开始执行二进制文件时, 会先跳转到<code>std</code>中的<code>start</code>语义项, 执行一些准备工作, 然后跳转到<code>main</code>函数.</li>
<li>如果要移除<code>main</code>函数的支持, 需要加上<code>#![no_main]</code>.</li>
</ul>
</li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 向阳而生, 喜欢聪明的人. </span>
    </div>
</article>







    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©B1ueDrops
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
