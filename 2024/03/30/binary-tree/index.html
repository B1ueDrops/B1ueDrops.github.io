<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>二叉树系列 | B1ueDrops</title>
  <meta name="keywords" content="">
  <meta name="description" content="二叉树系列 | B1ueDrops">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="动态规划 线性DP 最长上升子序列  https:&#x2F;&#x2F;www.acwing.com&#x2F;problem&#x2F;content&#x2F;897&#x2F;   最长上升子序列的DP做法, 时间复杂度是. 假设f[i]表示以a[i]结尾的最长上升子序列的长度.  那么首先, 一个元素也可以叫最长上升子序列, 那么初始化就是1. 其次, 如果j &lt; i并且a[j] &lt; a[i], 那么f[i] &#x3D; f[j] + 1.">
<meta property="og:type" content="article">
<meta property="og:title" content="AcWing算法基础课题解">
<meta property="og:url" content="https://b1uedrops.github.io/2024/10/31/acwing_basic/index.html">
<meta property="og:site_name" content="B1ueDrops">
<meta property="og:description" content="动态规划 线性DP 最长上升子序列  https:&#x2F;&#x2F;www.acwing.com&#x2F;problem&#x2F;content&#x2F;897&#x2F;   最长上升子序列的DP做法, 时间复杂度是. 假设f[i]表示以a[i]结尾的最长上升子序列的长度.  那么首先, 一个元素也可以叫最长上升子序列, 那么初始化就是1. 其次, 如果j &lt; i并且a[j] &lt; a[i], 那么f[i] &#x3D; f[j] + 1.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-10-31T12:05:59.973Z">
<meta property="article:modified_time" content="2024-10-31T13:19:10.347Z">
<meta property="article:author" content="B1ueDrops">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpeg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpeg"/>
</a>
<div class="author">
    <span>B1ueDrops</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/B1ueDrops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:bluedrops@yeah.net"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2381446488&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(95)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="编程语言">
            
            编程语言
            <small>(10)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="操作系统">
            
            操作系统
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="后端技术">
            
            后端技术
            <small>(19)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="金融知识">
            
            金融知识
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            
            开发工具
            <small>(6)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="控制基础">
            
            控制基础
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="脑机接口">
            
            脑机接口
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(26)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="体系结构">
            
            体系结构
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="AI-HPC">
            
            AI-HPC
            <small>(9)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="English">
            
            English
            <small>(9)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="95">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All 算法 "
           href="/2024/10/31/acwing_basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AcWing算法基础课题解">AcWing算法基础课题解</span>
            <span class="post-date" title="2024-10-31 20:05:59">2024/10/31</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/10/31/acwing_improve/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AcWing算法提高课题解">AcWing算法提高课题解</span>
            <span class="post-date" title="2024-10-31 19:36:46">2024/10/31</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/10/27/leetcode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LeetCode-1000题题解">LeetCode-1000题题解</span>
            <span class="post-date" title="2024-10-27 11:06:02">2024/10/27</span>
        </a>
        
        
        <a  class="All 金融知识 "
           href="/2024/10/14/economics/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="资源与可持续发展">资源与可持续发展</span>
            <span class="post-date" title="2024-10-14 12:41:46">2024/10/14</span>
        </a>
        
        
        <a  class="All 控制基础 "
           href="/2024/10/07/probability/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="概率论与数理统计">概率论与数理统计</span>
            <span class="post-date" title="2024-10-07 15:43:28">2024/10/07</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/09/27/jetbrains/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jetbrains系列IDE的使用方式">Jetbrains系列IDE的使用方式</span>
            <span class="post-date" title="2024-09-27 22:37:32">2024/09/27</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/22/x86_arch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="x86-CPU的体系结构基础">x86-CPU的体系结构基础</span>
            <span class="post-date" title="2024-09-22 13:23:27">2024/09/22</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/20/program_time/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="理解程序运行的时间">理解程序运行的时间</span>
            <span class="post-date" title="2024-09-20 14:22:52">2024/09/20</span>
        </a>
        
        
        <a  class="All 控制基础 "
           href="/2024/09/17/signal_process/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="信号与系统">信号与系统</span>
            <span class="post-date" title="2024-09-17 19:06:32">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/transformer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Transformer的工作原理">Transformer的工作原理</span>
            <span class="post-date" title="2024-09-17 14:16:16">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/fast-ai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="推理加速相关的评价指标">推理加速相关的评价指标</span>
            <span class="post-date" title="2024-09-17 14:16:00">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/pytorch_quant/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="模型量化的理论和实战">模型量化的理论和实战</span>
            <span class="post-date" title="2024-09-17 14:15:30">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/pytorch_arch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Pytorch的前后端架构">Pytorch的前后端架构</span>
            <span class="post-date" title="2024-09-17 14:15:03">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/ai_basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="构建AI模型理论与实战">构建AI模型理论与实战</span>
            <span class="post-date" title="2024-09-17 14:14:52">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/welford/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Welford算法计算方差">Welford算法计算方差</span>
            <span class="post-date" title="2024-09-17 14:14:12">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/data-augmentation-metric/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="理解数据增广的本质">理解数据增广的本质</span>
            <span class="post-date" title="2024-09-17 14:14:03">2024/09/17</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/09/10/design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="设计模式的实际操作">设计模式的实际操作</span>
            <span class="post-date" title="2024-09-10 18:29:51">2024/09/10</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/09/08/windows_msys2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Windows环境配置">Windows环境配置</span>
            <span class="post-date" title="2024-09-08 13:53:44">2024/09/08</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/09/06/network_application_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-应用层">计算机网络-应用层</span>
            <span class="post-date" title="2024-09-06 14:31:30">2024/09/06</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/09/06/network_tcp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-传输层">计算机网络-传输层</span>
            <span class="post-date" title="2024-09-06 14:31:18">2024/09/06</span>
        </a>
        
        
        <a  class="All 操作系统 "
           href="/2024/08/16/concurrent_sketch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="并发编程的概述">并发编程的概述</span>
            <span class="post-date" title="2024-08-16 13:48:22">2024/08/16</span>
        </a>
        
        
        <a  class="All 操作系统 "
           href="/2024/08/16/multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多进程/多线程编程模型">多进程/多线程编程模型</span>
            <span class="post-date" title="2024-08-16 13:48:12">2024/08/16</span>
        </a>
        
        
        <a  class="All 操作系统 "
           href="/2024/08/16/linux_process/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux上的进程控制">Linux上的进程控制</span>
            <span class="post-date" title="2024-08-16 13:48:03">2024/08/16</span>
        </a>
        
        
        <a  class="All 脑机接口 "
           href="/2024/08/16/ssvep_stimulus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SSVEP刺激设计">SSVEP刺激设计</span>
            <span class="post-date" title="2024-08-16 13:47:39">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/network_network_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-网络层">计算机网络-网络层</span>
            <span class="post-date" title="2024-08-16 13:46:58">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/network_datalink_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-数据链路层">计算机网络-数据链路层</span>
            <span class="post-date" title="2024-08-16 13:46:50">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/tcp_stick/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何解决TCP粘包问题">如何解决TCP粘包问题</span>
            <span class="post-date" title="2024-08-16 13:46:38">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/vimium/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Chrome中vimium键位">Chrome中vimium键位</span>
            <span class="post-date" title="2024-08-16 13:46:08">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/yabai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="yabai窗口管理器键位配置">yabai窗口管理器键位配置</span>
            <span class="post-date" title="2024-08-16 13:45:41">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/lazygit/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="试用LazyGit进行版本控制">试用LazyGit进行版本控制</span>
            <span class="post-date" title="2024-08-16 13:45:31">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/tmux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tmux键位配置">tmux键位配置</span>
            <span class="post-date" title="2024-08-16 13:45:09">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/build_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创建型的设计模式">创建型的设计模式</span>
            <span class="post-date" title="2024-08-16 13:35:12">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/behaviour_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="行为型的设计模式">行为型的设计模式</span>
            <span class="post-date" title="2024-08-16 13:35:00">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/combine_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="组合型的设计模式">组合型的设计模式</span>
            <span class="post-date" title="2024-08-16 13:33:52">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/dns/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DNS-客户端连接到机房的技术">DNS-客户端连接到机房的技术</span>
            <span class="post-date" title="2024-08-16 13:33:38">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/lvs_nginx/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LVS/Nginx-服务器调度的技术">LVS/Nginx-服务器调度的技术</span>
            <span class="post-date" title="2024-08-16 13:33:27">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/service_discovery/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="服务发现架构设计">服务发现架构设计</span>
            <span class="post-date" title="2024-08-16 13:33:15">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/storage_rpc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="存储微服务的架构">存储微服务的架构</span>
            <span class="post-date" title="2024-08-16 13:33:00">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/mq/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="消息中间件技术">消息中间件技术</span>
            <span class="post-date" title="2024-08-16 13:32:10">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/concurrent_arch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="高并发架构通用设计">高并发架构通用设计</span>
            <span class="post-date" title="2024-08-16 13:31:33">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/10/data_replication_center/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机房高可用技术">机房高可用技术</span>
            <span class="post-date" title="2024-08-10 20:04:18">2024/08/10</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/07/08/time_complexity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="时间复杂度">时间复杂度</span>
            <span class="post-date" title="2024-07-08 19:42:58">2024/07/08</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/07/05/parser/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="编译原理-Parser的知识合集">编译原理-Parser的知识合集</span>
            <span class="post-date" title="2024-07-05 16:29:19">2024/07/05</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/07/04/raii/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="资源管理中RAII的概念">资源管理中RAII的概念</span>
            <span class="post-date" title="2024-07-04 16:16:39">2024/07/04</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/07/04/char_encode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="字符集与字符编码的深度理解">字符集与字符编码的深度理解</span>
            <span class="post-date" title="2024-07-04 11:32:31">2024/07/04</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/07/04/ieee_754/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="体系结构中的浮点数">体系结构中的浮点数</span>
            <span class="post-date" title="2024-07-04 11:24:35">2024/07/04</span>
        </a>
        
        
        <a  class="All 控制基础 "
           href="/2024/06/02/quaternion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="描述旋转的几种方式">描述旋转的几种方式</span>
            <span class="post-date" title="2024-06-02 13:08:26">2024/06/02</span>
        </a>
        
        
        <a  class="All 控制基础 "
           href="/2024/06/01/linear_algebra/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性代数">线性代数</span>
            <span class="post-date" title="2024-06-01 15:30:18">2024/06/01</span>
        </a>
        
        
        <a  class="All 控制基础 "
           href="/2024/06/01/kalman/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡尔曼滤波数学推导">卡尔曼滤波数学推导</span>
            <span class="post-date" title="2024-06-01 14:10:10">2024/06/01</span>
        </a>
        
        
        <a  class="All 金融知识 "
           href="/2024/05/22/quant_analysis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="金融量化分析模型">金融量化分析模型</span>
            <span class="post-date" title="2024-05-22 18:08:38">2024/05/22</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/17/car-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="汽车英语">汽车英语</span>
            <span class="post-date" title="2024-05-17 13:37:34">2024/05/17</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/14/regular_expression/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="正则表达式原理和实战">正则表达式原理和实战</span>
            <span class="post-date" title="2024-05-14 20:14:59">2024/05/14</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/05/14/recursion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="递归系列">递归系列</span>
            <span class="post-date" title="2024-05-14 16:02:10">2024/05/14</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/13/restaurant_english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="饭店英语">饭店英语</span>
            <span class="post-date" title="2024-05-13 20:25:52">2024/05/13</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/12/frontend-lang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Javascript原理与实战">Javascript原理与实战</span>
            <span class="post-date" title="2024-05-12 21:13:45">2024/05/12</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/12/hotel-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="酒店英语">酒店英语</span>
            <span class="post-date" title="2024-05-12 12:29:02">2024/05/12</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/10/airport-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机场英语">机场英语</span>
            <span class="post-date" title="2024-05-10 10:12:57">2024/05/10</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/09/practical-go/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Go语言原理与实战">Go语言原理与实战</span>
            <span class="post-date" title="2024-05-09 20:48:25">2024/05/09</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/05/09/database-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostgreSQL数据库教程">PostgreSQL数据库教程</span>
            <span class="post-date" title="2024-05-09 20:24:37">2024/05/09</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/05/09/cache-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cache的基础知识与设计策略">Cache的基础知识与设计策略</span>
            <span class="post-date" title="2024-05-09 20:12:19">2024/05/09</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/05/09/sort-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="排序算法">排序算法</span>
            <span class="post-date" title="2024-05-09 17:10:04">2024/05/09</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/04/14/two_pointer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="双指针">双指针</span>
            <span class="post-date" title="2024-04-14 19:46:01">2024/04/14</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/13/practical-rust/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust原理与实战">Rust原理与实战</span>
            <span class="post-date" title="2024-04-13 17:05:26">2024/04/13</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/07/python_many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python原理与实战">Python原理与实战</span>
            <span class="post-date" title="2024-04-07 10:46:59">2024/04/07</span>
        </a>
        
        
        <a  class="All 脑机接口 "
           href="/2024/04/06/eeg_device/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="脑电的原理">脑电的原理</span>
            <span class="post-date" title="2024-04-06 10:35:04">2024/04/06</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/30/binary-tree/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二叉树系列">二叉树系列</span>
            <span class="post-date" title="2024-03-30 17:07:34">2024/03/30</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/28/linkedlist/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="链表系列">链表系列</span>
            <span class="post-date" title="2024-03-28 09:53:10">2024/03/28</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/24/data-struct/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构系列">数据结构系列</span>
            <span class="post-date" title="2024-03-24 14:10:22">2024/03/24</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/shell_script/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shell脚本基础与实战">Shell脚本基础与实战</span>
            <span class="post-date" title="2024-03-22 12:50:32">2024/03/22</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/modern_cpp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Modern C++基础与实战">Modern C++基础与实战</span>
            <span class="post-date" title="2024-03-22 11:31:11">2024/03/22</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/linear-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性DP">线性DP</span>
            <span class="post-date" title="2024-03-20 18:11:22">2024/03/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/tree-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="树形DP">树形DP</span>
            <span class="post-date" title="2024-03-20 18:10:56">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-method/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Methodology">英语科技论文写作模型-Methodology</span>
            <span class="post-date" title="2024-03-20 16:53:17">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-abstract/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Abstract">英语科技论文写作模型-Abstract</span>
            <span class="post-date" title="2024-03-20 16:49:54">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-conclusion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Conclusion">英语科技论文写作模型-Conclusion</span>
            <span class="post-date" title="2024-03-20 16:49:46">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-results/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Results">英语科技论文写作模型-Results</span>
            <span class="post-date" title="2024-03-20 16:49:31">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/19/sci-writing-introduction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Introduction">英语科技论文写作模型-Introduction</span>
            <span class="post-date" title="2024-03-19 10:16:07">2024/03/19</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/10/catalan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡特兰数系列">卡特兰数系列</span>
            <span class="post-date" title="2024-03-10 12:47:19">2024/03/10</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/03/knapsack/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="背包问题">背包问题</span>
            <span class="post-date" title="2024-03-03 16:22:21">2024/03/03</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/03/02/virtualmem/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="虚拟内存的基础知识和设计">虚拟内存的基础知识和设计</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/sim-plus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="高精度加减乘除">高精度加减乘除</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/prefix-sum-diff/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前缀和/差分">前缀和/差分</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/other-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="其他算法/模拟题">其他算法/模拟题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/parathesis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="括号序列">括号序列</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/mathematic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数学问题">数学问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/interval/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="区间问题">区间问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/graph/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="图论">图论</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/greedy/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="贪心算法">贪心算法</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/dfs/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深度优先搜索">深度优先搜索</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/03/02/cache-coherence/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="缓存一致性">缓存一致性</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/catch-rain/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="接雨水问题">接雨水问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/binary-search/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二分系列">二分系列</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/bfs/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="广度优先搜索">广度优先搜索</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/03/01/clean_code/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码整洁之道">代码整洁之道</span>
            <span class="post-date" title="2024-03-01 14:30:08">2024/03/01</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/03/01/software_rule/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面向对象设计的基本原则">面向对象设计的基本原则</span>
            <span class="post-date" title="2024-03-01 14:30:02">2024/03/01</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-binary-tree" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">二叉树系列</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="算法">算法</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-07-08 19:52:48'>2024-03-30 17:07</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95"><span class="toc-text">递归写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95"><span class="toc-text">迭代写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95-1"><span class="toc-text">递归写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95-1"><span class="toc-text">迭代写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95-2"><span class="toc-text">递归写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95-2"><span class="toc-text">迭代写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%8B%E5%AD%97%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">之字形层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">前序中序恢复二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E4%B8%AD%E5%BA%8F%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">后序中序恢复二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">前序后序恢复二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">二叉树中序遍历的下一个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="toc-text">二叉搜索树的搜索操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">二叉搜索树的插入操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">二叉搜索树的删除操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉搜索树的后序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E6%98%AF%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">二叉树中和是某一值的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-text">树的子结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-text">二叉树的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">对称的二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">合并二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-text">二叉树的所有路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B1%82%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-text">完全二叉树求节点个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%B1%82%E6%95%B0%E7%9B%AE"><span class="toc-text">不同的二叉搜索树求数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%B1%82%E6%96%B9%E6%A1%88"><span class="toc-text">不同的二叉搜索树求方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">验证二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">恢复二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Morris%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">Morris中序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8F%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">有序数组变二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8F%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">有序链表变二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-text">二叉树展开为链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9"><span class="toc-text">填充每个节点的下一个右侧节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84LCA"><span class="toc-text">二叉搜索树的LCA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84LCA"><span class="toc-text">二叉树的LCA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">验证二叉树前序序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">二叉树的序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">二叉搜索树的序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%AD%90%E5%8F%B6%E4%B9%8B%E5%92%8C"><span class="toc-text">左子叶之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">二叉树的最大路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-text">找树左下角的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII"><span class="toc-text">路径总和III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-text">二叉搜索树中的众数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C"><span class="toc-text">出现次数最多的子树元素和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-text">二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C"><span class="toc-text">在二叉树中增加一行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-text">寻找重复的子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">两数之和-二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">最大二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="toc-text">二叉树的最大宽度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">修建二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">二叉树中第二小的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">输出二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D"><span class="toc-text">二叉树剪枝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BAk%E7%9A%84%E7%82%B9"><span class="toc-text">二叉树中所有距离为k的点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E6%B7%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91"><span class="toc-text">最深节点的最小子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E7%9C%9F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">所有可能的真二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8"><span class="toc-text">完全二叉树插入器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">判断是否是完全二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9"><span class="toc-text">二叉树的堂兄弟节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A5%E5%8C%B9%E9%85%8D%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">翻转二叉树以匹配先序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81"><span class="toc-text">在二叉树中分配硬币</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%8F%B6%E8%8A%82%E7%82%B9%E5%BC%80%E5%A7%8B%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">从叶节点开始的最小字符串</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95"><span class="toc-text">递归写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95"><span class="toc-text">迭代写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95-1"><span class="toc-text">递归写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95-1"><span class="toc-text">迭代写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95-2"><span class="toc-text">递归写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95-2"><span class="toc-text">迭代写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%8B%E5%AD%97%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">之字形层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">前序中序恢复二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E4%B8%AD%E5%BA%8F%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">后序中序恢复二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">前序后序恢复二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">二叉树中序遍历的下一个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="toc-text">二叉搜索树的搜索操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">二叉搜索树的插入操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">二叉搜索树的删除操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉搜索树的后序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E6%98%AF%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">二叉树中和是某一值的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-text">树的子结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-text">二叉树的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">对称的二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">合并二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-text">二叉树的所有路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B1%82%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-text">完全二叉树求节点个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%B1%82%E6%95%B0%E7%9B%AE"><span class="toc-text">不同的二叉搜索树求数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%B1%82%E6%96%B9%E6%A1%88"><span class="toc-text">不同的二叉搜索树求方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">验证二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">恢复二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Morris%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">Morris中序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8F%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">有序数组变二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8F%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">有序链表变二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-text">二叉树展开为链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9"><span class="toc-text">填充每个节点的下一个右侧节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84LCA"><span class="toc-text">二叉搜索树的LCA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84LCA"><span class="toc-text">二叉树的LCA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">验证二叉树前序序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">二叉树的序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">二叉搜索树的序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%AD%90%E5%8F%B6%E4%B9%8B%E5%92%8C"><span class="toc-text">左子叶之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">二叉树的最大路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-text">找树左下角的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII"><span class="toc-text">路径总和III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-text">二叉搜索树中的众数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C"><span class="toc-text">出现次数最多的子树元素和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-text">二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C"><span class="toc-text">在二叉树中增加一行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-text">寻找重复的子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">两数之和-二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">最大二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="toc-text">二叉树的最大宽度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">修建二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">二叉树中第二小的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">输出二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D"><span class="toc-text">二叉树剪枝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BAk%E7%9A%84%E7%82%B9"><span class="toc-text">二叉树中所有距离为k的点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E6%B7%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91"><span class="toc-text">最深节点的最小子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E7%9C%9F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">所有可能的真二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8"><span class="toc-text">完全二叉树插入器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">判断是否是完全二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9"><span class="toc-text">二叉树的堂兄弟节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A5%E5%8C%B9%E9%85%8D%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">翻转二叉树以匹配先序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%88%86%E9%85%8D%E7%A1%AC%E5%B8%81"><span class="toc-text">在二叉树中分配硬币</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%8F%B6%E8%8A%82%E7%82%B9%E5%BC%80%E5%A7%8B%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">从叶节点开始的最小字符串</span></a></li></ol></div></p>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p>
</blockquote>
<p>中序遍历是左, 中, 右.</p>
<h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题: 二叉搜索树的第k小元素: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">https://leetcode.cn/problems/kth-smallest-element-in-a-bst/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> k, ans;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> _k)</span> </span>&#123;<br>        k = _k;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(root-&gt;left)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (-- k == <span class="hljs-number">0</span>) &#123;<br>            ans = root-&gt;val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>简单的递归应用 (二叉搜索树的范围和): <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-of-bst/">https://leetcode.cn/problems/range-sum-of-bst/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSumBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-built_in">rangeSumBST</span>(root-&gt;left, low, high);<br>        sum += <span class="hljs-built_in">rangeSumBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high) sum += root-&gt;val;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode*&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) <br>        &#123;<br>            <span class="hljs-keyword">while</span> (root)<br>            &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题(二叉树中序遍历迭代器): <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search-tree-iterator/">https://leetcode.cn/problems/binary-search-tree-iterator/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;TreeNode *&gt; stk;<br><br>    <span class="hljs-built_in">BSTIterator</span>(TreeNode* root) &#123;<br>        <span class="hljs-keyword">while</span> (root) &#123;<br>            stk.<span class="hljs-built_in">push</span>(root);<br>            root = root-&gt;left;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> root = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> val = root-&gt;val;<br>        root = root-&gt;right;<br>        <span class="hljs-keyword">while</span> (root) &#123;<br>            stk.<span class="hljs-built_in">push</span>(root);<br>            root = root-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p>
</blockquote>
<p>前序遍历是根, 左, 右.</p>
<h3 id="递归写法-1"><a href="#递归写法-1" class="headerlink" title="递归写法"></a>递归写法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="迭代写法-1"><a href="#迭代写法-1" class="headerlink" title="迭代写法"></a>迭代写法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span> (root)<br>            &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题(根据二叉树创建字符串): <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-string-from-binary-tree/">https://leetcode.cn/problems/construct-string-from-binary-tree/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-function">string <span class="hljs-title">tree2str</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            ans += <span class="hljs-string">&quot;()&quot;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        ans += <span class="hljs-built_in">to_string</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; root-&gt;right) &#123;<br>            ans += <span class="hljs-string">&quot;()&quot;</span>;<br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题: 叶子相似的树, <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/leaf-similar-trees/description/">https://leetcode.cn/problems/leaf-similar-trees/description/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) a.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, a), <span class="hljs-built_in">dfs</span>(root-&gt;right, a);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">leafSimilar</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; a, b;<br>        <span class="hljs-built_in">dfs</span>(root1, a);<br>        <span class="hljs-built_in">dfs</span>(root2, b);<br>        <span class="hljs-keyword">return</span> a == b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p>
</blockquote>
<p>后序遍历是左, 右, 根.</p>
<h3 id="递归写法-2"><a href="#递归写法-2" class="headerlink" title="递归写法"></a>递归写法</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="迭代写法-2"><a href="#迭代写法-2" class="headerlink" title="迭代写法"></a>迭代写法</h3>
<p>先按照根右左的顺序遍历, 然后反向即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;right;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            root = root-&gt;left;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal">https://leetcode.cn/problems/binary-tree-level-order-traversal</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/41/">https://www.acwing.com/problem/content/description/41/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/42/">https://www.acwing.com/problem/content/42/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>						<br>          <span class="hljs-comment">/* 每一层单独放 */</span><br>            <span class="hljs-keyword">while</span> (len --) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题(二叉树的右视图): <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">https://leetcode.cn/problems/binary-tree-right-side-view/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-comment">// 注意层序遍历不要忘记判断空节点</span><br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br>        queue&lt;TreeNode *&gt; q;<br><br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>                <span class="hljs-keyword">if</span> (i == len - <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="之字形层序遍历"><a href="#之字形层序遍历" class="headerlink" title="之字形层序遍历"></a>之字形层序遍历</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/43/">https://www.acwing.com/problem/content/description/43/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/</a></p>
</blockquote>
<p>在层序遍历的基础上用一个变量控制一下是否反转<code>level</code>即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        <br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <br>        <span class="hljs-type">bool</span> rev = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <br>            <span class="hljs-keyword">while</span> (len --)<br>            &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (rev) <span class="hljs-built_in">reverse</span>(level.<span class="hljs-built_in">begin</span>(), level.<span class="hljs-built_in">end</span>());<br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>            rev = !rev;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="前序中序恢复二叉树"><a href="#前序中序恢复二叉树" class="headerlink" title="前序中序恢复二叉树"></a>前序中序恢复二叉树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
</blockquote>
<p>首先, 前序遍历序列的第一个元素就是根节点, 通过哈希表可以找到第一个元素在中序遍历中的位置, 假设根节点在中序遍历中的下标是<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-1-TEX-I-1D458"/></g></g></g></svg>.</p>
<p>假设前序遍历的下标范围是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.235ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2755.7 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-2-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/><path id="MJX-2-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/><path id="MJX-2-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-2-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-2-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="5B" xlink:href="#MJX-2-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(278,0)"><use data-c="1D45D" xlink:href="#MJX-2-TEX-I-1D45D"/></g><g data-mml-node="mi" transform="translate(781,0)"><use data-c="1D459" xlink:href="#MJX-2-TEX-I-1D459"/></g><g data-mml-node="mo" transform="translate(1079,0)"><use data-c="2C" xlink:href="#MJX-2-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(1523.7,0)"><use data-c="1D45D" xlink:href="#MJX-2-TEX-I-1D45D"/></g><g data-mml-node="mi" transform="translate(2026.7,0)"><use data-c="1D45F" xlink:href="#MJX-2-TEX-I-1D45F"/></g><g data-mml-node="mo" transform="translate(2477.7,0)"><use data-c="5D" xlink:href="#MJX-2-TEX-N-5D"/></g></g></g></svg>, 中序遍历的下标范围是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.52ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2439.7 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-3-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-3-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/><path id="MJX-3-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-3-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-3-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="5B" xlink:href="#MJX-3-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(278,0)"><use data-c="1D456" xlink:href="#MJX-3-TEX-I-1D456"/></g><g data-mml-node="mi" transform="translate(623,0)"><use data-c="1D459" xlink:href="#MJX-3-TEX-I-1D459"/></g><g data-mml-node="mo" transform="translate(921,0)"><use data-c="2C" xlink:href="#MJX-3-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(1365.7,0)"><use data-c="1D456" xlink:href="#MJX-3-TEX-I-1D456"/></g><g data-mml-node="mi" transform="translate(1710.7,0)"><use data-c="1D45F" xlink:href="#MJX-3-TEX-I-1D45F"/></g><g data-mml-node="mo" transform="translate(2161.7,0)"><use data-c="5D" xlink:href="#MJX-3-TEX-N-5D"/></g></g></g></svg>, 那么:</p>
<ul>
<li>左子树在前序遍历的下标范围是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="35.298ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 15601.8 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-4-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-4-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/><path id="MJX-4-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/><path id="MJX-4-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-4-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-4-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-4-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-4-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-4-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/><path id="MJX-4-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-4-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/><path id="MJX-4-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="5B" xlink:href="#MJX-4-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(278,0)"><use data-c="1D45D" xlink:href="#MJX-4-TEX-I-1D45D"/></g><g data-mml-node="mi" transform="translate(781,0)"><use data-c="1D459" xlink:href="#MJX-4-TEX-I-1D459"/></g><g data-mml-node="mo" transform="translate(1301.2,0)"><use data-c="2B" xlink:href="#MJX-4-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(2301.4,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(2801.4,0)"><use data-c="2C" xlink:href="#MJX-4-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(3246.1,0)"><use data-c="1D45D" xlink:href="#MJX-4-TEX-I-1D45D"/></g><g data-mml-node="mi" transform="translate(3749.1,0)"><use data-c="1D459" xlink:href="#MJX-4-TEX-I-1D459"/></g><g data-mml-node="mo" transform="translate(4269.3,0)"><use data-c="2B" xlink:href="#MJX-4-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(5269.6,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(5991.8,0)"><use data-c="2B" xlink:href="#MJX-4-TEX-N-2B"/></g><g data-mml-node="mo" transform="translate(6992,0)"><use data-c="28" xlink:href="#MJX-4-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(7381,0)"><use data-c="1D458" xlink:href="#MJX-4-TEX-I-1D458"/></g><g data-mml-node="mo" transform="translate(8124.2,0)"><use data-c="2212" xlink:href="#MJX-4-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(9124.4,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(9846.7,0)"><use data-c="2212" xlink:href="#MJX-4-TEX-N-2212"/></g><g data-mml-node="mi" transform="translate(10846.9,0)"><use data-c="1D456" xlink:href="#MJX-4-TEX-I-1D456"/></g><g data-mml-node="mi" transform="translate(11191.9,0)"><use data-c="1D459" xlink:href="#MJX-4-TEX-I-1D459"/></g><g data-mml-node="mo" transform="translate(11712.1,0)"><use data-c="2B" xlink:href="#MJX-4-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(12712.3,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(13212.3,0)"><use data-c="29" xlink:href="#MJX-4-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(13823.6,0)"><use data-c="2212" xlink:href="#MJX-4-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(14823.8,0)"><use data-c="31" xlink:href="#MJX-4-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(15323.8,0)"><use data-c="5D" xlink:href="#MJX-4-TEX-N-5D"/></g></g></g></svg></li>
<li>右子树在前序遍历的下标范围是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="31.747ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 14032.3 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-5-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-5-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/><path id="MJX-5-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/><path id="MJX-5-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-5-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-5-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-5-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-5-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/><path id="MJX-5-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-5-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/><path id="MJX-5-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-5-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-5-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="5B" xlink:href="#MJX-5-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(278,0)"><use data-c="1D45D" xlink:href="#MJX-5-TEX-I-1D45D"/></g><g data-mml-node="mi" transform="translate(781,0)"><use data-c="1D459" xlink:href="#MJX-5-TEX-I-1D459"/></g><g data-mml-node="mo" transform="translate(1301.2,0)"><use data-c="2B" xlink:href="#MJX-5-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(2301.4,0)"><use data-c="31" xlink:href="#MJX-5-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(3023.7,0)"><use data-c="2B" xlink:href="#MJX-5-TEX-N-2B"/></g><g data-mml-node="mo" transform="translate(4023.9,0)"><use data-c="28" xlink:href="#MJX-5-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(4412.9,0)"><use data-c="1D458" xlink:href="#MJX-5-TEX-I-1D458"/></g><g data-mml-node="mo" transform="translate(5156.1,0)"><use data-c="2212" xlink:href="#MJX-5-TEX-N-2212"/></g><g data-mml-node="mi" transform="translate(6156.3,0)"><use data-c="1D456" xlink:href="#MJX-5-TEX-I-1D456"/></g><g data-mml-node="mi" transform="translate(6501.3,0)"><use data-c="1D459" xlink:href="#MJX-5-TEX-I-1D459"/></g><g data-mml-node="mo" transform="translate(7021.6,0)"><use data-c="2B" xlink:href="#MJX-5-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(8021.8,0)"><use data-c="31" xlink:href="#MJX-5-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(8521.8,0)"><use data-c="29" xlink:href="#MJX-5-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(9133,0)"><use data-c="2212" xlink:href="#MJX-5-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(10133.2,0)"><use data-c="31" xlink:href="#MJX-5-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(10855.4,0)"><use data-c="2B" xlink:href="#MJX-5-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(11855.7,0)"><use data-c="31" xlink:href="#MJX-5-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(12355.7,0)"><use data-c="2C" xlink:href="#MJX-5-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(12800.3,0)"><use data-c="1D45D" xlink:href="#MJX-5-TEX-I-1D45D"/></g><g data-mml-node="mi" transform="translate(13303.3,0)"><use data-c="1D45F" xlink:href="#MJX-5-TEX-I-1D45F"/></g><g data-mml-node="mo" transform="translate(13754.3,0)"><use data-c="5D" xlink:href="#MJX-5-TEX-N-5D"/></g></g></g></svg></li>
<li>左子树在中序遍历的下标范围是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.794ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3887.1 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-6-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-6-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-6-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/><path id="MJX-6-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-6-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-6-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/><path id="MJX-6-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-6-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="5B" xlink:href="#MJX-6-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(278,0)"><use data-c="1D456" xlink:href="#MJX-6-TEX-I-1D456"/></g><g data-mml-node="mi" transform="translate(623,0)"><use data-c="1D459" xlink:href="#MJX-6-TEX-I-1D459"/></g><g data-mml-node="mo" transform="translate(921,0)"><use data-c="2C" xlink:href="#MJX-6-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(1365.7,0)"><use data-c="1D458" xlink:href="#MJX-6-TEX-I-1D458"/></g><g data-mml-node="mo" transform="translate(2108.9,0)"><use data-c="2212" xlink:href="#MJX-6-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(3109.1,0)"><use data-c="31" xlink:href="#MJX-6-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(3609.1,0)"><use data-c="5D" xlink:href="#MJX-6-TEX-N-5D"/></g></g></g></svg></li>
<li>右子树在中序遍历的下标范围是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.141ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4040.1 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-7-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-7-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-7-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-7-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-7-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-7-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-7-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-7-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="5B" xlink:href="#MJX-7-TEX-N-5B"/></g><g data-mml-node="mi" transform="translate(278,0)"><use data-c="1D458" xlink:href="#MJX-7-TEX-I-1D458"/></g><g data-mml-node="mo" transform="translate(1021.2,0)"><use data-c="2B" xlink:href="#MJX-7-TEX-N-2B"/></g><g data-mml-node="mn" transform="translate(2021.4,0)"><use data-c="31" xlink:href="#MJX-7-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(2521.4,0)"><use data-c="2C" xlink:href="#MJX-7-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(2966.1,0)"><use data-c="1D456" xlink:href="#MJX-7-TEX-I-1D456"/></g><g data-mml-node="mi" transform="translate(3311.1,0)"><use data-c="1D45F" xlink:href="#MJX-7-TEX-I-1D45F"/></g><g data-mml-node="mo" transform="translate(3762.1,0)"><use data-c="5D" xlink:href="#MJX-7-TEX-N-5D"/></g></g></g></svg></li>
</ul>
<p>然后递归建树即可, 时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-8-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-8-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-8-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-8-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-8-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-8-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-8-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-8-TEX-N-29"/></g></g></g></svg>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;preorder, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inorder, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pl &gt; pr) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> val = preorder[pl];<br>        <span class="hljs-type">int</span> k = hash[val];<br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br><br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(preorder, inorder, pl + <span class="hljs-number">1</span>, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il, il, k - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(preorder, inorder, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il + <span class="hljs-number">1</span>, pr, k + <span class="hljs-number">1</span>, ir);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) hash[inorder[i]] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>注意, 只有前序和后序不能唯一确定一个二叉树</p>
<h2 id="后序中序恢复二叉树"><a href="#后序中序恢复二叉树" class="headerlink" title="后序中序恢复二叉树"></a>后序中序恢复二叉树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description</a></p>
</blockquote>
<p>分析思路和上一题相同.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;inorder, vector&lt;<span class="hljs-type">int</span>&gt; &amp;postorder, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pl &gt; pr) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> val = postorder[pr];<br>        <span class="hljs-type">int</span> k = hash[val];<br><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br><br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(inorder, postorder, il, k - <span class="hljs-number">1</span>, pl, pl + k - <span class="hljs-number">1</span> - il);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(inorder, postorder, k + <span class="hljs-number">1</span>, ir, pl + k - <span class="hljs-number">1</span> - il + <span class="hljs-number">1</span>, pr - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) hash[inorder[i]] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(inorder, postorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>); <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="前序后序恢复二叉树"><a href="#前序后序恢复二叉树" class="headerlink" title="前序后序恢复二叉树"></a>前序后序恢复二叉树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</a></p>
</blockquote>
<blockquote>
<p>为什么根据前序遍历和后序遍历无法恢复二叉树?</p>
</blockquote>
<p>假设我有一个节点, 它的左子树/右子树不存在, 但是在前序/后序遍历中, 都无法反映这个子树不存在的信息, 因此如果你从前序/后序遍历中发现一个子树不存在, 它既可以是左子树不存在, 也可以是右子树不存在, 选一个就可以.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;preorder, vector&lt;<span class="hljs-type">int</span>&gt; &amp;postorder, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (a &gt; b) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[a]);<br>        <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">// 左根在后序遍历中的位置</span><br>        <span class="hljs-type">int</span> k = hash[preorder[a + <span class="hljs-number">1</span>]];<br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(preorder, postorder, a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + (k - x + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>, x, k);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(preorder, postorder, a + <span class="hljs-number">1</span> + (k - x + <span class="hljs-number">1</span>), b, k + <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructFromPrePost</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = postorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) hash[postorder[i]] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preorder, postorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树中序遍历的下一个节点"><a href="#二叉树中序遍历的下一个节点" class="headerlink" title="二叉树中序遍历的下一个节点"></a>二叉树中序遍历的下一个节点</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/31/">https://www.acwing.com/problem/content/description/31/</a></p>
</blockquote>
<p>分两种情况:</p>
<ul>
<li>第一: 如果给定节点有右子树, 那么下一个节点就是右子树最左边的节点, 对应左根右的右这一部分.</li>
<li>第二: 如果给定节点没有右子树, 那么它需要向上, 找到节点<svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.138ex" height="1.439ex" role="img" focusable="false" viewbox="0 -442 503 636" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-9-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45D" xlink:href="#MJX-9-TEX-I-1D45D"/></g></g></g></svg>, 使得<svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="17.731ex" height="2.059ex" role="img" focusable="false" viewbox="0 -705 7836.9 910" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-10-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/><path id="MJX-10-TEX-N-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/><path id="MJX-10-TEX-I-1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/><path id="MJX-10-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/><path id="MJX-10-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/><path id="MJX-10-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/><path id="MJX-10-TEX-I-1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/><path id="MJX-10-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-10-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/><path id="MJX-10-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45D" xlink:href="#MJX-10-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(503,0)"><use data-c="2E" xlink:href="#MJX-10-TEX-N-2E"/></g><g data-mml-node="mi" transform="translate(947.7,0)"><use data-c="1D453" xlink:href="#MJX-10-TEX-I-1D453"/></g><g data-mml-node="mi" transform="translate(1497.7,0)"><use data-c="1D44E" xlink:href="#MJX-10-TEX-I-1D44E"/></g><g data-mml-node="mi" transform="translate(2026.7,0)"><use data-c="1D461" xlink:href="#MJX-10-TEX-I-1D461"/></g><g data-mml-node="mi" transform="translate(2387.7,0)"><use data-c="210E" xlink:href="#MJX-10-TEX-I-210E"/></g><g data-mml-node="mi" transform="translate(2963.7,0)"><use data-c="1D452" xlink:href="#MJX-10-TEX-I-1D452"/></g><g data-mml-node="mi" transform="translate(3429.7,0)"><use data-c="1D45F" xlink:href="#MJX-10-TEX-I-1D45F"/></g><g data-mml-node="mo" transform="translate(3880.7,0)"><use data-c="2E" xlink:href="#MJX-10-TEX-N-2E"/></g><g data-mml-node="mi" transform="translate(4325.3,0)"><use data-c="1D459" xlink:href="#MJX-10-TEX-I-1D459"/></g><g data-mml-node="mi" transform="translate(4623.3,0)"><use data-c="1D452" xlink:href="#MJX-10-TEX-I-1D452"/></g><g data-mml-node="mi" transform="translate(5089.3,0)"><use data-c="1D453" xlink:href="#MJX-10-TEX-I-1D453"/></g><g data-mml-node="mi" transform="translate(5639.3,0)"><use data-c="1D461" xlink:href="#MJX-10-TEX-I-1D461"/></g><g data-mml-node="mo" transform="translate(6278.1,0)"><use data-c="3D" xlink:href="#MJX-10-TEX-N-3D"/></g><g data-mml-node="mi" transform="translate(7333.9,0)"><use data-c="1D45D" xlink:href="#MJX-10-TEX-I-1D45D"/></g></g></g></svg>, 那么<svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="8.78ex" height="2.059ex" role="img" focusable="false" viewbox="0 -705 3880.7 910" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-11-TEX-I-1D45D" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/><path id="MJX-11-TEX-N-2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/><path id="MJX-11-TEX-I-1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/><path id="MJX-11-TEX-I-1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/><path id="MJX-11-TEX-I-1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/><path id="MJX-11-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/><path id="MJX-11-TEX-I-1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"/><path id="MJX-11-TEX-I-1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45D" xlink:href="#MJX-11-TEX-I-1D45D"/></g><g data-mml-node="mo" transform="translate(503,0)"><use data-c="2E" xlink:href="#MJX-11-TEX-N-2E"/></g><g data-mml-node="mi" transform="translate(947.7,0)"><use data-c="1D453" xlink:href="#MJX-11-TEX-I-1D453"/></g><g data-mml-node="mi" transform="translate(1497.7,0)"><use data-c="1D44E" xlink:href="#MJX-11-TEX-I-1D44E"/></g><g data-mml-node="mi" transform="translate(2026.7,0)"><use data-c="1D461" xlink:href="#MJX-11-TEX-I-1D461"/></g><g data-mml-node="mi" transform="translate(2387.7,0)"><use data-c="210E" xlink:href="#MJX-11-TEX-I-210E"/></g><g data-mml-node="mi" transform="translate(2963.7,0)"><use data-c="1D452" xlink:href="#MJX-11-TEX-I-1D452"/></g><g data-mml-node="mi" transform="translate(3429.7,0)"><use data-c="1D45F" xlink:href="#MJX-11-TEX-I-1D45F"/></g></g></g></svg>就是下一个节点, 对应左根右的根这一部分.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">inorderSuccessor</span><span class="hljs-params">(TreeNode* p)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;right) &#123;<br>            p = p-&gt;right;<br>            <span class="hljs-keyword">while</span> (p-&gt;left) p = p-&gt;left;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (p-&gt;father &amp;&amp; p-&gt;father-&gt;right == p) p = p-&gt;father;<br>            <span class="hljs-keyword">return</span> p-&gt;father;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉搜索树的搜索操作"><a href="#二叉搜索树的搜索操作" class="headerlink" title="二叉搜索树的搜索操作"></a>二叉搜索树的搜索操作</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">https://leetcode.cn/problems/search-in-a-binary-search-tree/</a></p>
</blockquote>
<p>迭代写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">while</span> (root) &#123;<br>            <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) root = root-&gt;left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; root-&gt;val) root = root-&gt;right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>递归写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (val == root-&gt;val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">https://leetcode.cn/problems/insert-into-a-binary-search-tree/</a></p>
</blockquote>
<p>递归写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">else</span> root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉搜索树的删除操作"><a href="#二叉搜索树的删除操作" class="headerlink" title="二叉搜索树的删除操作"></a>二叉搜索树的删除操作</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">https://leetcode.cn/problems/delete-node-in-a-bst/</a></p>
</blockquote>
<p>二叉搜索树的删除分为如下三种情况:</p>
<ul>
<li>如果要删除的节点是叶子节点, 那么直接把这个节点变成null就行.</li>
<li>如果要删除的节点只有左子树/右子树, 那么直接把左子树/右子树提上来就行.</li>
<li>如果要删除的节点左子树和右子树都有, 那么就找后继节点, 让后继节点覆盖当前节点, 然后再从右子树中递归删除后继节点.
<ul>
<li>注意, 由于后继节点没有左子树, 如果递归的话, 那么就是第一种/第二种情况.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-built_in">del</span>(root, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (key &lt; root-&gt;val) &#123;<br>            <span class="hljs-built_in">del</span>(root-&gt;left, key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (key &gt; root-&gt;val) &#123;<br>            <span class="hljs-built_in">del</span>(root-&gt;right, key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) root = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root-&gt;left) root = root-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root-&gt;right) root = root-&gt;left;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> next = root-&gt;right;<br>            <span class="hljs-keyword">while</span> (next-&gt;left) next = next-&gt;left;<br>            root-&gt;val = next-&gt;val;<br>            <span class="hljs-built_in">del</span>(root-&gt;right, next-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉搜索树的后序遍历"><a href="#二叉搜索树的后序遍历" class="headerlink" title="二叉搜索树的后序遍历"></a>二叉搜索树的后序遍历</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/44/">https://www.acwing.com/problem/content/44/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifySequenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = sequence.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, sequence);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp;sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-type">int</span> index = l, root = sequence[r];<br>        <br>        <span class="hljs-keyword">while</span> (index &lt; r &amp;&amp; sequence[index] &lt; root) index ++;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; r; i ++)<br>            <span class="hljs-keyword">if</span> (sequence[i] &lt; root)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(l, index - <span class="hljs-number">1</span>, sequence) &amp;&amp; <span class="hljs-built_in">dfs</span>(index, r - <span class="hljs-number">1</span>, sequence);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树中和是某一值的路径"><a href="#二叉树中和是某一值的路径" class="headerlink" title="二叉树中和是某一值的路径"></a>二叉树中和是某一值的路径</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/45/">https://www.acwing.com/problem/content/description/45/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii">https://leetcode.cn/problems/path-sum-ii</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findPath</span>(TreeNode* root, <span class="hljs-type">int</span> sum) &#123;<br>        <br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">dfs</span>(root, sum);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> sum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        sum -= root-&gt;val;<br>        <br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !sum)<br>        &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            sum += root-&gt;val;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, sum);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, sum);<br><br>        path.<span class="hljs-built_in">pop_back</span>();<br>        <br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        targetSum -= root-&gt;val;<br><br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !targetSum) &#123;<br>            targetSum += root-&gt;val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, targetSum);<br>        <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, targetSum);<br><br>        <span class="hljs-keyword">if</span> (left || right) &#123;<br>            targetSum += root-&gt;val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/35/">https://www.acwing.com/problem/content/35/</a></p>
</blockquote>
<p>注意, 在这个题中, 空🌲不是任何🌲的子结构, 在这个图中, <code>subRoot</code>是<code>root</code>的子结构.</p>
<img alt="树的子结构的定义" src="/2024/03/30/binary-tree/image-20240321195934006.png" style="zoom:50%;">
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 判断r2子树是否是r1子树的子结构 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *r1, TreeNode *r2)</span> </span>&#123;<br>      <span class="hljs-comment">// 注意, 这里有顺序, 一定要先判断r2是否为空</span><br>        <span class="hljs-keyword">if</span> (!r2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!r1) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (r1-&gt;val != r2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(r1-&gt;left, r2-&gt;left) &amp;&amp; <span class="hljs-built_in">dfs</span>(r1-&gt;right, r2-&gt;right);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>        <span class="hljs-comment">/* 如果是有一个是NULL, 那么就不是子结构 */</span><br>        <span class="hljs-keyword">if</span> (!pRoot1 || !pRoot2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(pRoot1, pRoot2)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      	<span class="hljs-comment">// 注意这里是hasSubtree而不是dfs</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasSubtree</span>(pRoot1-&gt;left, pRoot2) || <span class="hljs-built_in">hasSubtree</span>(pRoot1-&gt;right, pRoot2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这里还有一道变式题, <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">https://leetcode.cn/problems/subtree-of-another-tree/</a></p>
<p>要求判断是不是子树, 在这种情况下<code>subRoot</code>肯定不是<code>Root</code>的子树.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> !p &amp;&amp; !q;<br>        <span class="hljs-keyword">if</span> (p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="hljs-built_in">dfs</span>(p-&gt;right, q-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root || !subRoot) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(root, subRoot)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubtree</span>(root-&gt;left, subRoot) || <span class="hljs-built_in">isSubtree</span>(root-&gt;right, subRoot);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/37/">https://www.acwing.com/problem/content/description/37/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></p>
</blockquote>
<p>将二叉树变成镜像的方法就是递归地把左右节点交换即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mirror</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">mirror</span>(root-&gt;left);<br>        <span class="hljs-built_in">mirror</span>(root-&gt;right);<br>        <br>        <span class="hljs-keyword">auto</span> t = root-&gt;left;<br>        root-&gt;left = root-&gt;right;<br>        root-&gt;right = t;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题: 判断是否是平衡二叉树, 就是在<code>maxDepth</code>函数中再维护其他信息.</p>
<p>(平衡🌲就是对于🌲中的任意一个节点, 左子树和右子树的最大深度之差绝对值不超过1, 空🌲也是平衡树).</p>
<p>链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> ans = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lh = <span class="hljs-built_in">dfs</span>(root-&gt;left), rh = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(lh - rh) &gt; <span class="hljs-number">1</span>) ans = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lh, rh) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>变式题: 二叉树的最小深度, <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 注意一个节点为空, 另一个节点不为空的情况, 这种情况应该只取一边</span><br>        <span class="hljs-keyword">if</span> (!root-&gt;left) <span class="hljs-keyword">return</span> <span class="hljs-built_in">minDepth</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-built_in">minDepth</span>(root-&gt;left) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">minDepth</span>(root-&gt;left), <span class="hljs-built_in">minDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/38/">https://www.acwing.com/problem/content/description/38/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 判断p和q所在的子树是否对称 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> !p &amp;&amp; !q;<br>        <span class="hljs-keyword">if</span> (p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="hljs-built_in">dfs</span>(p-&gt;right, q-&gt;left);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/description/">https://leetcode.cn/problems/same-tree/description/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> !p &amp;&amp; !q;<br>        <span class="hljs-keyword">if</span> (p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="hljs-built_in">isSameTree</span>(p-&gt;right, q-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题(翻转等价二叉树): <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flip-equivalent-binary-trees/">https://leetcode.cn/problems/flip-equivalent-binary-trees/</a></p>
<ul>
<li>这个题的时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-12-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-12-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-12-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-12-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-12-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-12-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-12-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-12-TEX-N-29"/></g></g></g></svg>, 原因在于每个点都是不一样的, 也就是说等价的方式只有一种.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">flipEquiv</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root1 || !root2) <span class="hljs-keyword">return</span> !root1 &amp;&amp; !root2;<br>        <span class="hljs-keyword">if</span> (root1-&gt;val != root2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">flipEquiv</span>(root1-&gt;left, root2-&gt;left) &amp;&amp; <span class="hljs-built_in">flipEquiv</span>(root1-&gt;right, root2-&gt;right)) || (<span class="hljs-built_in">flipEquiv</span>(root1-&gt;left, root2-&gt;right) &amp;&amp; <span class="hljs-built_in">flipEquiv</span>(root1-&gt;right, root2-&gt;left));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root1) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span> (!root2) <span class="hljs-keyword">return</span> root1;<br><br>        root1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);<br>        root1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);<br><br>        root1-&gt;val += root2-&gt;val;<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, string path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br><br>        path += <span class="hljs-built_in">to_string</span>(root-&gt;val);<br><br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, path + <span class="hljs-string">&quot;-&gt;&quot;</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, path + <span class="hljs-string">&quot;-&gt;&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题: 求根节点到叶节点的数字之和</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">https://leetcode.cn/problems/sum-root-to-leaf-numbers/</a></p>
<h2 id="完全二叉树求节点个数"><a href="#完全二叉树求节点个数" class="headerlink" title="完全二叉树求节点个数"></a>完全二叉树求节点个数</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">https://leetcode.cn/problems/count-complete-tree-nodes/</a></p>
</blockquote>
<p>通用的代码: 这个所有树都可以使用, 时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-13-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-13-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-13-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-13-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-13-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-13-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-13-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-13-TEX-N-29"/></g></g></g></svg>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题: 二叉树的坡度 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-tilt/">https://leetcode.cn/problems/binary-tree-tilt/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTilt</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left), right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        ans += <span class="hljs-built_in">abs</span>(left - right);<br>        <span class="hljs-keyword">return</span> left + right + root-&gt;val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="不同的二叉搜索树求数目"><a href="#不同的二叉搜索树求数目" class="headerlink" title="不同的二叉搜索树求数目"></a>不同的二叉搜索树求数目</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">https://leetcode.cn/problems/unique-binary-search-trees/</a></p>
</blockquote>
<blockquote>
<p>二叉搜索树的中序遍历一定是严格递增的.</p>
</blockquote>
<p>假设<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.362ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1928 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-14-TEX-I-1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/><path id="MJX-14-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-14-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-14-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D453" xlink:href="#MJX-14-TEX-I-1D453"/></g><g data-mml-node="mo" transform="translate(550,0)"><use data-c="28" xlink:href="#MJX-14-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(939,0)"><use data-c="1D45B" xlink:href="#MJX-14-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1539,0)"><use data-c="29" xlink:href="#MJX-14-TEX-N-29"/></g></g></g></svg>表示长度为<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-15-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-15-TEX-I-1D45B"/></g></g></g></svg>, 元素为<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.753ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2100.7 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-16-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-16-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-16-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-16-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-16-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="5B" xlink:href="#MJX-16-TEX-N-5B"/></g><g data-mml-node="mn" transform="translate(278,0)"><use data-c="31" xlink:href="#MJX-16-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(778,0)"><use data-c="2C" xlink:href="#MJX-16-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(1222.7,0)"><use data-c="1D45B" xlink:href="#MJX-16-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1822.7,0)"><use data-c="5D" xlink:href="#MJX-16-TEX-N-5D"/></g></g></g></svg>的二叉搜索树的个数.</p>
<p>初始状态是<code>f[0] = 1</code>. 注意空子树这个形态是合法的, 因为一个状态会由它的左子树和右子树的状态转移而来, 而左子树和右子树可以为空.</p>
<p>从<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.753ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2100.7 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-17-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-17-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-17-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-17-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-17-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><use data-c="5B" xlink:href="#MJX-17-TEX-N-5B"/></g><g data-mml-node="mn" transform="translate(278,0)"><use data-c="31" xlink:href="#MJX-17-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(778,0)"><use data-c="2C" xlink:href="#MJX-17-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(1222.7,0)"><use data-c="1D45B" xlink:href="#MJX-17-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1822.7,0)"><use data-c="5D" xlink:href="#MJX-17-TEX-N-5D"/></g></g></g></svg>进行枚举, 对于状态<code>i</code>, 再从<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.874ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3480.2 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-18-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/><path id="MJX-18-TEX-N-2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"/><path id="MJX-18-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-18-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-18-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-18-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-18-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D457" xlink:href="#MJX-18-TEX-I-1D457"/></g><g data-mml-node="mo" transform="translate(689.8,0)"><use data-c="2208" xlink:href="#MJX-18-TEX-N-2208"/></g><g data-mml-node="mo" transform="translate(1634.6,0)"><use data-c="5B" xlink:href="#MJX-18-TEX-N-5B"/></g><g data-mml-node="mn" transform="translate(1912.6,0)"><use data-c="31" xlink:href="#MJX-18-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(2412.6,0)"><use data-c="2C" xlink:href="#MJX-18-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(2857.2,0)"><use data-c="1D456" xlink:href="#MJX-18-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(3202.2,0)"><use data-c="5D" xlink:href="#MJX-18-TEX-N-5D"/></g></g></g></svg>进行枚举, <svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewbox="0 -661 412 865" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-19-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D457" xlink:href="#MJX-19-TEX-I-1D457"/></g></g></g></svg>作为根节点, 那么左子树和右子树的个数就分别是<code>f[j - 1]</code>和<code>f[i - (j + 1) + 1]</code>, 进行状态转移即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j ++) &#123;<br>                f[i] += f[j - <span class="hljs-number">1</span>] * f[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>从1~n构成的互不相同的二叉搜索树的个数是卡特兰数.</p>
</blockquote>
<h2 id="不同的二叉搜索树求方案"><a href="#不同的二叉搜索树求方案" class="headerlink" title="不同的二叉搜索树求方案"></a>不同的二叉搜索树求方案</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">https://leetcode.cn/problems/unique-binary-search-trees-ii/</a></p>
</blockquote>
<p>常规的搜索问题.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;TreeNode *&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">NULL</span>&#125;;<br>        vector&lt;TreeNode *&gt; res;<br><br>        <span class="hljs-comment">// 枚举根节点的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i ++) &#123;<br>            <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">dfs</span>(l, i - <span class="hljs-number">1</span>), right = <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, r);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : left) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> q: right) &#123;<br>                    TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(i);<br>                    root-&gt;left = p, root-&gt;right = q;<br>                    res.<span class="hljs-built_in">push_back</span>(root);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p>
</blockquote>
<p>方法一: 如果一个树是二叉搜索树, 等价于中序遍历严格递增.</p>
<p>方法二: 按照定义搜索, 需要求子树中所有元素的最小值和最大值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root)[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">// 返回三个信息, 是否是二叉搜索树, 子树最大值, 子树最小值</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(&#123; <span class="hljs-number">1</span>, root-&gt;val, root-&gt;val &#125;)</span></span>;<br>				<br>        <span class="hljs-keyword">if</span> (root-&gt;left) &#123;<br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>            <span class="hljs-keyword">if</span> (!t[<span class="hljs-number">0</span>] || t[<span class="hljs-number">2</span>] &gt;= root-&gt;val) res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            res[<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(root-&gt;val, t[<span class="hljs-number">1</span>]);<br>            res[<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(root-&gt;val, t[<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;right) &#123;<br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>            <span class="hljs-keyword">if</span> (!t[<span class="hljs-number">0</span>] || t[<span class="hljs-number">1</span>] &lt;= root-&gt;val) res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 注意这里min里面是res[1], 而不是root-&gt;val, 因为取最小值要连上左子树一起比较</span><br>            res[<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(res[<span class="hljs-number">1</span>], t[<span class="hljs-number">1</span>]);<br>            res[<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(res[<span class="hljs-number">2</span>], t[<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/recover-binary-search-tree/description/">https://leetcode.cn/problems/recover-binary-search-tree/description/</a></p>
</blockquote>
<p>首先, 对于一个二叉搜索树, 它的中序遍历一定是严格单调递增的序列.</p>
<p>如果两个节点被错误地交换了, 那么只有可能是两种情况:</p>
<ul>
<li>
<p>相邻的两个节点, 例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1, 2, 3, 4, 5 -&gt; 1, 3, 2, 4, 5<br></code></pre></td></tr></table></figure>
<p>这种情况下, 有一个相邻元素组成的逆序对<code>(3, 2)</code>, 只需要交换这两个元素的位置即可.</p>
</li>
<li>
<p>不相邻的两个节点, 例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1, 2, 3, 4, 5 -&gt; 1, 4, 3, 2, 5<br></code></pre></td></tr></table></figure>
<p>这种情况下, 有两个相邻元素组成的逆序对<code>(4, 3)</code>和<code>(3, 2)</code>, 只需要交换4和2的位置即可.</p>
</li>
</ul>
<p>时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-20-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-20-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-20-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-20-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-20-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-20-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-20-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-20-TEX-N-29"/></g></g></g></svg>.</p>
<p>如果空间复杂度要求是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-21-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-21-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-21-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-21-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-21-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-21-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-21-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-21-TEX-N-29"/></g></g></g></svg>的话, 可以在进行中序遍历时记录哪些节点需要交换, 直接交换即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;TreeNode*&gt; stk;<br>    vector&lt;TreeNode *&gt; inorder;<br>    vector&lt;TreeNode *&gt; element;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span> &amp;&amp; inorder.<span class="hljs-built_in">back</span>()-&gt;val &gt; root-&gt;val) &#123;<br>                element.<span class="hljs-built_in">push_back</span>(inorder.<span class="hljs-built_in">back</span>());<br>                element.<span class="hljs-built_in">push_back</span>(root);<br>            &#125;<br>            inorder.<span class="hljs-built_in">push_back</span>(root);<br>            root = root-&gt;right;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (element.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-type">int</span> t = element[<span class="hljs-number">0</span>]-&gt;val;<br>            element[<span class="hljs-number">0</span>]-&gt;val = element[<span class="hljs-number">1</span>]-&gt;val;<br>            element[<span class="hljs-number">1</span>]-&gt;val = t;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-built_in">size</span>() == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-type">int</span> t = element[<span class="hljs-number">0</span>]-&gt;val;<br>            element[<span class="hljs-number">0</span>]-&gt;val = element[<span class="hljs-number">3</span>]-&gt;val;<br>            element[<span class="hljs-number">3</span>]-&gt;val = t;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>如果空间复杂度要求是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-22-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-22-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-22-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-22-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-22-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-22-TEX-N-28"/></g><g data-mml-node="mn" transform="translate(1152,0)"><use data-c="31" xlink:href="#MJX-22-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(1652,0)"><use data-c="29" xlink:href="#MJX-22-TEX-N-29"/></g></g></g></svg>​的话, 就需要用到Morris遍历.</p>
<h3 id="Morris中序遍历"><a href="#Morris中序遍历" class="headerlink" title="Morris中序遍历"></a>Morris中序遍历</h3>
<p>Morris遍历的流程大概如下:</p>
<ul>
<li>首先, 将当前节点设置成根节点: <code>cur = root</code>.</li>
<li>如果当前节点有左子树:
<ul>
<li>找当前节点的前驱<code>prev</code>:
<ul>
<li>如果<code>prev</code>的右子树为空, 证明<code>cur</code>的左子树没有被遍历过, 将<code>prev-&gt;right</code>设置成当前节点<code>cur</code>, 然后<code>cur = cur-&gt;left</code>.</li>
<li>如果<code>prev</code>的右子树不为空, 证明<code>cur</code>的左子树已经被遍历过, 此时将<code>prev-&gt;right</code>设置为空, 然后打印<code>cur</code>的值, 然后跳转到右子树<code>cur = cur-&gt;right</code>.</li>
</ul>
</li>
</ul>
</li>
<li>如果当前节点没有左子树:
<ul>
<li>打印当前节点的值, 直接进入右子树 (此时一般会回溯到树的上层).</li>
</ul>
</li>
</ul>
<blockquote>
<p>在Morris遍历中, 需要对每个节点都求一次前驱, 但是节点求前驱的时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-23-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-23-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-23-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-23-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-23-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-23-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-23-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-23-TEX-N-29"/></g></g></g></svg>, 为什么Morris遍历的时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-24-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-24-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-24-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-24-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-24-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-24-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-24-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-24-TEX-N-29"/></g></g></g></svg>而不是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-25-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-25-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-25-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-25-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-25-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-25-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-25-TEX-N-28"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-25-TEX-I-1D45B"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><use data-c="32" xlink:href="#MJX-25-TEX-N-32"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><use data-c="29" xlink:href="#MJX-25-TEX-N-29"/></g></g></g></svg>?</p>
</blockquote>
<p>对二叉树的所有节点求一遍前驱的时间复杂度其实就是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-26-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-26-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-26-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-26-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-26-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-26-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-26-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-26-TEX-N-29"/></g></g></g></svg>, 因为每条边只会被遍历两次.</p>
<p>Morris遍历生成中序遍历的代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        <span class="hljs-keyword">auto</span> cur = root;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <br>            <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                <span class="hljs-comment">// find prev</span><br>                <span class="hljs-keyword">auto</span> prev = cur-&gt;left;<br>                <span class="hljs-keyword">while</span> (prev-&gt;right &amp;&amp; prev-&gt;right != cur) prev = prev-&gt;right;<br>                <br>                <span class="hljs-keyword">if</span> (!prev-&gt;right) &#123;<br>                    prev-&gt;right = cur;<br>                    cur = cur-&gt;left;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    prev-&gt;right = <span class="hljs-literal">NULL</span>;<br>                    ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                    cur = cur-&gt;right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                cur = cur-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>使用Morris遍历解决此题的代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">auto</span> cur = root;<br>        TreeNode *p = <span class="hljs-literal">NULL</span>;<br>        TreeNode *first = <span class="hljs-literal">NULL</span>;<br>        TreeNode *second = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">while</span> (cur) &#123;<br><br>            <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                <span class="hljs-keyword">auto</span> prev = cur-&gt;left;<br>                <span class="hljs-keyword">while</span> (prev-&gt;right &amp;&amp; prev-&gt;right != cur) prev = prev-&gt;right;<br>                <span class="hljs-keyword">if</span> (!prev-&gt;right) &#123;<br>                    prev-&gt;right = cur;<br>                    cur = cur-&gt;left;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    prev-&gt;right = <span class="hljs-literal">NULL</span>;<br>                    <span class="hljs-keyword">if</span> (p &amp;&amp; p-&gt;val &gt; cur-&gt;val) &#123;<br>                        <span class="hljs-keyword">if</span> (!first) first = p, second = cur;<br>                        <span class="hljs-keyword">else</span> second = cur;<br>                    &#125;<br>                    p = cur;<br>                    cur = cur-&gt;right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (p &amp;&amp; p-&gt;val &gt; cur-&gt;val) &#123;<br>                    <span class="hljs-keyword">if</span> (!first) first = p, second = cur;<br>                    <span class="hljs-keyword">else</span> second = cur;<br>                &#125;<br>                p = cur;<br>                cur = cur-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(first-&gt;val, second-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="有序数组变二叉搜索树"><a href="#有序数组变二叉搜索树" class="headerlink" title="有序数组变二叉搜索树"></a>有序数组变二叉搜索树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p>
</blockquote>
<p>时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-27-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-27-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-27-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-27-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-27-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-27-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-27-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-27-TEX-N-29"/></g></g></g></svg>​.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br><br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(nums, l, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(nums, mid + <span class="hljs-number">1</span>, r);<br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>证明: 用该算法得到的二叉搜索树的所有高度(不是最大高度)之差的最大值不超过1</p>
</blockquote>
<ul>
<li>左半部分的节点每次最多比右半部分少1, 如果高度差最大值是2, 那么必然左边会比右边多一层, 这根本不可能, 多1个节点贡献的高度差肯定吵不过1.</li>
</ul>
<h2 id="有序链表变二叉搜索树"><a href="#有序链表变二叉搜索树" class="headerlink" title="有序链表变二叉搜索树"></a>有序链表变二叉搜索树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/</a></p>
</blockquote>
<p>找有序链表的终点可以使用快慢指针.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(head, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">build</span><span class="hljs-params">(ListNode *s, ListNode *t)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span> (s == t) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">auto</span> fast = s, slow = s;<br><br>        <span class="hljs-keyword">while</span> (fast != t &amp;&amp; fast-&gt;next != t) &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(slow-&gt;val);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(s, slow);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(slow-&gt;next, t);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>时间复杂度是<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="21.777ex" height="2.477ex" role="img" focusable="false" viewbox="0 -750 9625.3 1095" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-28-TEX-I-1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/><path id="MJX-28-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-28-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-28-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/><path id="MJX-28-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-28-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-28-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-28-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D447" xlink:href="#MJX-28-TEX-I-1D447"/></g><g data-mml-node="mo" transform="translate(704,0)"><use data-c="28" xlink:href="#MJX-28-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1093,0)"><use data-c="1D45B" xlink:href="#MJX-28-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1693,0)"><use data-c="29" xlink:href="#MJX-28-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(2359.8,0)"><use data-c="3D" xlink:href="#MJX-28-TEX-N-3D"/></g><g data-mml-node="mn" transform="translate(3415.6,0)"><use data-c="32" xlink:href="#MJX-28-TEX-N-32"/></g><g data-mml-node="mi" transform="translate(3915.6,0)"><use data-c="1D447" xlink:href="#MJX-28-TEX-I-1D447"/></g><g data-mml-node="mo" transform="translate(4619.6,0)"><use data-c="28" xlink:href="#MJX-28-TEX-N-28"/></g><g data-mml-node="mfrac" transform="translate(5008.6,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-28-TEX-I-1D45B"/></g><g data-mml-node="mn" transform="translate(255.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-28-TEX-N-32"/></g><rect width="624.3" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(5872.8,0)"><use data-c="29" xlink:href="#MJX-28-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(6484,0)"><use data-c="2B" xlink:href="#MJX-28-TEX-N-2B"/></g><g data-mml-node="mi" transform="translate(7484.3,0)"><use data-c="1D442" xlink:href="#MJX-28-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(8247.3,0)"><use data-c="28" xlink:href="#MJX-28-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(8636.3,0)"><use data-c="1D45B" xlink:href="#MJX-28-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(9236.3,0)"><use data-c="29" xlink:href="#MJX-28-TEX-N-29"/></g></g></g></svg>, 根据主定理, 最后的时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.052ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4001 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-29-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-29-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-29-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-29-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/><path id="MJX-29-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/><path id="MJX-29-TEX-I-1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/><path id="MJX-29-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-29-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-29-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-29-TEX-I-1D45B"/></g><g data-mml-node="mi" transform="translate(1752,0)"><use data-c="1D459" xlink:href="#MJX-29-TEX-I-1D459"/></g><g data-mml-node="mi" transform="translate(2050,0)"><use data-c="1D45C" xlink:href="#MJX-29-TEX-I-1D45C"/></g><g data-mml-node="mi" transform="translate(2535,0)"><use data-c="1D454" xlink:href="#MJX-29-TEX-I-1D454"/></g><g data-mml-node="mi" transform="translate(3012,0)"><use data-c="1D45B" xlink:href="#MJX-29-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(3612,0)"><use data-c="29" xlink:href="#MJX-29-TEX-N-29"/></g></g></g></svg>.</p>
<h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/</a></p>
</blockquote>
<p>每一次只需要将当前节点<code>cur</code>的左节点<code>cur-&gt;left</code>到<code>cur</code>的前驱节点这一条路合并到右子树就可以了, 合并之后<code>cur</code>向右移动.</p>
<p>效果如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.  1<br>   / \<br>  2   5<br> / \   \<br>3   4   6<br><br>2.  1<br>     \<br>      2<br>     / \<br>    3   4<br>         \<br>          5<br>           \<br>            6<br><br>3.  1<br>     \<br>      2<br>       \<br>        3<br>         \<br>          4<br>           \<br>            5<br>             \<br>              6<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur = root;<br><br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                <span class="hljs-keyword">auto</span> prev = cur-&gt;left;<br>                <span class="hljs-keyword">while</span> (prev-&gt;right) prev = prev-&gt;right;<br>                prev-&gt;right = cur-&gt;right;<br>                cur-&gt;right = cur-&gt;left;<br>                cur-&gt;left = <span class="hljs-number">0</span>;<br>            &#125;<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>类似的题 (递增顺序搜索树):<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/increasing-order-search-tree/">https://leetcode.cn/problems/increasing-order-search-tree/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode *cur;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <br>        cur = cur-&gt;right = root;<br>        root-&gt;left = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">-1</span>);<br>        cur = dummy;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> dummy-&gt;right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="填充每个节点的下一个右侧节点"><a href="#填充每个节点的下一个右侧节点" class="headerlink" title="填充每个节点的下一个右侧节点"></a>填充每个节点的下一个右侧节点</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/</a></p>
</blockquote>
<p>最简单也是最容易想的方法: 层序遍历</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        queue&lt;Node *&gt; q;<br>        <br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;Node *&gt; level;<br>            <span class="hljs-keyword">while</span> (len --) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(t);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; level.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; level.<span class="hljs-built_in">size</span>()) &#123;<br>                    level[i]-&gt;next = level[i + <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> level[i]-&gt;next = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>但是用层序遍历的空间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-30-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-30-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-30-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-30-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-30-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-30-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-30-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-30-TEX-N-29"/></g></g></g></svg>, 如果要求用常数空间, 可以借助bfs的思想</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>				<br>      	<span class="hljs-comment">// 注意这里判断p的时候应该用p-&gt;left不为空, 因为要操作下一层节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = root; p-&gt;left; p = p-&gt;left) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> q = p; q; q = q-&gt;next) &#123;<br>              <span class="hljs-comment">// 核心点</span><br>                q-&gt;left-&gt;next = q-&gt;right;<br>                q-&gt;right-&gt;next = q-&gt;next ? q-&gt;next-&gt;left : <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>其中核心点在于, 我遍历这一层时, 我操作下一层的<code>next</code>指针, 假设我遍历到节点<code>cur</code>:</p>
<ul>
<li><code>cur</code>左儿子的<code>next</code>应该指向<code>cur-&gt;right</code>.</li>
<li><code>cur</code>右儿子的<code>next</code>应该指向<code>cur-&gt;next-&gt;left</code>.
<ul>
<li>注意, <code>cur</code>右儿子的<code>next</code>应该是我在遍历<code>cur</code>上层节点的时候设置好了, 这其实就是一个<code>bfs</code>迭代的过程.</li>
</ul>
</li>
</ul>
<p>变式: 如果二叉树不是满二叉树</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/</a></p>
<p>此时, 再遍历上一层时, 只需要用链表的形式把下一层节点串起来即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">auto</span> cur = root;<br><br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-comment">// 每一层维护两个变量, 所以是常数空间</span><br>            <span class="hljs-keyword">auto</span> head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">auto</span> tail = head;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = cur; p; p = p-&gt;next) &#123;<br>                <span class="hljs-keyword">if</span> (p-&gt;left) tail = tail-&gt;next = p-&gt;left;<br>                <span class="hljs-keyword">if</span> (p-&gt;right) tail = tail-&gt;next = p-&gt;right;<br>            &#125;<br>            <br>            cur = head-&gt;next;<br>            <span class="hljs-keyword">delete</span> head;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉搜索树的LCA"><a href="#二叉搜索树的LCA" class="headerlink" title="二叉搜索树的LCA"></a>二叉搜索树的LCA</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>
</blockquote>
<p>时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.79ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2117 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-31-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-31-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-31-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/><path id="MJX-31-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-31-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-31-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="210E" xlink:href="#MJX-31-TEX-I-210E"/></g><g data-mml-node="mo" transform="translate(1728,0)"><use data-c="29" xlink:href="#MJX-31-TEX-N-29"/></g></g></g></svg>, 其中<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.303ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 576 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-32-TEX-I-210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="210E" xlink:href="#MJX-32-TEX-I-210E"/></g></g></g></svg>是二叉搜索树的高度.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;val &gt; q-&gt;val) <span class="hljs-built_in">swap</span>(p, q);<br>        <span class="hljs-keyword">if</span> (p-&gt;val &lt;= root-&gt;val &amp;&amp; q-&gt;val &gt;= root-&gt;val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (q-&gt;val &lt; root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        <span class="hljs-keyword">if</span> (p-&gt;val &gt; root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的LCA"><a href="#二叉树的LCA" class="headerlink" title="二叉树的LCA"></a>二叉树的LCA</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
</blockquote>
<p>时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-33-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-33-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-33-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-33-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-33-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-33-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-33-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-33-TEX-N-29"/></g></g></g></svg>.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode * ans = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, p, q);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断root所在子树中是否存在节点p, q</span><br>    <span class="hljs-comment">// 00: 没有pq, 01: 有p, 10: 有q, 11: 有pq</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> state = <span class="hljs-built_in">dfs</span>(root-&gt;left, p, q);<br>        <span class="hljs-keyword">if</span> (root == p) state |= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root == q) state |= <span class="hljs-number">2</span>;<br>        state |= <span class="hljs-built_in">dfs</span>(root-&gt;right, p, q);<br>      <span class="hljs-comment">// 如果一个子树里同时有p, q, 并且第一次被遍历到, 就是LCA</span><br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">3</span> &amp;&amp; !ans) ans = root;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="验证二叉树前序序列化"><a href="#验证二叉树前序序列化" class="headerlink" title="验证二叉树前序序列化"></a>验证二叉树前序序列化</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/">https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/</a></p>
</blockquote>
<p>按照前序遍历的递归过程模拟吃掉元素, 如果吃掉元素过程中有问题就有问题.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(string preorder)</span> </span>&#123;<br>        preorder += <span class="hljs-string">&quot;,&quot;</span>;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(preorder, u)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果我遍历完了, 但是字符串还有, 不合法</span><br>        <span class="hljs-keyword">return</span> u == preorder.<span class="hljs-built_in">size</span>();<br>    &#125;<br>		<br>  <span class="hljs-comment">// 注意这里的u加了引用, 表示所有dfs共用u</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string preorder, <span class="hljs-type">int</span> &amp;u)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果我还没遍历完, 但是字符串没了, 不合法</span><br>        <span class="hljs-keyword">if</span> (u == preorder.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 子树遍历完了</span><br>        <span class="hljs-keyword">if</span> (preorder[u] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>            u += <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 过滤到下一个元素</span><br>        <span class="hljs-keyword">while</span> (preorder[u] != <span class="hljs-string">&#x27;,&#x27;</span>) u ++;<br>        <span class="hljs-comment">// 过滤,</span><br>        u ++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preorder, u) &amp;&amp; <span class="hljs-built_in">dfs</span>(preorder, u);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/</a></p>
</blockquote>
<p>序列化可以采用前序遍历+记录空节点的方式.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs_s</span>(root, path);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_s</span><span class="hljs-params">(TreeNode *root, string &amp;path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            path += <span class="hljs-string">&quot;#,&quot;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        path += <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&quot;,&quot;</span>;<br>        <span class="hljs-built_in">dfs_s</span>(root-&gt;left, path);<br>        <span class="hljs-built_in">dfs_s</span>(root-&gt;right, path);<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs_d</span>(data, u);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs_d</span><span class="hljs-params">(string data, <span class="hljs-type">int</span> &amp;u)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (u == data.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (data[u] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>            u += <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> k = u;<br>            <span class="hljs-keyword">while</span> (data[u] != <span class="hljs-string">&#x27;,&#x27;</span>) u ++;<br>            <span class="hljs-type">int</span> val = <span class="hljs-built_in">stoi</span>(data.<span class="hljs-built_in">substr</span>(k, u - k));<br>            u ++;<br>            <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            root-&gt;left = <span class="hljs-built_in">dfs_d</span>(data, u);<br>            root-&gt;right = <span class="hljs-built_in">dfs_d</span>(data, u);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉搜索树的序列化和反序列化"><a href="#二叉搜索树的序列化和反序列化" class="headerlink" title="二叉搜索树的序列化和反序列化"></a>二叉搜索树的序列化和反序列化</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">https://leetcode.cn/problems/serialize-and-deserialize-bst/</a></p>
</blockquote>
<p>如果是二叉搜索树, 那么就默认中序遍历已经给了, 因此, 可以直接拿前序遍历来做序列化.</p>
<p>反序列化时, 可以根据二叉搜索树的定义来区分左右子树的边界.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        string path = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">dfs_s</span>(root, path);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_s</span><span class="hljs-params">(TreeNode *root, string &amp;path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        path += <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-built_in">dfs_s</span>(root-&gt;left, path), <span class="hljs-built_in">dfs_s</span>(root-&gt;right, path);<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-comment">// 先将字符串转换为vector</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>        <span class="hljs-function">stringstream <span class="hljs-title">ssin</span><span class="hljs-params">(data)</span></span>;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (ssin &gt;&gt; x) arr.<span class="hljs-built_in">push_back</span>(x);<br><br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs_d</span>(arr, u, INT_MIN, INT_MAX);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs_d</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> &amp;u, <span class="hljs-type">int</span> minv, <span class="hljs-type">int</span> maxv)</span> </span>&#123;<br>        <span class="hljs-comment">// 遍历完</span><br>        <span class="hljs-keyword">if</span> (u == arr.<span class="hljs-built_in">size</span>() || arr[u] &lt; minv || arr[u] &gt; maxv) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(arr[u]);<br>        u ++;<br>        <span class="hljs-comment">// 左子树中节点的值在[minv, root-&gt;val]之间, 如果超出范围, 表示遍历完了</span><br>        root-&gt;left = <span class="hljs-built_in">dfs_d</span>(arr, u, minv, root-&gt;val);<br>        root-&gt;right = <span class="hljs-built_in">dfs_d</span>(arr, u, root-&gt;val, maxv);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="左子叶之和"><a href="#左子叶之和" class="headerlink" title="左子叶之和"></a>左子叶之和</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">https://leetcode.cn/problems/sum-of-left-leaves/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <br>        <span class="hljs-comment">// 如果root有左儿子, 并且还是叶子节点, 再累加</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) ans += root-&gt;left-&gt;val;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的最大路径和"><a href="#二叉树的最大路径和" class="headerlink" title="二叉树的最大路径和"></a>二叉树的最大路径和</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">https://leetcode.cn/problems/binary-tree-maximum-path-sum/</a></p>
</blockquote>
<p>枚举路径的时候, 我们可以先枚举这条路径左右端点的LCA, 假设LCA是u</p>
<ul>
<li>然后可以发现, 这个路径和是由三部分组成:
<ul>
<li>节点u本身的值.</li>
<li>节点u左子树往下的所有路径(注意这个路径不拐弯)的最大值.</li>
<li>节点u右子树往下所有路径的最大值.</li>
</ul>
</li>
<li>路径和可以由这三部分相加组成, 其中后两部分可以通过递归求出.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dfs</span>(root-&gt;left));<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dfs</span>(root-&gt;right));<br><br>        ans = <span class="hljs-built_in">max</span>(ans, root-&gt;val + left + right);<br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(left, right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题: 二叉树的直径: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">https://leetcode.cn/problems/diameter-of-binary-tree/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>      <span class="hljs-comment">// 直径是边数, 等于点数-1</span><br>        <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left), right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> res = left + right + <span class="hljs-number">1</span>;<br>        ans = <span class="hljs-built_in">max</span>(ans, res);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题: 最长同值路径, <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-univalue-path/">https://leetcode.cn/problems/longest-univalue-path/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">dfs</span>(root-&gt;left), r = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (!root-&gt;left || root-&gt;left-&gt;val != root-&gt;val) l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;right || root-&gt;right-&gt;val != root-&gt;val) r = <span class="hljs-number">0</span>;<br>        ans = <span class="hljs-built_in">max</span>(ans, l + r );<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l, r) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p>
</blockquote>
<p>用bfs记录一下即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-built_in">del</span>(root, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (key &lt; root-&gt;val) &#123;<br>            <span class="hljs-built_in">del</span>(root-&gt;left, key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (key &gt; root-&gt;val) &#123;<br>            <span class="hljs-built_in">del</span>(root-&gt;right, key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) root = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root-&gt;left) root = root-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root-&gt;right) root = root-&gt;left;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> next = root-&gt;right;<br>            <span class="hljs-keyword">while</span> (next-&gt;left) next = next-&gt;left;<br>            root-&gt;val = next-&gt;val;<br>            <span class="hljs-built_in">del</span>(root-&gt;right, next-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">https://leetcode.cn/problems/find-largest-value-in-each-tree-row/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> maxv = INT_MIN;<br>            <span class="hljs-keyword">while</span> (len --) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                maxv = <span class="hljs-built_in">max</span>(maxv, t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(maxv);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>同类题: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></p>
<p>二叉树层平均值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">double</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                sum += t-&gt;val;<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(sum / len);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a>路径总和III</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">https://leetcode.cn/problems/path-sum-iii/</a></p>
</blockquote>
<p>这个题有一个一维版本: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">https://leetcode.cn/problems/subarray-sum-equals-k/</a></p>
<p>解法使用前缀和+哈希表.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    unordered_map&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        hash[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">dfs</span>(root, targetSum, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> targetSum, <span class="hljs-type">long</span> <span class="hljs-type">long</span> path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        path += root-&gt;val;<br>        ans += hash[path - targetSum];<br>        hash[path] ++;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, targetSum, path), <span class="hljs-built_in">dfs</span>(root-&gt;right, targetSum, path);<br>        hash[path] --;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">https://leetcode.cn/problems/find-mode-in-binary-search-tree/</a></p>
</blockquote>
<ul>
<li>首先, 二叉搜索树的中序遍历一定是有序的, 那么重复元素在中序遍历序列中一定是连续出现了.</li>
<li>可以在中序遍历的过程中维护一些信息用来统计众数:
<ul>
<li><code>last</code>: 某一段连续的数, 这个数是什么.</li>
<li><code>curc</code>: 当前这个数出现的次数.</li>
<li><code>maxc</code>: 全局中, 出现次数最多的数, 它出现的次数到底是多少.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxc = <span class="hljs-number">0</span>, curc = <span class="hljs-number">0</span>, last;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span> (!curc || root-&gt;val == last) &#123;<br>            curc ++;<br>            last = root-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            curc = <span class="hljs-number">1</span>;<br>            last = root-&gt;val;<br>        &#125;<br>        <span class="hljs-comment">// 每次更新都需要维护maxc</span><br>        <span class="hljs-keyword">if</span> (curc &gt; maxc) &#123;<br>            maxc = curc;<br>            ans = &#123;last&#125;;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curc == maxc) ans.<span class="hljs-built_in">push_back</span>(last);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="出现次数最多的子树元素和"><a href="#出现次数最多的子树元素和" class="headerlink" title="出现次数最多的子树元素和"></a>出现次数最多的子树元素和</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/most-frequent-subtree-sum/">https://leetcode.cn/problems/most-frequent-subtree-sum/</a></p>
</blockquote>
<p>在求子树和的过程中, 用哈希表维护子树和的信息即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-type">int</span> maxc = <span class="hljs-number">0</span>;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findFrequentTreeSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> sum = root-&gt;val + <span class="hljs-built_in">dfs</span>(root-&gt;left) + <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        hash[sum] ++;<br>        <span class="hljs-keyword">if</span> (hash[sum] &gt; maxc) &#123;<br>            maxc = hash[sum];<br>            ans = &#123;sum&#125;;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hash[sum] == maxc) ans.<span class="hljs-built_in">push_back</span>(sum);<br><br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">https://leetcode.cn/problems/minimum-absolute-difference-in-bst/</a></p>
</blockquote>
<p>二叉搜索树的中序遍历是有序的, 因此, 最小绝对差只能在相邻的元素中取到, 只需要在中序遍历中维护一下相关信息即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = INT_MAX;<br>    <span class="hljs-type">bool</span> is_first = <span class="hljs-literal">true</span>;<br>    TreeNode * last;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br><br>        <span class="hljs-keyword">if</span> (is_first) is_first = <span class="hljs-literal">false</span>, last = root;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, root-&gt;val - last-&gt;val);<br>        &#125;<br>        last = root;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>一种同类题: 二叉搜索树转换为累加树, <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">https://leetcode.cn/problems/convert-bst-to-greater-tree/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br><br>        <span class="hljs-type">int</span> x = root-&gt;val;<br>        root-&gt;val += sum;<br>        sum += x;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="在二叉树中增加一行"><a href="#在二叉树中增加一行" class="headerlink" title="在二叉树中增加一行"></a>在二叉树中增加一行</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-one-row-to-tree/description/">https://leetcode.cn/problems/add-one-row-to-tree/description/</a></p>
</blockquote>
<p>涉及二叉树行的问题, 其实都可以用层序遍历解决.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">addOneRow</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        depth --;<br>        <span class="hljs-keyword">if</span> (!depth) &#123;<br>            <span class="hljs-keyword">auto</span> cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            cur-&gt;left = root;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            depth --;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (!depth) &#123;<br>                    <span class="hljs-keyword">auto</span> cur1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>                    <span class="hljs-keyword">auto</span> cur2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>                    cur1-&gt;left = t-&gt;left;<br>                    t-&gt;left = cur1;<br>                    cur2-&gt;right = t-&gt;right;<br>                    t-&gt;right = cur2;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!depth) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="寻找重复的子树"><a href="#寻找重复的子树" class="headerlink" title="寻找重复的子树"></a>寻找重复的子树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-duplicate-subtrees/description/">https://leetcode.cn/problems/find-duplicate-subtrees/description/</a></p>
</blockquote>
<p>这个题涉及二叉树中哈希一颗子树的方案, 可以采用如下的方案:</p>
<ul>
<li>对于每个子树, 用一个三元组来表示, 三元组的构成是: <code>(root-&gt;val, 左子树id, 右子树id)</code>.</li>
<li>左子树id和右子树id可以用一个全局的变量来分配.</li>
</ul>
<p>这个三元组可以变成一个字符串存储在哈希表中, 这个哈希表可以将字符串映射到一个唯一的<code>id</code>, 这个<code>id</code>可以映射到<code>id</code>出现的次数, 如果出现次数大于1, 证明出现了重复的子树.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;TreeNode *&gt; ans;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; ids;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br><br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">findDuplicateSubtrees</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">/* Return id */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-comment">// Use 0 to map NULL</span><br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left), right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        string key = <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">to_string</span>(left) + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">to_string</span>(right);<br><br>        <span class="hljs-keyword">if</span> (ids.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) ids[key] = ++cnt;<br>        <span class="hljs-type">int</span> id = ids[key];<br>        <span class="hljs-keyword">if</span> (++ hash[id] == <span class="hljs-number">2</span>) ans.<span class="hljs-built_in">push_back</span>(root);<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="两数之和-二叉搜索树"><a href="#两数之和-二叉搜索树" class="headerlink" title="两数之和-二叉搜索树"></a>两数之和-二叉搜索树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/">https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/</a></p>
</blockquote>
<p>直接采用哈希表做.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, k);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(root-&gt;left, k)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(k - root-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        hash.<span class="hljs-built_in">insert</span>(root-&gt;val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;right, k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/description/">https://leetcode.cn/problems/maximum-binary-tree/description/</a></p>
</blockquote>
<p>RMQ和二叉树结合的问题, 注意此时<code>f</code>数组中维护的不是最大值, 而是最大值的下标.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; f;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; _nums)</span> </span>&#123;<br>        nums = _nums;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-built_in">log</span>(n) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>        f = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;( k + <span class="hljs-number">1</span> ));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= k; j ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt; n; i ++) &#123;<br>                <span class="hljs-keyword">if</span> (!j) f[i][j] = i;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> l = f[i][j - <span class="hljs-number">1</span>], r = f[i + (<span class="hljs-number">1</span> &lt;&lt; j - <span class="hljs-number">1</span>)][j - <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (nums[l] &gt; nums[r]) f[i][j] = l;<br>                    <span class="hljs-keyword">else</span> f[i][j] = r;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-comment">// query</span><br>        <span class="hljs-type">int</span> k = <span class="hljs-built_in">log</span>(r - l + <span class="hljs-number">1</span>) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> a = f[l][k], b = f[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k];<br>        <span class="hljs-keyword">if</span> (nums[a] &gt; nums[b]) <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> b;<br>    &#125;<br>    <span class="hljs-function">TreeNode * <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-built_in">query</span>(l, r);<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[k]);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(l, k - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(k + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a>二叉树的最大宽度</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">https://leetcode.cn/problems/maximum-width-of-binary-tree/</a></p>
</blockquote>
<p>在二叉树中, 节点可以有编号, 这个编号类似于堆, 假设一个节点编号是<code>u</code>:</p>
<ul>
<li>左节点一般是<code>u * 2</code>, 右节点一般是<code>u * 2 + 1</code>.</li>
</ul>
<p>这个节点编号可以做很多事情, 这个题就是考察这个编号的用法.</p>
<p>但是, 如果二叉树节点一多, 编号每次都乘2, 那么很快就会爆<code>int</code>.</p>
<p>在这个题中, 只在意编号的相对关系, 因此可以让每层的编号强制从1开始.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>    LL ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// int stands for id for TreeNode</span><br>        queue&lt;pair&lt;TreeNode *, LL&gt;&gt; q;<br>        q.<span class="hljs-built_in">push</span>(&#123; root, <span class="hljs-number">1</span> &#125;);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            LL l = q.<span class="hljs-built_in">front</span>().second, r;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">auto</span> v = t.first;<br>                r = t.second;<br>                LL p = r - l + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (v-&gt;left) q.<span class="hljs-built_in">push</span>(&#123; v-&gt;left, p * <span class="hljs-number">2</span> &#125;);<br>                <span class="hljs-keyword">if</span> (v-&gt;right) q.<span class="hljs-built_in">push</span>(&#123; v-&gt;right, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &#125;);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="修建二叉搜索树"><a href="#修建二叉搜索树" class="headerlink" title="修建二叉搜索树"></a>修建二叉搜索树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">https://leetcode.cn/problems/trim-a-binary-search-tree/</a></p>
</blockquote>
<p>这个题有个规律, 如果一个节点要被删除了:</p>
<ul>
<li>如果节点小于low, 那么这个点连同左子树都要没, 直接把右子树提上来.</li>
<li>大于high的情况同理.</li>
<li>如果节点在区间范围, 只需要递归左右子树修剪即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树中第二小的节点"><a href="#二叉树中第二小的节点" class="headerlink" title="二叉树中第二小的节点"></a>二叉树中第二小的节点</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/description/">https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/description/</a></p>
</blockquote>
<p>直接遍历即可, 注意维护最小值和次小值的逻辑(<code>&lt;</code>和<code>&lt;=</code>).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>    LL d1, d2;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findSecondMinimumValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        d1 = d2 = <span class="hljs-number">1e18</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">if</span> (d2 == <span class="hljs-number">1e18</span>) d2 = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> d2;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-comment">// 注意这里一定是&lt;, 不是&lt;=</span><br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; d1) d2 = d1, d1 = root-&gt;val;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; d1 &amp;&amp; root-&gt;val &lt; d2) d2 = root-&gt;val;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left), <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="输出二叉树"><a href="#输出二叉树" class="headerlink" title="输出二叉树"></a>输出二叉树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/print-binary-tree/">https://leetcode.cn/problems/print-binary-tree/</a></p>
</blockquote>
<p><font color="red">注意: 🌲的高度和深度的定义不同:</font></p>
<ul>
<li>高度: 从根节点到叶子节点的<strong>边</strong>的数量.</li>
<li>深度: 从根节点到叶子节点经过的<strong>节点</strong>数量.</li>
</ul>
<p>满二叉树第<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-34-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-34-TEX-I-1D45B"/></g></g></g></svg>层的节点个数是<svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.176ex" height="1.714ex" role="img" focusable="false" viewbox="0 -675.5 2729.7 757.5" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-35-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-35-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-35-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/><path id="MJX-35-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-35-TEX-N-32"/></g><g data-mml-node="TeXAtom" transform="translate(533,363) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-35-TEX-I-1D45B"/></g></g></g><g data-mml-node="mo" transform="translate(1229.5,0)"><use data-c="2212" xlink:href="#MJX-35-TEX-N-2212"/></g><g data-mml-node="mn" transform="translate(2229.7,0)"><use data-c="31" xlink:href="#MJX-35-TEX-N-31"/></g></g></g></svg>​.</p>
<p>这个题直接递归打印即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>		<span class="hljs-comment">// 返回树的最大高度和最大宽度</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">dfs</span>(root-&gt;left), r = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-built_in">max</span>(l[<span class="hljs-number">0</span>], r[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>(l[<span class="hljs-number">1</span>], r[<span class="hljs-number">1</span>]) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        ans[h][mid] = <span class="hljs-built_in">to_string</span>(root-&gt;val);<br>        <span class="hljs-built_in">print</span>(root-&gt;left, h + <span class="hljs-number">1</span>, l, mid - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">print</span>(root-&gt;right, h + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">printTree</span>(TreeNode* root) &#123;<br>        <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-type">int</span> h = t[<span class="hljs-number">0</span>], w = t[<span class="hljs-number">1</span>];<br>        ans = vector&lt;vector&lt;string&gt;&gt;(h, <span class="hljs-built_in">vector</span>&lt;string&gt;(w));<br>        <span class="hljs-built_in">print</span>(root, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, w - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树剪枝"><a href="#二叉树剪枝" class="headerlink" title="二叉树剪枝"></a>二叉树剪枝</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-pruning/">https://leetcode.cn/problems/binary-tree-pruning/</a></p>
</blockquote>
<p>dfs直接遍历一遍就可以.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// root没有1, 那么就要删掉</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(root)) root = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">// 返回root所在子树是否包含1</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 删除左右子树</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(root-&gt;left)) root-&gt;left = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(root-&gt;right)) root-&gt;right = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> root-&gt;val || root-&gt;left || root-&gt;right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树中所有距离为k的点"><a href="#二叉树中所有距离为k的点" class="headerlink" title="二叉树中所有距离为k的点"></a>二叉树中所有距离为k的点</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/">https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/</a></p>
</blockquote>
<p>直接把二叉树变成一个无向图, 然后从target开始搜索即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;TreeNode *, vector&lt;TreeNode*&gt;&gt; g;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (root-&gt;left) &#123;<br>            g[root].<span class="hljs-built_in">push_back</span>(root-&gt;left);<br>            g[root-&gt;left].<span class="hljs-built_in">push_back</span>(root);<br>            <span class="hljs-built_in">dfs1</span>(root-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;right) &#123;<br>            g[root].<span class="hljs-built_in">push_back</span>(root-&gt;right);<br>            g[root-&gt;right].<span class="hljs-built_in">push_back</span>(root);<br>            <span class="hljs-built_in">dfs1</span>(root-&gt;right);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(TreeNode *u, TreeNode *father, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!u) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (!k) ans.<span class="hljs-built_in">push_back</span>(u-&gt;val);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> son : g[u]) &#123;<br>            <span class="hljs-keyword">if</span> (son != father) &#123;<br>                <span class="hljs-built_in">dfs2</span>(son, u, k - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distanceK</span><span class="hljs-params">(TreeNode* root, TreeNode* target, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs1</span>(root);<br>        <span class="hljs-built_in">dfs2</span>(target, <span class="hljs-literal">NULL</span>, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="最深节点的最小子树"><a href="#最深节点的最小子树" class="headerlink" title="最深节点的最小子树"></a>最深节点的最小子树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/">https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/</a></p>
</blockquote>
<p>递归需要考虑两个问题:</p>
<ul>
<li>我需要维护什么信息.</li>
<li>知道左子树/右子树的信息, 如何求出根的信息.</li>
</ul>
<p>这个题中, 我需要维护一个节点所在子树, 最深的节点的深度, 以及这个点最小子树的树根, 假设叫h:</p>
<ul>
<li>如果<code>left.h == right.h</code>, 那么根节点就是答案.</li>
<li>如果<code>left.h &gt; right.h</code>, 那么最深的点在左子树.</li>
<li>如果<code>left.h &lt; right.h</code>, 那么最深的点在右子树.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">dfs</span>(root-&gt;left), r = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (l.second == r.second) <span class="hljs-keyword">return</span> &#123; root, l.second + <span class="hljs-number">1</span> &#125;;<br>        <span class="hljs-keyword">if</span> (l.second &gt; r.second) <span class="hljs-keyword">return</span> &#123; l.first, l.second + <span class="hljs-number">1</span> &#125;;<br>        <span class="hljs-keyword">return</span> &#123; r.first, r.second + <span class="hljs-number">1</span> &#125;;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">subtreeWithAllDeepest</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root).first;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="所有可能的真二叉树"><a href="#所有可能的真二叉树" class="headerlink" title="所有可能的真二叉树"></a>所有可能的真二叉树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-possible-full-binary-trees/">https://leetcode.cn/problems/all-possible-full-binary-trees/</a></p>
</blockquote>
<p>首先, 对于这种二叉树, 节点的个数必须是奇数, 因为边数肯定是偶数.</p>
<p>然后, 对于可能的解, 可以分为如下几类:</p>
<ul>
<li>左子树1个节点, 右子树n - 2个.</li>
<li>左子树3个节点, 右子树n - 4个.</li>
<li>...</li>
<li>左子树n - 2个, 右子树1个.</li>
</ul>
<p>每次递归左右子树后, 按照乘法原理, 从左右子树中任选一种方案都是合法方案.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">allPossibleFBT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <br>        vector&lt;TreeNode *&gt; ans;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>));<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i += <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">allPossibleFBT</span>(i);<br>            <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">allPossibleFBT</span>(n - <span class="hljs-number">1</span> - i);<br><br>            <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> l : left)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> r: right)<br>                    ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>, l, r));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="完全二叉树插入器"><a href="#完全二叉树插入器" class="headerlink" title="完全二叉树插入器"></a>完全二叉树插入器</h2>
<p>这个题考查的是完全二叉树的堆存储方式.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CBTInserter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* R;<br>    <span class="hljs-comment">// 堆的存储方式</span><br>    vector&lt;TreeNode *&gt; h;<br>    <span class="hljs-built_in">CBTInserter</span>(TreeNode* root) &#123;<br>      <span class="hljs-comment">// 完全二叉树堆存储, 下标从1开始</span><br>        h.<span class="hljs-built_in">resize</span>(<span class="hljs-number">1</span>);<br>        R = root;<br>        <span class="hljs-comment">// 宽搜, 放到堆里</span><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            h.<span class="hljs-built_in">push_back</span>(t);<br>            <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>            <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        h.<span class="hljs-built_in">push_back</span>(t);<br>        <span class="hljs-type">int</span> k = h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> p = k / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (p * <span class="hljs-number">2</span> == k) h[p]-&gt;left = t;<br>        <span class="hljs-keyword">else</span> h[p]-&gt;right = t;<br>        <span class="hljs-keyword">return</span> h[p]-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">get_root</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> R;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="判断是否是完全二叉树"><a href="#判断是否是完全二叉树" class="headerlink" title="判断是否是完全二叉树"></a>判断是否是完全二叉树</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">https://leetcode.cn/problems/check-completeness-of-a-binary-tree/</a></p>
</blockquote>
<p>同样考察完全二叉树的堆式存储.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// n用来记录遍历了多少点, p用来记录下标的最大值</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, p = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 节点数目最多100, 如果超过了就直接返回false, 避免x2溢出</span><br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">100</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        n ++;<br>        p = <span class="hljs-built_in">max</span>(p, k);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, k * <span class="hljs-number">2</span>) &amp;&amp; <span class="hljs-built_in">dfs</span>(root-&gt;right, k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果遍历的点正好等于p, 那么就是完全二叉树</span><br>        <span class="hljs-keyword">return</span> n == p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="二叉树的堂兄弟节点"><a href="#二叉树的堂兄弟节点" class="headerlink" title="二叉树的堂兄弟节点"></a>二叉树的堂兄弟节点</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cousins-in-binary-tree/">https://leetcode.cn/problems/cousins-in-binary-tree/</a></p>
</blockquote>
<p>在搜索的时候记录一下父亲节点和深度信息即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">if</span> (root-&gt;val == x) <span class="hljs-keyword">return</span> &#123; fa, depth &#125;;<br><br>        <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">dfs</span>(root-&gt;left, x, root-&gt;val, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">dfs</span>(root-&gt;right, x, root-&gt;val, depth + <span class="hljs-number">1</span>);<br>				<span class="hljs-comment">// 这里, l和r只会有一边有值, 另一边会返回&#123;0, 0&#125;, trick</span><br>        <span class="hljs-keyword">return</span> &#123; l[<span class="hljs-number">0</span>] + r[<span class="hljs-number">0</span>], l[<span class="hljs-number">1</span>] + r[<span class="hljs-number">1</span>] &#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCousins</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">dfs</span>(root, x, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">dfs</span>(root, y, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>] &amp;&amp; a[<span class="hljs-number">1</span>] == b[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="翻转二叉树以匹配先序遍历"><a href="#翻转二叉树以匹配先序遍历" class="headerlink" title="翻转二叉树以匹配先序遍历"></a>翻转二叉树以匹配先序遍历</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/description/">https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/description/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;voyage, <span class="hljs-type">int</span> &amp;k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 如果根节点的值不等于voyage当前元素, 直接返回</span><br>        <span class="hljs-keyword">if</span> (root-&gt;val != voyage[k]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 跳过根节点</span><br>        k ++;<br>        <span class="hljs-comment">// 如果左子树根节点不等于当前前序遍历第一个元素, 则需要反转</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;left-&gt;val != voyage[k]) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            <span class="hljs-comment">// 先遍历右子树, 然后遍历左子树, 代表反转</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;right, voyage, k) &amp;&amp; <span class="hljs-built_in">dfs</span>(root-&gt;left, voyage, k);<br>        &#125;<br>        <span class="hljs-comment">// 如果不需要反转</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, voyage, k) &amp;&amp; <span class="hljs-built_in">dfs</span>(root-&gt;right, voyage, k);<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">flipMatchVoyage</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; voyage)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(root, voyage, k)) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="在二叉树中分配硬币"><a href="#在二叉树中分配硬币" class="headerlink" title="在二叉树中分配硬币"></a>在二叉树中分配硬币</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/">https://leetcode.cn/problems/distribute-coins-in-binary-tree/</a></p>
</blockquote>
<p>考虑一颗子树, 和它上面的一条边.</p>
<p>如果在这颗子树中:</p>
<ul>
<li>节点总数<code>x</code>比金币总数<code>y</code>多, 那么就会有<code>x - y</code>个硬币从这条边经过.</li>
<li>同理, 如果金币数多, 那么就有<code>y - x</code>个硬币经过.</li>
</ul>
<p>因此, 只需要遍历所有的边, 计算每一条边的贡献即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-comment">// 节点数, 边数, 操作数</span><br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">dfs</span>(root-&gt;left), r = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br><br>        <span class="hljs-type">int</span> x = l[<span class="hljs-number">0</span>] + r[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> y = l[<span class="hljs-number">1</span>] + r[<span class="hljs-number">1</span>] + root-&gt;val;<br>        <span class="hljs-keyword">return</span> &#123; x, y, <span class="hljs-built_in">abs</span>(x - y) + l[<span class="hljs-number">2</span>] + r[<span class="hljs-number">2</span>] &#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">distributeCoins</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root)[<span class="hljs-number">2</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="从叶节点开始的最小字符串"><a href="#从叶节点开始的最小字符串" class="headerlink" title="从叶节点开始的最小字符串"></a>从叶节点开始的最小字符串</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-string-starting-from-leaf/">https://leetcode.cn/problems/smallest-string-starting-from-leaf/</a></p>
</blockquote>
<p>直接爆搜 每一个字符串即可, 时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-36-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-36-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-36-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-36-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-36-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-36-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-36-TEX-N-28"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-36-TEX-I-1D45B"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><use data-c="32" xlink:href="#MJX-36-TEX-N-32"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><use data-c="29" xlink:href="#MJX-36-TEX-N-29"/></g></g></g></svg>, 数据范围是8500, 勉强能过.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string ans, path;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        path += root-&gt;val + <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">empty</span>() || ans &gt; path) ans = path;<br>            <span class="hljs-comment">// 恢复现场</span><br>            <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>            <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        &#125;<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">smallestFromLeaf</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

      
       <hr><span style="font-style: italic;color: gray;"> 向阳而生, 喜欢聪明的人. </span>
    </div>
</article>







    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>

    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©B1ueDrops
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
