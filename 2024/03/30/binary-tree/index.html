<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>二叉树/二叉搜索树全系列 | B1ueDrops</title>
  <meta name="keywords" content="">
  <meta name="description" content="二叉树/二叉搜索树全系列 | B1ueDrops">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Movies: series or entertaining?The world’s  movie industry has witnessed unprecedented boom in recent years. Delighted with an ample supply of excellent motion pictures, global audiences are thankful">
<meta property="og:type" content="article">
<meta property="og:title" content="英语写作背诵文章">
<meta property="og:url" content="https://b1uedrops.github.io/2024/05/09/english-writing/index.html">
<meta property="og:site_name" content="B1ueDrops">
<meta property="og:description" content="Movies: series or entertaining?The world’s  movie industry has witnessed unprecedented boom in recent years. Delighted with an ample supply of excellent motion pictures, global audiences are thankful">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-09T13:11:19.328Z">
<meta property="article:modified_time" content="2024-05-09T13:15:07.644Z">
<meta property="article:author" content="B1ueDrops">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpeg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpeg"/>
</a>
<div class="author">
    <span>B1ueDrops</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/B1ueDrops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:bluedrops@yeah.net"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2381446488&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(51)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="编程语言">
            
            编程语言
            <small>(7)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="并发编程">
            
            并发编程
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="工具/环境">
            
            工具/环境
            <small>(7)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="计算机网络">
            
            计算机网络
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="金融知识">
            
            金融知识
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="脑机接口">
            
            脑机接口
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="软件工程">
            
            软件工程
            <small>(6)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="社会技能">
            
            社会技能
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(10)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="体系结构">
            
            体系结构
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="信号处理">
            
            信号处理
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="AI">
            
            AI
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="English">
            
            English
            <small>(6)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="51">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All English "
           href="/2024/05/09/english-writing/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语写作背诵文章">英语写作背诵文章</span>
            <span class="post-date" title="2024-05-09 21:11:19">2024/05/09</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/09/practical-go/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Go语言原理与实战记录">Go语言原理与实战记录</span>
            <span class="post-date" title="2024-05-09 20:48:25">2024/05/09</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/05/09/database-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据库-PostgreSQL环境配置与SQL语句">数据库-PostgreSQL环境配置与SQL语句</span>
            <span class="post-date" title="2024-05-09 20:24:37">2024/05/09</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/05/09/cache-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cache的基础知识与设计策略">Cache的基础知识与设计策略</span>
            <span class="post-date" title="2024-05-09 20:12:19">2024/05/09</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/05/09/sort-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基础排序算法和应用">基础排序算法和应用</span>
            <span class="post-date" title="2024-05-09 17:10:04">2024/05/09</span>
        </a>
        
        
        <a  class="All 社会技能 "
           href="/2024/04/26/secure_drive/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="安全驾驶知识">安全驾驶知识</span>
            <span class="post-date" title="2024-04-26 19:53:53">2024/04/26</span>
        </a>
        
        
        <a  class="All 金融知识 "
           href="/2024/04/26/quant/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基金及量化投资">基金及量化投资</span>
            <span class="post-date" title="2024-04-26 13:42:05">2024/04/26</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2024/04/21/network_tcp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="TCP的相关知识">TCP的相关知识</span>
            <span class="post-date" title="2024-04-21 15:16:42">2024/04/21</span>
        </a>
        
        
        <a  class="All 信号处理 "
           href="/2024/04/20/fourier/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="傅立叶级数分解">傅立叶级数分解</span>
            <span class="post-date" title="2024-04-20 18:36:34">2024/04/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/04/14/two_pointer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="双指针系列">双指针系列</span>
            <span class="post-date" title="2024-04-14 19:46:01">2024/04/14</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/13/practical-rust/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust原理与实战记录">Rust原理与实战记录</span>
            <span class="post-date" title="2024-04-13 17:05:26">2024/04/13</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/04/13/ai_basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AI的一些基础概念">AI的一些基础概念</span>
            <span class="post-date" title="2024-04-13 16:43:26">2024/04/13</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/04/13/transformer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="简单理解Transformer">简单理解Transformer</span>
            <span class="post-date" title="2024-04-13 12:36:45">2024/04/13</span>
        </a>
        
        
        <a  class="All 并发编程 "
           href="/2024/04/12/rust_async/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust的异步编程">Rust的异步编程</span>
            <span class="post-date" title="2024-04-12 14:09:37">2024/04/12</span>
        </a>
        
        
        <a  class="All 计算机网络 "
           href="/2024/04/08/network_http/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="应用层-HTTP协议">应用层-HTTP协议</span>
            <span class="post-date" title="2024-04-08 19:44:40">2024/04/08</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/07/python_many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python用到什么学什么">Python用到什么学什么</span>
            <span class="post-date" title="2024-04-07 10:46:59">2024/04/07</span>
        </a>
        
        
        <a  class="All 脑机接口 "
           href="/2024/04/06/eeg_device/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="脑电的原理">脑电的原理</span>
            <span class="post-date" title="2024-04-06 10:35:04">2024/04/06</span>
        </a>
        
        
        <a  class="All 社会技能 "
           href="/2024/04/05/eq/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="培养高情商的一些策略">培养高情商的一些策略</span>
            <span class="post-date" title="2024-04-05 10:25:28">2024/04/05</span>
        </a>
        
        
        <a  class="All 并发编程 "
           href="/2024/04/04/rust_multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust多线程编程模型">Rust多线程编程模型</span>
            <span class="post-date" title="2024-04-04 12:38:50">2024/04/04</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/02/rust_leetcode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="用Rust实现Leetcode算法题">用Rust实现Leetcode算法题</span>
            <span class="post-date" title="2024-04-02 12:59:13">2024/04/02</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/01/rust_system/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust基础系统总结">Rust基础系统总结</span>
            <span class="post-date" title="2024-04-01 19:24:52">2024/04/01</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/30/binary-tree/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二叉树/二叉搜索树全系列">二叉树/二叉搜索树全系列</span>
            <span class="post-date" title="2024-03-30 17:07:34">2024/03/30</span>
        </a>
        
        
        <a  class="All 并发编程 "
           href="/2024/03/30/multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多进程/多线程编程模型">多进程/多线程编程模型</span>
            <span class="post-date" title="2024-03-30 16:47:20">2024/03/30</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/30/profile/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="软件的性能分析">软件的性能分析</span>
            <span class="post-date" title="2024-03-30 13:49:01">2024/03/30</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/28/linkedlist/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="链表系列">链表系列</span>
            <span class="post-date" title="2024-03-28 09:53:10">2024/03/28</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/24/data-struct/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构系列">数据结构系列</span>
            <span class="post-date" title="2024-03-24 14:10:22">2024/03/24</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/23/vscode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="vscode插件配置">vscode插件配置</span>
            <span class="post-date" title="2024-03-23 15:50:58">2024/03/23</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/command_line/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shell脚本现用现学">Shell脚本现用现学</span>
            <span class="post-date" title="2024-03-22 12:50:32">2024/03/22</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/cpp-many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++之用到什么学什么">C++之用到什么学什么</span>
            <span class="post-date" title="2024-03-22 11:31:11">2024/03/22</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/21/prefix-sum-sub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前缀和差分系列">前缀和差分系列</span>
            <span class="post-date" title="2024-03-21 15:44:29">2024/03/21</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/linear-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性动态规划系列">线性动态规划系列</span>
            <span class="post-date" title="2024-03-20 18:11:22">2024/03/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/tree-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="树形动态规划系列">树形动态规划系列</span>
            <span class="post-date" title="2024-03-20 18:10:56">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-method/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Methodology">英语科技论文写作模型-Methodology</span>
            <span class="post-date" title="2024-03-20 16:53:17">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-abstract/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Abstract">英语科技论文写作模型-Abstract</span>
            <span class="post-date" title="2024-03-20 16:49:54">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-conclusion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Conclusion">英语科技论文写作模型-Conclusion</span>
            <span class="post-date" title="2024-03-20 16:49:46">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-results/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Results">英语科技论文写作模型-Results</span>
            <span class="post-date" title="2024-03-20 16:49:31">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/19/sci-writing-introduction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Introduction">英语科技论文写作模型-Introduction</span>
            <span class="post-date" title="2024-03-19 10:16:07">2024/03/19</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/03/10/ai-cnn/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CNN的一些基础知识">CNN的一些基础知识</span>
            <span class="post-date" title="2024-03-10 15:57:42">2024/03/10</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/10/catalan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡特兰数系列">卡特兰数系列</span>
            <span class="post-date" title="2024-03-10 12:47:19">2024/03/10</span>
        </a>
        
        
        <a  class="All 并发编程 "
           href="/2024/03/05/concurrent_sketch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="并发编程的概述">并发编程的概述</span>
            <span class="post-date" title="2024-03-05 15:00:50">2024/03/05</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/03/knapsack/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="背包问题的模板总结">背包问题的模板总结</span>
            <span class="post-date" title="2024-03-03 16:22:21">2024/03/03</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/02/jetbrains/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jetbrains系列IDE的配置">Jetbrains系列IDE的配置</span>
            <span class="post-date" title="2024-03-02 19:00:15">2024/03/02</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/02/tmux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tmux键位配置">tmux键位配置</span>
            <span class="post-date" title="2024-03-02 13:16:32">2024/03/02</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/01/clean_code/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码整洁之道">代码整洁之道</span>
            <span class="post-date" title="2024-03-01 14:30:08">2024/03/01</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/01/software_rule/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面向对象设计的基本原则">面向对象设计的基本原则</span>
            <span class="post-date" title="2024-03-01 14:30:02">2024/03/01</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/29/lazygit/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="lazygit的一些常见用法">lazygit的一些常见用法</span>
            <span class="post-date" title="2024-02-29 17:44:04">2024/02/29</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/28/yabai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="yabai窗口管理器键位配置">yabai窗口管理器键位配置</span>
            <span class="post-date" title="2024-02-28 13:01:35">2024/02/28</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/27/joshuto/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="joshuto的键位配置">joshuto的键位配置</span>
            <span class="post-date" title="2024-02-27 19:43:49">2024/02/27</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/02/26/behaviour_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="行为型的设计模式">行为型的设计模式</span>
            <span class="post-date" title="2024-02-26 20:11:27">2024/02/26</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/26/vimium/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Chrome中vimium键位">Chrome中vimium键位</span>
            <span class="post-date" title="2024-02-26 20:03:26">2024/02/26</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/02/25/build_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创建型的设计模式">创建型的设计模式</span>
            <span class="post-date" title="2024-02-25 15:27:36">2024/02/25</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-binary-tree" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">二叉树/二叉搜索树全系列</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="算法">算法</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-05-09 20:08:35'>2024-03-30 17:07</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">中序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95"><span class="toc-text">递归写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95"><span class="toc-text">迭代写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">前序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95-1"><span class="toc-text">递归写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95-1"><span class="toc-text">迭代写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">后序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%86%99%E6%B3%95-2"><span class="toc-text">递归写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95-2"><span class="toc-text">迭代写法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%8B%E5%AD%97%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">之字形层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E4%B8%AD%E5%BA%8F%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">前序中序恢复二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E4%B8%AD%E5%BA%8F%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">后序中序恢复二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E5%90%8E%E5%BA%8F%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">前序后序恢复二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-text">二叉树中序遍历的下一个节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C"><span class="toc-text">二叉搜索树的搜索操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-text">二叉搜索树的插入操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">二叉搜索树的删除操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">二叉搜索树的后序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E6%98%AF%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">二叉树中和是某一值的路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-text">树的子结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="toc-text">二叉树的镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="toc-text">二叉树的最大深度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">对称的二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">合并二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-text">二叉树的所有路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B1%82%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-text">完全二叉树求节点个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%B1%82%E6%95%B0%E7%9B%AE"><span class="toc-text">不同的二叉搜索树求数目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%B1%82%E6%96%B9%E6%A1%88"><span class="toc-text">不同的二叉搜索树求方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">验证二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">恢复二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Morris%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">Morris中序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E5%8F%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">有序数组变二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%8F%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">有序链表变二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-text">二叉树展开为链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9"><span class="toc-text">填充每个节点的下一个右侧节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84LCA"><span class="toc-text">二叉搜索树的LCA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84LCA"><span class="toc-text">二叉树的LCA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">验证二叉树前序序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">二叉树的序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">二叉搜索树的序列化和反序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%AD%90%E5%8F%B6%E4%B9%8B%E5%92%8C"><span class="toc-text">左子叶之和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-text">二叉树的最大路径和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="toc-text">找树左下角的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII"><span class="toc-text">路径总和III</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="toc-text">二叉搜索树中的众数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C"><span class="toc-text">出现次数最多的子树元素和</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="toc-text">二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C"><span class="toc-text">在二叉树中增加一行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-text">寻找重复的子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">两数之和-二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">最大二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6"><span class="toc-text">二叉树的最大宽度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">修建二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-text">二叉树中第二小的节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">输出二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D"><span class="toc-text">二叉树剪枝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BAk%E7%9A%84%E7%82%B9"><span class="toc-text">二叉树中所有距离为k的点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E6%B7%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91"><span class="toc-text">最深节点的最小子树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E7%9C%9F%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">所有可能的真二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8"><span class="toc-text">完全二叉树插入器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">判断是否是完全二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9"><span class="toc-text">二叉树的堂兄弟节点</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p>
</blockquote>
<p>中序遍历是左, 中, 右.</p>
<h3 id="递归写法"><a href="#递归写法" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题: 二叉搜索树的第k小元素: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">https://leetcode.cn/problems/kth-smallest-element-in-a-bst/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> k, ans;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> _k)</span> </span>&#123;<br>        k = _k;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(root-&gt;left)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (-- k == <span class="hljs-number">0</span>) &#123;<br>            ans = root-&gt;val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>简单的递归应用 (二叉搜索树的范围和): <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-of-bst/">https://leetcode.cn/problems/range-sum-of-bst/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSumBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-built_in">rangeSumBST</span>(root-&gt;left, low, high);<br>        sum += <span class="hljs-built_in">rangeSumBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt;= low &amp;&amp; root-&gt;val &lt;= high) sum += root-&gt;val;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="迭代写法"><a href="#迭代写法" class="headerlink" title="迭代写法"></a>迭代写法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode*&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) <br>        &#123;<br>            <span class="hljs-keyword">while</span> (root)<br>            &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题(二叉树中序遍历迭代器): <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search-tree-iterator/">https://leetcode.cn/problems/binary-search-tree-iterator/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BSTIterator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;TreeNode *&gt; stk;<br><br>    <span class="hljs-built_in">BSTIterator</span>(TreeNode* root) &#123;<br>        <span class="hljs-keyword">while</span> (root) &#123;<br>            stk.<span class="hljs-built_in">push</span>(root);<br>            root = root-&gt;left;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> root = stk.<span class="hljs-built_in">top</span>();<br>        stk.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> val = root-&gt;val;<br>        root = root-&gt;right;<br>        <span class="hljs-keyword">while</span> (root) &#123;<br>            stk.<span class="hljs-built_in">push</span>(root);<br>            root = root-&gt;left;<br>        &#125;<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p>
</blockquote>
<p>前序遍历是根, 左, 右.</p>
<h3 id="递归写法-1"><a href="#递归写法-1" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="迭代写法-1"><a href="#迭代写法-1" class="headerlink" title="迭代写法"></a>迭代写法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span> (root)<br>            &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br><br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<p>同类题(根据二叉树创建字符串): <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-string-from-binary-tree/">https://leetcode.cn/problems/construct-string-from-binary-tree/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string ans = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-function">string <span class="hljs-title">tree2str</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            ans += <span class="hljs-string">&quot;()&quot;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        ans += <span class="hljs-built_in">to_string</span>(root-&gt;val);<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; root-&gt;right) &#123;<br>            ans += <span class="hljs-string">&quot;()&quot;</span>;<br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>            ans += <span class="hljs-string">&quot;(&quot;</span>;<br>            <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>            ans += <span class="hljs-string">&quot;)&quot;</span>;<br>        &#125;<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题: 叶子相似的树, <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/leaf-similar-trees/description/">https://leetcode.cn/problems/leaf-similar-trees/description/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;a)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) a.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, a), <span class="hljs-built_in">dfs</span>(root-&gt;right, a);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">leafSimilar</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; a, b;<br>        <span class="hljs-built_in">dfs</span>(root1, a);<br>        <span class="hljs-built_in">dfs</span>(root2, b);<br>        <span class="hljs-keyword">return</span> a == b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">https://leetcode.cn/problems/binary-tree-postorder-traversal/</a></p>
</blockquote>
<p>后序遍历是左, 右, 根.</p>
<h3 id="递归写法-2"><a href="#递归写法-2" class="headerlink" title="递归写法"></a>递归写法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="迭代写法-2"><a href="#迭代写法-2" class="headerlink" title="迭代写法"></a>迭代写法</h3><p> 先按照根右左的顺序遍历, 然后反向即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;right;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            root = root-&gt;left;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal">https://leetcode.cn/problems/binary-tree-level-order-traversal</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/41/">https://www.acwing.com/problem/content/description/41/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/42/">https://www.acwing.com/problem/content/42/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>						<br>          <span class="hljs-comment">/* 每一层单独放 */</span><br>            <span class="hljs-keyword">while</span> (len --) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题(二叉树的右视图): <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">https://leetcode.cn/problems/binary-tree-right-side-view/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-comment">// 注意层序遍历不要忘记判断空节点</span><br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br>        queue&lt;TreeNode *&gt; q;<br><br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>                <span class="hljs-keyword">if</span> (i == len - <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<h2 id="之字形层序遍历"><a href="#之字形层序遍历" class="headerlink" title="之字形层序遍历"></a>之字形层序遍历</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/43/">https://www.acwing.com/problem/content/description/43/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/">https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/</a></p>
</blockquote>
<p>在层序遍历的基础上用一个变量控制一下是否反转<code>level</code>即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">printFromTopToBottom</span>(TreeNode* root) &#123;<br>        <br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br>        <br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <br>        <span class="hljs-type">bool</span> rev = <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <br>            <span class="hljs-keyword">while</span> (len --)<br>            &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (rev) <span class="hljs-built_in">reverse</span>(level.<span class="hljs-built_in">begin</span>(), level.<span class="hljs-built_in">end</span>());<br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>            rev = !rev;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<h2 id="前序中序恢复二叉树"><a href="#前序中序恢复二叉树" class="headerlink" title="前序中序恢复二叉树"></a>前序中序恢复二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
</blockquote>
<p>首先, 前序遍历序列的第一个元素就是根节点, 通过哈希表可以找到第一个元素在中序遍历中的位置, 假设根节点在中序遍历中的下标是$k$.</p>
<p>假设前序遍历的下标范围是$[pl, pr]$, 中序遍历的下标范围是$[il, ir]$, 那么:</p>
<ul>
<li>左子树在前序遍历的下标范围是$[pl + 1, pl + 1 + (k - 1 - il + 1) - 1]$</li>
<li>右子树在前序遍历的下标范围是$[pl + 1 +  (k - il + 1) - 1 + 1, pr]$</li>
<li>左子树在中序遍历的下标范围是$[il, k - 1]$</li>
<li>右子树在中序遍历的下标范围是$[k + 1, ir]$</li>
</ul>
<p>然后递归建树即可, 时间复杂度是$O(n)$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;preorder, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inorder, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pl &gt; pr) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> val = preorder[pl];<br>        <span class="hljs-type">int</span> k = hash[val];<br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br><br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(preorder, inorder, pl + <span class="hljs-number">1</span>, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il, il, k - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(preorder, inorder, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il + <span class="hljs-number">1</span>, pr, k + <span class="hljs-number">1</span>, ir);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) hash[inorder[i]] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>注意, 只有前序和后序不能唯一确定一个二叉树 </p>
<h2 id="后序中序恢复二叉树"><a href="#后序中序恢复二叉树" class="headerlink" title="后序中序恢复二叉树"></a>后序中序恢复二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description">https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description</a></p>
</blockquote>
<p>分析思路和上一题相同.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;inorder, vector&lt;<span class="hljs-type">int</span>&gt; &amp;postorder, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (pl &gt; pr) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> val = postorder[pr];<br>        <span class="hljs-type">int</span> k = hash[val];<br><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br><br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(inorder, postorder, il, k - <span class="hljs-number">1</span>, pl, pl + k - <span class="hljs-number">1</span> - il);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(inorder, postorder, k + <span class="hljs-number">1</span>, ir, pl + k - <span class="hljs-number">1</span> - il + <span class="hljs-number">1</span>, pr - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) hash[inorder[i]] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(inorder, postorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>); <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="前序后序恢复二叉树"><a href="#前序后序恢复二叉树" class="headerlink" title="前序后序恢复二叉树"></a>前序后序恢复二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/</a></p>
</blockquote>
<blockquote>
<p>为什么根据前序遍历和后序遍历无法恢复二叉树?</p>
</blockquote>
<p>假设我有一个节点, 它的左子树&#x2F;右子树不存在, 但是在前序&#x2F;后序遍历中, 都无法反映这个子树不存在的信息, 因此如果你从前序&#x2F;后序遍历中发现一个子树不存在, 它既可以是左子树不存在, 也可以是右子树不存在, 选一个就可以.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;preorder, vector&lt;<span class="hljs-type">int</span>&gt; &amp;postorder, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (a &gt; b) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[a]);<br>        <span class="hljs-keyword">if</span> (a == b) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">// 左根在后序遍历中的位置</span><br>        <span class="hljs-type">int</span> k = hash[preorder[a + <span class="hljs-number">1</span>]];<br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(preorder, postorder, a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + (k - x + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>, x, k);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(preorder, postorder, a + <span class="hljs-number">1</span> + (k - x + <span class="hljs-number">1</span>), b, k + <span class="hljs-number">1</span>, y - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructFromPrePost</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; postorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = postorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) hash[postorder[i]] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preorder, postorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树中序遍历的下一个节点"><a href="#二叉树中序遍历的下一个节点" class="headerlink" title="二叉树中序遍历的下一个节点"></a>二叉树中序遍历的下一个节点</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/31/">https://www.acwing.com/problem/content/description/31/</a></p>
</blockquote>
<p>分两种情况:</p>
<ul>
<li>第一: 如果给定节点有右子树, 那么下一个节点就是右子树最左边的节点, 对应左根右的右这一部分.</li>
<li>第二: 如果给定节点没有右子树, 那么它需要向上, 找到节点$p$, 使得$p.father.left &#x3D; p$, 那么$p.father$就是下一个节点, 对应左根右的根这一部分.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">inorderSuccessor</span><span class="hljs-params">(TreeNode* p)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;right) &#123;<br>            p = p-&gt;right;<br>            <span class="hljs-keyword">while</span> (p-&gt;left) p = p-&gt;left;<br>            <span class="hljs-keyword">return</span> p;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (p-&gt;father &amp;&amp; p-&gt;father-&gt;right == p) p = p-&gt;father;<br>            <span class="hljs-keyword">return</span> p-&gt;father;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉搜索树的搜索操作"><a href="#二叉搜索树的搜索操作" class="headerlink" title="二叉搜索树的搜索操作"></a>二叉搜索树的搜索操作</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">https://leetcode.cn/problems/search-in-a-binary-search-tree/</a></p>
</blockquote>
<p>迭代写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">while</span> (root) &#123;<br>            <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) root = root-&gt;left;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val &gt; root-&gt;val) root = root-&gt;right;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>递归写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (val == root-&gt;val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;right, val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉搜索树的插入操作"><a href="#二叉搜索树的插入操作" class="headerlink" title="二叉搜索树的插入操作"></a>二叉搜索树的插入操作</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">https://leetcode.cn/problems/insert-into-a-binary-search-tree/</a></p>
</blockquote>
<p>递归写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        <span class="hljs-keyword">if</span> (val &lt; root-&gt;val) root-&gt;left = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;left, val);<br>        <span class="hljs-keyword">else</span> root-&gt;right = <span class="hljs-built_in">insertIntoBST</span>(root-&gt;right, val);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉搜索树的删除操作"><a href="#二叉搜索树的删除操作" class="headerlink" title="二叉搜索树的删除操作"></a>二叉搜索树的删除操作</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">https://leetcode.cn/problems/delete-node-in-a-bst/</a></p>
</blockquote>
<p>二叉搜索树的删除分为如下三种情况:</p>
<ul>
<li>如果要删除的节点是叶子节点, 那么直接把这个节点变成null就行.</li>
<li>如果要删除的节点只有左子树&#x2F;右子树, 那么直接把左子树&#x2F;右子树提上来就行.</li>
<li>如果要删除的节点左子树和右子树都有, 那么就找后继节点, 让后继节点覆盖当前节点, 然后再从右子树中递归删除后继节点.<ul>
<li>注意, 由于后继节点没有左子树, 如果递归的话, 那么就是第一种&#x2F;第二种情况.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-built_in">del</span>(root, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (key &lt; root-&gt;val) &#123;<br>            <span class="hljs-built_in">del</span>(root-&gt;left, key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (key &gt; root-&gt;val) &#123;<br>            <span class="hljs-built_in">del</span>(root-&gt;right, key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) root = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root-&gt;left) root = root-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root-&gt;right) root = root-&gt;left;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> next = root-&gt;right;<br>            <span class="hljs-keyword">while</span> (next-&gt;left) next = next-&gt;left;<br>            root-&gt;val = next-&gt;val;<br>            <span class="hljs-built_in">del</span>(root-&gt;right, next-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<h2 id="二叉搜索树的后序遍历"><a href="#二叉搜索树的后序遍历" class="headerlink" title="二叉搜索树的后序遍历"></a>二叉搜索树的后序遍历</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/44/">https://www.acwing.com/problem/content/44/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">verifySequenceOfBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; sequence)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = sequence.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, sequence);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;<span class="hljs-type">int</span>&gt; &amp;sequence)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-type">int</span> index = l, root = sequence[r];<br>        <br>        <span class="hljs-keyword">while</span> (index &lt; r &amp;&amp; sequence[index] &lt; root) index ++;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = index; i &lt; r; i ++)<br>            <span class="hljs-keyword">if</span> (sequence[i] &lt; root)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(l, index - <span class="hljs-number">1</span>, sequence) &amp;&amp; <span class="hljs-built_in">dfs</span>(index, r - <span class="hljs-number">1</span>, sequence);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树中和是某一值的路径"><a href="#二叉树中和是某一值的路径" class="headerlink" title="二叉树中和是某一值的路径"></a>二叉树中和是某一值的路径</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/45/">https://www.acwing.com/problem/content/description/45/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii">https://leetcode.cn/problems/path-sum-ii</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findPath</span>(TreeNode* root, <span class="hljs-type">int</span> sum) &#123;<br>        <br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">dfs</span>(root, sum);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> sum)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <br>        path.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        sum -= root-&gt;val;<br>        <br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !sum)<br>        &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            sum += root-&gt;val;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, sum);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, sum);<br><br>        path.<span class="hljs-built_in">pop_back</span>();<br>        <br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">https://leetcode.cn/problems/path-sum/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        targetSum -= root-&gt;val;<br><br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; !targetSum) &#123;<br>            targetSum += root-&gt;val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">hasPathSum</span>(root-&gt;left, targetSum);<br>        <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">hasPathSum</span>(root-&gt;right, targetSum);<br><br>        <span class="hljs-keyword">if</span> (left || right) &#123;<br>            targetSum += root-&gt;val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/35/">https://www.acwing.com/problem/content/35/</a></p>
</blockquote>
<p>注意, 在这个题中, 空🌲不是任何🌲的子结构, 在这个图中, <code>subRoot</code>是<code>root</code>的子结构.</p>
<img alt="树的子结构的定义" src="/2024/03/30/binary-tree/image-20240321195934006.png" style="zoom:50%;">

<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 判断r2子树是否是r1子树的子结构 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *r1, TreeNode *r2)</span> </span>&#123;<br>      <span class="hljs-comment">// 注意, 这里有顺序, 一定要先判断r2是否为空</span><br>        <span class="hljs-keyword">if</span> (!r2) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (!r1) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (r1-&gt;val != r2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(r1-&gt;left, r2-&gt;left) &amp;&amp; <span class="hljs-built_in">dfs</span>(r1-&gt;right, r2-&gt;right);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasSubtree</span><span class="hljs-params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;<br>        <span class="hljs-comment">/* 如果是有一个是NULL, 那么就不是子结构 */</span><br>        <span class="hljs-keyword">if</span> (!pRoot1 || !pRoot2) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(pRoot1, pRoot2)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasSubtree</span>(pRoot1-&gt;left, pRoot2) || <span class="hljs-built_in">hasSubtree</span>(pRoot1-&gt;right, pRoot2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这里还有一道变式题, <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">https://leetcode.cn/problems/subtree-of-another-tree/</a></p>
<p>要求判断是不是子树, 在这种情况下<code>subRoot</code>肯定不是<code>Root</code>的子树.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> !p &amp;&amp; !q;<br>        <span class="hljs-keyword">if</span> (p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="hljs-built_in">dfs</span>(p-&gt;right, q-&gt;right);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubtree</span><span class="hljs-params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root || !subRoot) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(root, subRoot)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSubtree</span>(root-&gt;left, subRoot) || <span class="hljs-built_in">isSubtree</span>(root-&gt;right, subRoot);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<h2 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/37/">https://www.acwing.com/problem/content/description/37/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></p>
</blockquote>
<p>将二叉树变成镜像的方法就是递归地把左右节点交换即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mirror</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">mirror</span>(root-&gt;left);<br>        <span class="hljs-built_in">mirror</span>(root-&gt;right);<br>        <br>        <span class="hljs-keyword">auto</span> t = root-&gt;left;<br>        root-&gt;left = root-&gt;right;<br>        root-&gt;right = t;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题: 判断是否是平衡二叉树, 就是在<code>maxDepth</code>函数中再维护其他信息.</p>
<p>(平衡🌲就是对于🌲中的任意一个节点, 左子树和右子树的最大深度之差绝对值不超过1, 空🌲也是平衡树).</p>
<p>链接: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">https://leetcode.cn/problems/balanced-binary-tree/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> ans = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> lh = <span class="hljs-built_in">dfs</span>(root-&gt;left), rh = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(lh - rh) &gt; <span class="hljs-number">1</span>) ans = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lh, rh) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>变式题: 二叉树的最小深度, <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 注意一个节点为空, 另一个节点不为空的情况, 这种情况应该只取一边</span><br>        <span class="hljs-keyword">if</span> (!root-&gt;left) <span class="hljs-keyword">return</span> <span class="hljs-built_in">minDepth</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-built_in">minDepth</span>(root-&gt;left) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">minDepth</span>(root-&gt;left), <span class="hljs-built_in">minDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="对称的二叉树"><a href="#对称的二叉树" class="headerlink" title="对称的二叉树"></a>对称的二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/38/">https://www.acwing.com/problem/content/description/38/</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/* 判断p和q所在的子树是否对称 */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> !p &amp;&amp; !q;<br>        <span class="hljs-keyword">if</span> (p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="hljs-built_in">dfs</span>(p-&gt;right, q-&gt;left);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/same-tree/description/">https://leetcode.cn/problems/same-tree/description/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> !p &amp;&amp; !q;<br>        <span class="hljs-keyword">if</span> (p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="hljs-built_in">isSameTree</span>(p-&gt;right, q-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题(翻转等价二叉树): <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flip-equivalent-binary-trees/">https://leetcode.cn/problems/flip-equivalent-binary-trees/</a></p>
<ul>
<li>这个题的时间复杂度是$O(n)$, 原因在于每个点都是不一样的, 也就是说等价的方式只有一种.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">flipEquiv</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root1 || !root2) <span class="hljs-keyword">return</span> !root1 &amp;&amp; !root2;<br>        <span class="hljs-keyword">if</span> (root1-&gt;val != root2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">flipEquiv</span>(root1-&gt;left, root2-&gt;left) &amp;&amp; <span class="hljs-built_in">flipEquiv</span>(root1-&gt;right, root2-&gt;right)) || (<span class="hljs-built_in">flipEquiv</span>(root1-&gt;left, root2-&gt;right) &amp;&amp; <span class="hljs-built_in">flipEquiv</span>(root1-&gt;right, root2-&gt;left));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root1) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span> (!root2) <span class="hljs-keyword">return</span> root1;<br><br>        root1-&gt;left = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;left, root2-&gt;left);<br>        root1-&gt;right = <span class="hljs-built_in">mergeTrees</span>(root1-&gt;right, root2-&gt;right);<br><br>        root1-&gt;val += root2-&gt;val;<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>





<h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">https://leetcode.cn/problems/binary-tree-paths/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">binaryTreePaths</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, string path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br><br>        path += <span class="hljs-built_in">to_string</span>(root-&gt;val);<br><br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, path + <span class="hljs-string">&quot;-&gt;&quot;</span>);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right, path + <span class="hljs-string">&quot;-&gt;&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题: 求根节点到叶节点的数字之和</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">https://leetcode.cn/problems/sum-root-to-leaf-numbers/</a></p>
<h2 id="完全二叉树求节点个数"><a href="#完全二叉树求节点个数" class="headerlink" title="完全二叉树求节点个数"></a>完全二叉树求节点个数</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">https://leetcode.cn/problems/count-complete-tree-nodes/</a></p>
</blockquote>
<p>通用的代码: 这个所有树都可以使用, 时间复杂度是$O(n)$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">countNodes</span>(root-&gt;left) + <span class="hljs-built_in">countNodes</span>(root-&gt;right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题: 二叉树的坡度 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-tilt/">https://leetcode.cn/problems/binary-tree-tilt/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findTilt</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left), right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        ans += <span class="hljs-built_in">abs</span>(left - right);<br>        <span class="hljs-keyword">return</span> left + right + root-&gt;val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<h2 id="不同的二叉搜索树求数目"><a href="#不同的二叉搜索树求数目" class="headerlink" title="不同的二叉搜索树求数目"></a>不同的二叉搜索树求数目</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">https://leetcode.cn/problems/unique-binary-search-trees/</a></p>
</blockquote>
<blockquote>
<p>二叉搜索树的中序遍历一定是严格递增的.</p>
</blockquote>
<p>假设$f(n)$表示长度为$n$, 元素为$[1, n]$的二叉搜索树的个数.</p>
<p>初始状态是<code>f[0] = 1</code>. 注意空子树这个形态是合法的, 因为一个状态会由它的左子树和右子树的状态转移而来, 而左子树和右子树可以为空.</p>
<p>从$[1, n]$进行枚举, 对于状态<code>i</code>, 再从$j \in [1, i]$进行枚举, $j$作为根节点, 那么左子树和右子树的个数就分别是<code>f[j - 1]</code>和<code>f[i - (j + 1) + 1]</code>, 进行状态转移即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j ++) &#123;<br>                f[i] += f[j - <span class="hljs-number">1</span>] * f[i - j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>从1~n构成的互不相同的二叉搜索树的个数是卡特兰数.</p>
</blockquote>
<h2 id="不同的二叉搜索树求方案"><a href="#不同的二叉搜索树求方案" class="headerlink" title="不同的二叉搜索树求方案"></a>不同的二叉搜索树求方案</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees-ii/">https://leetcode.cn/problems/unique-binary-search-trees-ii/</a></p>
</blockquote>
<p>常规的搜索问题.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;TreeNode *&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> &#123;<span class="hljs-literal">NULL</span>&#125;;<br>        vector&lt;TreeNode *&gt; res;<br><br>        <span class="hljs-comment">// 枚举根节点的位置</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; i ++) &#123;<br>            <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">dfs</span>(l, i - <span class="hljs-number">1</span>), right = <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, r);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : left) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> q: right) &#123;<br>                    TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(i);<br>                    root-&gt;left = p, root-&gt;right = q;<br>                    res.<span class="hljs-built_in">push_back</span>(root);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p>
</blockquote>
<p>方法一: 如果一个树是二叉搜索树, 等价于中序遍历严格递增.</p>
<p>方法二: 按照定义搜索, 需要求子树中所有元素的最小值和最大值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root)[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">// 返回三个信息, 是否是二叉搜索树, 子树最大值, 子树最小值</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(&#123; <span class="hljs-number">1</span>, root-&gt;val, root-&gt;val &#125;)</span></span>;<br>				<br>        <span class="hljs-keyword">if</span> (root-&gt;left) &#123;<br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>            <span class="hljs-keyword">if</span> (!t[<span class="hljs-number">0</span>] || t[<span class="hljs-number">2</span>] &gt;= root-&gt;val) res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            res[<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(root-&gt;val, t[<span class="hljs-number">1</span>]);<br>            res[<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(root-&gt;val, t[<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;right) &#123;<br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>            <span class="hljs-keyword">if</span> (!t[<span class="hljs-number">0</span>] || t[<span class="hljs-number">1</span>] &lt;= root-&gt;val) res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 注意这里min里面是res[1], 而不是root-&gt;val, 因为取最小值要连上左子树一起比较</span><br>            res[<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(res[<span class="hljs-number">1</span>], t[<span class="hljs-number">1</span>]);<br>            res[<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(res[<span class="hljs-number">2</span>], t[<span class="hljs-number">2</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="恢复二叉搜索树"><a href="#恢复二叉搜索树" class="headerlink" title="恢复二叉搜索树"></a>恢复二叉搜索树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/recover-binary-search-tree/description/">https://leetcode.cn/problems/recover-binary-search-tree/description/</a></p>
</blockquote>
<p>首先, 对于一个二叉搜索树, 它的中序遍历一定是严格单调递增的序列.</p>
<p>如果两个节点被错误地交换了, 那么只有可能是两种情况:</p>
<ul>
<li><p>相邻的两个节点, 例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1, 2, 3, 4, 5 -&gt; 1, 3, 2, 4, 5<br></code></pre></td></tr></table></figure>

<p>这种情况下, 有一个相邻元素组成的逆序对<code>(3, 2)</code>, 只需要交换这两个元素的位置即可.</p>
</li>
<li><p>不相邻的两个节点, 例如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1, 2, 3, 4, 5 -&gt; 1, 4, 3, 2, 5<br></code></pre></td></tr></table></figure>

<p>这种情况下, 有两个相邻元素组成的逆序对<code>(4, 3)</code>和<code>(3, 2)</code>, 只需要交换4和2的位置即可.</p>
</li>
</ul>
<p>时间复杂度是$O(n)$.</p>
<p>如果空间复杂度要求是$O(n)$的话, 可以在进行中序遍历时记录哪些节点需要交换, 直接交换即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;TreeNode*&gt; stk;<br>    vector&lt;TreeNode *&gt; inorder;<br>    vector&lt;TreeNode *&gt; element;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (inorder.<span class="hljs-built_in">size</span>() != <span class="hljs-number">0</span> &amp;&amp; inorder.<span class="hljs-built_in">back</span>()-&gt;val &gt; root-&gt;val) &#123;<br>                element.<span class="hljs-built_in">push_back</span>(inorder.<span class="hljs-built_in">back</span>());<br>                element.<span class="hljs-built_in">push_back</span>(root);<br>            &#125;<br>            inorder.<span class="hljs-built_in">push_back</span>(root);<br>            root = root-&gt;right;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (element.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-type">int</span> t = element[<span class="hljs-number">0</span>]-&gt;val;<br>            element[<span class="hljs-number">0</span>]-&gt;val = element[<span class="hljs-number">1</span>]-&gt;val;<br>            element[<span class="hljs-number">1</span>]-&gt;val = t;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (element.<span class="hljs-built_in">size</span>() == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-type">int</span> t = element[<span class="hljs-number">0</span>]-&gt;val;<br>            element[<span class="hljs-number">0</span>]-&gt;val = element[<span class="hljs-number">3</span>]-&gt;val;<br>            element[<span class="hljs-number">3</span>]-&gt;val = t;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>如果空间复杂度要求是$O(1)$​的话, 就需要用到Morris遍历.</p>
<h3 id="Morris中序遍历"><a href="#Morris中序遍历" class="headerlink" title="Morris中序遍历"></a>Morris中序遍历</h3><p>Morris遍历的流程大概如下:</p>
<ul>
<li>首先, 将当前节点设置成根节点: <code>cur = root</code>.</li>
<li>如果当前节点有左子树:<ul>
<li>找当前节点的前驱<code>prev</code>:<ul>
<li>如果<code>prev</code>的右子树为空, 证明<code>cur</code>的左子树没有被遍历过, 将<code>prev-&gt;right</code>设置成当前节点<code>cur</code>, 然后<code>cur = cur-&gt;left</code>.</li>
<li>如果<code>prev</code>的右子树不为空, 证明<code>cur</code>的左子树已经被遍历过, 此时将<code>prev-&gt;right</code>设置为空, 然后打印<code>cur</code>的值, 然后跳转到右子树<code>cur = cur-&gt;right</code>.</li>
</ul>
</li>
</ul>
</li>
<li>如果当前节点没有左子树:<ul>
<li>打印当前节点的值, 直接进入右子树 (此时一般会回溯到树的上层).</li>
</ul>
</li>
</ul>
<blockquote>
<p>在Morris遍历中, 需要对每个节点都求一次前驱, 但是节点求前驱的时间复杂度是$O(n)$, 为什么Morris遍历的时间复杂度是$O(n)$而不是$O(n^2)$?</p>
</blockquote>
<p>对二叉树的所有节点求一遍前驱的时间复杂度其实就是$O(n)$, 因为每条边只会被遍历两次.</p>
<p>Morris遍历生成中序遍历的代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        <span class="hljs-keyword">auto</span> cur = root;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <br>            <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                <span class="hljs-comment">// find prev</span><br>                <span class="hljs-keyword">auto</span> prev = cur-&gt;left;<br>                <span class="hljs-keyword">while</span> (prev-&gt;right &amp;&amp; prev-&gt;right != cur) prev = prev-&gt;right;<br>                <br>                <span class="hljs-keyword">if</span> (!prev-&gt;right) &#123;<br>                    prev-&gt;right = cur;<br>                    cur = cur-&gt;left;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    prev-&gt;right = <span class="hljs-literal">NULL</span>;<br>                    ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                    cur = cur-&gt;right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>                cur = cur-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>使用Morris遍历解决此题的代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">auto</span> cur = root;<br>        TreeNode *p = <span class="hljs-literal">NULL</span>;<br>        TreeNode *first = <span class="hljs-literal">NULL</span>;<br>        TreeNode *second = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">while</span> (cur) &#123;<br><br>            <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                <span class="hljs-keyword">auto</span> prev = cur-&gt;left;<br>                <span class="hljs-keyword">while</span> (prev-&gt;right &amp;&amp; prev-&gt;right != cur) prev = prev-&gt;right;<br>                <span class="hljs-keyword">if</span> (!prev-&gt;right) &#123;<br>                    prev-&gt;right = cur;<br>                    cur = cur-&gt;left;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    prev-&gt;right = <span class="hljs-literal">NULL</span>;<br>                    <span class="hljs-keyword">if</span> (p &amp;&amp; p-&gt;val &gt; cur-&gt;val) &#123;<br>                        <span class="hljs-keyword">if</span> (!first) first = p, second = cur;<br>                        <span class="hljs-keyword">else</span> second = cur;<br>                    &#125;<br>                    p = cur;<br>                    cur = cur-&gt;right;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (p &amp;&amp; p-&gt;val &gt; cur-&gt;val) &#123;<br>                    <span class="hljs-keyword">if</span> (!first) first = p, second = cur;<br>                    <span class="hljs-keyword">else</span> second = cur;<br>                &#125;<br>                p = cur;<br>                cur = cur-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(first-&gt;val, second-&gt;val);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="有序数组变二叉搜索树"><a href="#有序数组变二叉搜索树" class="headerlink" title="有序数组变二叉搜索树"></a>有序数组变二叉搜索树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p>
</blockquote>
<p>时间复杂度是$O(n)$​.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br><br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(nums, l, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(nums, mid + <span class="hljs-number">1</span>, r);<br>        <br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>证明: 用该算法得到的二叉搜索树的所有高度(不是最大高度)之差的最大值不超过1</p>
</blockquote>
<ul>
<li>左半部分的节点每次最多比右半部分少1, 如果高度差最大值是2, 那么必然左边会比右边多一层, 这根本不可能, 多1个节点贡献的高度差肯定吵不过1.</li>
</ul>
<h2 id="有序链表变二叉搜索树"><a href="#有序链表变二叉搜索树" class="headerlink" title="有序链表变二叉搜索树"></a>有序链表变二叉搜索树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/</a></p>
</blockquote>
<p>找有序链表的终点可以使用快慢指针.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(head, <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">build</span><span class="hljs-params">(ListNode *s, ListNode *t)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span> (s == t) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">auto</span> fast = s, slow = s;<br><br>        <span class="hljs-keyword">while</span> (fast != t &amp;&amp; fast-&gt;next != t) &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(slow-&gt;val);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(s, slow);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(slow-&gt;next, t);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>时间复杂度是$T(n) &#x3D; 2T(\frac{n}{2}) + O(n)$, 根据主定理, 最后的时间复杂度是$O(nlogn)$.</p>
<h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/</a></p>
</blockquote>
<p>每一次只需要将当前节点<code>cur</code>的左节点<code>cur-&gt;left</code>到<code>cur</code>的前驱节点这一条路合并到右子树就可以了, 合并之后<code>cur</code>向右移动.</p>
<p>效果如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1.  1<br>   / \<br>  2   5<br> / \   \<br>3   4   6<br><br>2.  1<br>     \<br>      2<br>     / \<br>    3   4<br>         \<br>          5<br>           \<br>            6<br><br>3.  1<br>     \<br>      2<br>       \<br>        3<br>         \<br>          4<br>           \<br>            5<br>             \<br>              6<br></code></pre></td></tr></table></figure>



<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur = root;<br><br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                <span class="hljs-keyword">auto</span> prev = cur-&gt;left;<br>                <span class="hljs-keyword">while</span> (prev-&gt;right) prev = prev-&gt;right;<br>                prev-&gt;right = cur-&gt;right;<br>                cur-&gt;right = cur-&gt;left;<br>                cur-&gt;left = <span class="hljs-number">0</span>;<br>            &#125;<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<p>类似的题 (递增顺序搜索树):<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/increasing-order-search-tree/">https://leetcode.cn/problems/increasing-order-search-tree/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode *cur;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <br>        cur = cur-&gt;right = root;<br>        root-&gt;left = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">increasingBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">-1</span>);<br>        cur = dummy;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> dummy-&gt;right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="填充每个节点的下一个右侧节点"><a href="#填充每个节点的下一个右侧节点" class="headerlink" title="填充每个节点的下一个右侧节点"></a>填充每个节点的下一个右侧节点</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/</a></p>
</blockquote>
<p>最简单也是最容易想的方法: 层序遍历</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        queue&lt;Node *&gt; q;<br>        <br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;Node *&gt; level;<br>            <span class="hljs-keyword">while</span> (len --) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(t);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; level.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; level.<span class="hljs-built_in">size</span>()) &#123;<br>                    level[i]-&gt;next = level[i + <span class="hljs-number">1</span>];<br>                &#125;<br>                <span class="hljs-keyword">else</span> level[i]-&gt;next = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>但是用层序遍历的空间复杂度是$O(n)$, 如果要求用常数空间, 可以借助bfs的思想</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>				<br>      	<span class="hljs-comment">// 注意这里判断p的时候应该用p-&gt;left不为空, 因为要操作下一层节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = root; p-&gt;left; p = p-&gt;left) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> q = p; q; q = q-&gt;next) &#123;<br>              <span class="hljs-comment">// 核心点</span><br>                q-&gt;left-&gt;next = q-&gt;right;<br>                q-&gt;right-&gt;next = q-&gt;next ? q-&gt;next-&gt;left : <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>其中核心点在于, 我遍历这一层时, 我操作下一层的<code>next</code>指针, 假设我遍历到节点<code>cur</code>:</p>
<ul>
<li><code>cur</code>左儿子的<code>next</code>应该指向<code>cur-&gt;right</code>.</li>
<li><code>cur</code>右儿子的<code>next</code>应该指向<code>cur-&gt;next-&gt;left</code>.<ul>
<li>注意, <code>cur</code>右儿子的<code>next</code>应该是我在遍历<code>cur</code>上层节点的时候设置好了, 这其实就是一个<code>bfs</code>迭代的过程.</li>
</ul>
</li>
</ul>
<p>变式: 如果二叉树不是满二叉树</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/">https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/</a></p>
<p>此时, 再遍历上一层时, 只需要用链表的形式把下一层节点串起来即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-keyword">auto</span> cur = root;<br><br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-comment">// 每一层维护两个变量, 所以是常数空间</span><br>            <span class="hljs-keyword">auto</span> head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">auto</span> tail = head;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = cur; p; p = p-&gt;next) &#123;<br>                <span class="hljs-keyword">if</span> (p-&gt;left) tail = tail-&gt;next = p-&gt;left;<br>                <span class="hljs-keyword">if</span> (p-&gt;right) tail = tail-&gt;next = p-&gt;right;<br>            &#125;<br>            <br>            cur = head-&gt;next;<br>            <span class="hljs-keyword">delete</span> head;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉搜索树的LCA"><a href="#二叉搜索树的LCA" class="headerlink" title="二叉搜索树的LCA"></a>二叉搜索树的LCA</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></p>
</blockquote>
<p>时间复杂度是$O(h)$, 其中$h$是二叉搜索树的高度.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p-&gt;val &gt; q-&gt;val) <span class="hljs-built_in">swap</span>(p, q);<br>        <span class="hljs-keyword">if</span> (p-&gt;val &lt;= root-&gt;val &amp;&amp; q-&gt;val &gt;= root-&gt;val) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span> (q-&gt;val &lt; root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);<br>        <span class="hljs-keyword">if</span> (p-&gt;val &gt; root-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树的LCA"><a href="#二叉树的LCA" class="headerlink" title="二叉树的LCA"></a>二叉树的LCA</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
</blockquote>
<p>时间复杂度是$O(n)$.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode * ans = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, p, q);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断root所在子树中是否存在节点p, q</span><br>    <span class="hljs-comment">// 00: 没有pq, 01: 有p, 10: 有q, 11: 有pq</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> state = <span class="hljs-built_in">dfs</span>(root-&gt;left, p, q);<br>        <span class="hljs-keyword">if</span> (root == p) state |= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root == q) state |= <span class="hljs-number">2</span>;<br>        state |= <span class="hljs-built_in">dfs</span>(root-&gt;right, p, q);<br>      <span class="hljs-comment">// 如果一个子树里同时有p, q, 并且第一次被遍历到, 就是LCA</span><br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">3</span> &amp;&amp; !ans) ans = root;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="验证二叉树前序序列化"><a href="#验证二叉树前序序列化" class="headerlink" title="验证二叉树前序序列化"></a>验证二叉树前序序列化</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/">https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree/</a></p>
</blockquote>
<p>按照前序遍历的递归过程模拟吃掉元素, 如果吃掉元素过程中有问题就有问题.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidSerialization</span><span class="hljs-params">(string preorder)</span> </span>&#123;<br>        preorder += <span class="hljs-string">&quot;,&quot;</span>;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(preorder, u)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果我遍历完了, 但是字符串还有, 不合法</span><br>        <span class="hljs-keyword">return</span> u == preorder.<span class="hljs-built_in">size</span>();<br>    &#125;<br>		<br>  <span class="hljs-comment">// 注意这里的u加了引用, 表示所有dfs共用u</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string preorder, <span class="hljs-type">int</span> &amp;u)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果我还没遍历完, 但是字符串没了, 不合法</span><br>        <span class="hljs-keyword">if</span> (u == preorder.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 子树遍历完了</span><br>        <span class="hljs-keyword">if</span> (preorder[u] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>            u += <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 过滤到下一个元素</span><br>        <span class="hljs-keyword">while</span> (preorder[u] != <span class="hljs-string">&#x27;,&#x27;</span>) u ++;<br>        <span class="hljs-comment">// 过滤,</span><br>        u ++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preorder, u) &amp;&amp; <span class="hljs-built_in">dfs</span>(preorder, u);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/</a></p>
</blockquote>
<p>序列化可以采用前序遍历+记录空节点的方式.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs_s</span>(root, path);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_s</span><span class="hljs-params">(TreeNode *root, string &amp;path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) &#123;<br>            path += <span class="hljs-string">&quot;#,&quot;</span>;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        path += <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&quot;,&quot;</span>;<br>        <span class="hljs-built_in">dfs_s</span>(root-&gt;left, path);<br>        <span class="hljs-built_in">dfs_s</span>(root-&gt;right, path);<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs_d</span>(data, u);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs_d</span><span class="hljs-params">(string data, <span class="hljs-type">int</span> &amp;u)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (u == data.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (data[u] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>            u += <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> k = u;<br>            <span class="hljs-keyword">while</span> (data[u] != <span class="hljs-string">&#x27;,&#x27;</span>) u ++;<br>            <span class="hljs-type">int</span> val = <span class="hljs-built_in">stoi</span>(data.<span class="hljs-built_in">substr</span>(k, u - k));<br>            u ++;<br>            <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            root-&gt;left = <span class="hljs-built_in">dfs_d</span>(data, u);<br>            root-&gt;right = <span class="hljs-built_in">dfs_d</span>(data, u);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉搜索树的序列化和反序列化"><a href="#二叉搜索树的序列化和反序列化" class="headerlink" title="二叉搜索树的序列化和反序列化"></a>二叉搜索树的序列化和反序列化</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">https://leetcode.cn/problems/serialize-and-deserialize-bst/</a></p>
</blockquote>
<p>如果是二叉搜索树, 那么就默认中序遍历已经给了, 因此, 可以直接拿前序遍历来做序列化.</p>
<p>反序列化时, 可以根据二叉搜索树的定义来区分左右子树的边界.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Codec</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">// Encodes a tree to a single string.</span><br>    <span class="hljs-function">string <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        string path = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-built_in">dfs_s</span>(root, path);<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_s</span><span class="hljs-params">(TreeNode *root, string &amp;path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        path += <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-built_in">dfs_s</span>(root-&gt;left, path), <span class="hljs-built_in">dfs_s</span>(root-&gt;right, path);<br>    &#125;<br><br>    <span class="hljs-comment">// Decodes your encoded data to tree.</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deserialize</span><span class="hljs-params">(string data)</span> </span>&#123;<br>        <span class="hljs-comment">// 先将字符串转换为vector</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>        <span class="hljs-function">stringstream <span class="hljs-title">ssin</span><span class="hljs-params">(data)</span></span>;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (ssin &gt;&gt; x) arr.<span class="hljs-built_in">push_back</span>(x);<br><br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs_d</span>(arr, u, INT_MIN, INT_MAX);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs_d</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;arr, <span class="hljs-type">int</span> &amp;u, <span class="hljs-type">int</span> minv, <span class="hljs-type">int</span> maxv)</span> </span>&#123;<br>        <span class="hljs-comment">// 遍历完</span><br>        <span class="hljs-keyword">if</span> (u == arr.<span class="hljs-built_in">size</span>() || arr[u] &lt; minv || arr[u] &gt; maxv) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(arr[u]);<br>        u ++;<br>        <span class="hljs-comment">// 左子树中节点的值在[minv, root-&gt;val]之间, 如果超出范围, 表示遍历完了</span><br>        root-&gt;left = <span class="hljs-built_in">dfs_d</span>(arr, u, minv, root-&gt;val);<br>        root-&gt;right = <span class="hljs-built_in">dfs_d</span>(arr, u, root-&gt;val, maxv);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>







<h2 id="左子叶之和"><a href="#左子叶之和" class="headerlink" title="左子叶之和"></a>左子叶之和</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">https://leetcode.cn/problems/sum-of-left-leaves/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfLeftLeaves</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <br>        <span class="hljs-comment">// 如果root有左儿子, 并且还是叶子节点, 再累加</span><br>        <span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right) ans += root-&gt;left-&gt;val;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树的最大路径和"><a href="#二叉树的最大路径和" class="headerlink" title="二叉树的最大路径和"></a>二叉树的最大路径和</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">https://leetcode.cn/problems/binary-tree-maximum-path-sum/</a></p>
</blockquote>
<p>枚举路径的时候, 我们可以先枚举这条路径左右端点的LCA, 假设LCA是u</p>
<ul>
<li>然后可以发现, 这个路径和是由三部分组成:<ul>
<li>节点u本身的值.</li>
<li>节点u左子树往下的所有路径(注意这个路径不拐弯)的最大值.</li>
<li>节点u右子树往下所有路径的最大值.</li>
</ul>
</li>
<li>路径和可以由这三部分相加组成, 其中后两部分可以通过递归求出.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dfs</span>(root-&gt;left));<br>        <span class="hljs-type">int</span> right = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">dfs</span>(root-&gt;right));<br><br>        ans = <span class="hljs-built_in">max</span>(ans, root-&gt;val + left + right);<br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(left, right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题: 二叉树的直径: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">https://leetcode.cn/problems/diameter-of-binary-tree/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>      <span class="hljs-comment">// 直径是边数, 等于点数-1</span><br>        <span class="hljs-keyword">return</span> ans - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left), right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> res = left + right + <span class="hljs-number">1</span>;<br>        ans = <span class="hljs-built_in">max</span>(ans, res);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题: 最长同值路径, <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-univalue-path/">https://leetcode.cn/problems/longest-univalue-path/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestUnivaluePath</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">dfs</span>(root-&gt;left), r = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (!root-&gt;left || root-&gt;left-&gt;val != root-&gt;val) l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (!root-&gt;right || root-&gt;right-&gt;val != root-&gt;val) r = <span class="hljs-number">0</span>;<br>        ans = <span class="hljs-built_in">max</span>(ans, l + r );<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(l, r) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">https://leetcode.cn/problems/find-bottom-left-tree-value/</a></p>
</blockquote>
<p>用bfs记录一下即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-built_in">del</span>(root, key);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(TreeNode* &amp;root, <span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-keyword">if</span> (key &lt; root-&gt;val) &#123;<br>            <span class="hljs-built_in">del</span>(root-&gt;left, key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (key &gt; root-&gt;val) &#123;<br>            <span class="hljs-built_in">del</span>(root-&gt;right, key);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) root = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root-&gt;left) root = root-&gt;right;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!root-&gt;right) root = root-&gt;left;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> next = root-&gt;right;<br>            <span class="hljs-keyword">while</span> (next-&gt;left) next = next-&gt;left;<br>            root-&gt;val = next-&gt;val;<br>            <span class="hljs-built_in">del</span>(root-&gt;right, next-&gt;val);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">https://leetcode.cn/problems/find-largest-value-in-each-tree-row/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">largestValues</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">int</span> maxv = INT_MIN;<br>            <span class="hljs-keyword">while</span> (len --) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                maxv = <span class="hljs-built_in">max</span>(maxv, t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(maxv);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>同类题: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">https://leetcode.cn/problems/merge-two-binary-trees/</a></p>
<p>二叉树层平均值.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">double</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">averageOfLevels</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-type">double</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                sum += t-&gt;val;<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(sum / len);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="路径总和III"><a href="#路径总和III" class="headerlink" title="路径总和III"></a>路径总和III</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">https://leetcode.cn/problems/path-sum-iii/</a></p>
</blockquote>
<p>这个题有一个一维版本: <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">https://leetcode.cn/problems/subarray-sum-equals-k/</a></p>
<p>解法使用前缀和+哈希表.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    unordered_map&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        hash[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">dfs</span>(root, targetSum, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> targetSum, <span class="hljs-type">long</span> <span class="hljs-type">long</span> path)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        path += root-&gt;val;<br>        ans += hash[path - targetSum];<br>        hash[path] ++;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, targetSum, path), <span class="hljs-built_in">dfs</span>(root-&gt;right, targetSum, path);<br>        hash[path] --;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">https://leetcode.cn/problems/find-mode-in-binary-search-tree/</a></p>
</blockquote>
<ul>
<li>首先, 二叉搜索树的中序遍历一定是有序的, 那么重复元素在中序遍历序列中一定是连续出现了.</li>
<li>可以在中序遍历的过程中维护一些信息用来统计众数:<ul>
<li><code>last</code>: 某一段连续的数, 这个数是什么.</li>
<li><code>curc</code>: 当前这个数出现的次数.</li>
<li><code>maxc</code>: 全局中, 出现次数最多的数, 它出现的次数到底是多少.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxc = <span class="hljs-number">0</span>, curc = <span class="hljs-number">0</span>, last;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findMode</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span> (!curc || root-&gt;val == last) &#123;<br>            curc ++;<br>            last = root-&gt;val;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            curc = <span class="hljs-number">1</span>;<br>            last = root-&gt;val;<br>        &#125;<br>        <span class="hljs-comment">// 每次更新都需要维护maxc</span><br>        <span class="hljs-keyword">if</span> (curc &gt; maxc) &#123;<br>            maxc = curc;<br>            ans = &#123;last&#125;;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (curc == maxc) ans.<span class="hljs-built_in">push_back</span>(last);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="出现次数最多的子树元素和"><a href="#出现次数最多的子树元素和" class="headerlink" title="出现次数最多的子树元素和"></a>出现次数最多的子树元素和</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/most-frequent-subtree-sum/">https://leetcode.cn/problems/most-frequent-subtree-sum/</a></p>
</blockquote>
<p>在求子树和的过程中, 用哈希表维护子树和的信息即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-type">int</span> maxc = <span class="hljs-number">0</span>;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findFrequentTreeSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> sum = root-&gt;val + <span class="hljs-built_in">dfs</span>(root-&gt;left) + <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        hash[sum] ++;<br>        <span class="hljs-keyword">if</span> (hash[sum] &gt; maxc) &#123;<br>            maxc = hash[sum];<br>            ans = &#123;sum&#125;;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (hash[sum] == maxc) ans.<span class="hljs-built_in">push_back</span>(sum);<br><br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">https://leetcode.cn/problems/minimum-absolute-difference-in-bst/</a></p>
</blockquote>
<p>二叉搜索树的中序遍历是有序的, 因此, 最小绝对差只能在相邻的元素中取到, 只需要在中序遍历中维护一下相关信息即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = INT_MAX;<br>    <span class="hljs-type">bool</span> is_first = <span class="hljs-literal">true</span>;<br>    TreeNode * last;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br><br>        <span class="hljs-keyword">if</span> (is_first) is_first = <span class="hljs-literal">false</span>, last = root;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, root-&gt;val - last-&gt;val);<br>        &#125;<br>        last = root;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>一种同类题: 二叉搜索树转换为累加树, <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">https://leetcode.cn/problems/convert-bst-to-greater-tree/</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br><br>        <span class="hljs-type">int</span> x = root-&gt;val;<br>        root-&gt;val += sum;<br>        sum += x;<br><br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="在二叉树中增加一行"><a href="#在二叉树中增加一行" class="headerlink" title="在二叉树中增加一行"></a>在二叉树中增加一行</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-one-row-to-tree/description/">https://leetcode.cn/problems/add-one-row-to-tree/description/</a></p>
</blockquote>
<p>涉及二叉树行的问题, 其实都可以用层序遍历解决.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">addOneRow</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        depth --;<br>        <span class="hljs-keyword">if</span> (!depth) &#123;<br>            <span class="hljs-keyword">auto</span> cur = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>            cur-&gt;left = root;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            depth --;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (!depth) &#123;<br>                    <span class="hljs-keyword">auto</span> cur1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>                    <span class="hljs-keyword">auto</span> cur2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>                    cur1-&gt;left = t-&gt;left;<br>                    t-&gt;left = cur1;<br>                    cur2-&gt;right = t-&gt;right;<br>                    t-&gt;right = cur2;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!depth) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="寻找重复的子树"><a href="#寻找重复的子树" class="headerlink" title="寻找重复的子树"></a>寻找重复的子树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-duplicate-subtrees/description/">https://leetcode.cn/problems/find-duplicate-subtrees/description/</a></p>
</blockquote>
<p>这个题涉及二叉树中哈希一颗子树的方案, 可以采用如下的方案:</p>
<ul>
<li>对于每个子树, 用一个三元组来表示, 三元组的构成是: <code>(root-&gt;val, 左子树id, 右子树id)</code>.</li>
<li>左子树id和右子树id可以用一个全局的变量来分配.</li>
</ul>
<p>这个三元组可以变成一个字符串存储在哈希表中, 这个哈希表可以将字符串映射到一个唯一的<code>id</code>, 这个<code>id</code>可以映射到<code>id</code>出现的次数, 如果出现次数大于1, 证明出现了重复的子树.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;TreeNode *&gt; ans;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    unordered_map&lt;string, <span class="hljs-type">int</span>&gt; ids;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br><br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">findDuplicateSubtrees</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">/* Return id */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-comment">// Use 0 to map NULL</span><br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left), right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        string key = <span class="hljs-built_in">to_string</span>(root-&gt;val) + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">to_string</span>(left) + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">to_string</span>(right);<br><br>        <span class="hljs-keyword">if</span> (ids.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) ids[key] = ++cnt;<br>        <span class="hljs-type">int</span> id = ids[key];<br>        <span class="hljs-keyword">if</span> (++ hash[id] == <span class="hljs-number">2</span>) ans.<span class="hljs-built_in">push_back</span>(root);<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="两数之和-二叉搜索树"><a href="#两数之和-二叉搜索树" class="headerlink" title="两数之和-二叉搜索树"></a>两数之和-二叉搜索树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/">https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/</a></p>
</blockquote>
<p>直接采用哈希表做.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root, k);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(root-&gt;left, k)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(k - root-&gt;val)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        hash.<span class="hljs-built_in">insert</span>(root-&gt;val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;right, k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/description/">https://leetcode.cn/problems/maximum-binary-tree/description/</a></p>
</blockquote>
<p>RMQ和二叉树结合的问题, 注意此时<code>f</code>数组中维护的不是最大值, 而是最大值的下标.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; f;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; _nums)</span> </span>&#123;<br>        nums = _nums;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-built_in">log</span>(n) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>        f = vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;( k + <span class="hljs-number">1</span> ));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= k; j ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt; n; i ++) &#123;<br>                <span class="hljs-keyword">if</span> (!j) f[i][j] = i;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> l = f[i][j - <span class="hljs-number">1</span>], r = f[i + (<span class="hljs-number">1</span> &lt;&lt; j - <span class="hljs-number">1</span>)][j - <span class="hljs-number">1</span>];<br>                    <span class="hljs-keyword">if</span> (nums[l] &gt; nums[r]) f[i][j] = l;<br>                    <span class="hljs-keyword">else</span> f[i][j] = r;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-comment">// query</span><br>        <span class="hljs-type">int</span> k = <span class="hljs-built_in">log</span>(r - l + <span class="hljs-number">1</span>) / <span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> a = f[l][k], b = f[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k];<br>        <span class="hljs-keyword">if</span> (nums[a] &gt; nums[b]) <span class="hljs-keyword">return</span> a;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> b;<br>    &#125;<br>    <span class="hljs-function">TreeNode * <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> k = <span class="hljs-built_in">query</span>(l, r);<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[k]);<br>        root-&gt;left = <span class="hljs-built_in">build</span>(l, k - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(k + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树的最大宽度"><a href="#二叉树的最大宽度" class="headerlink" title="二叉树的最大宽度"></a>二叉树的最大宽度</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">https://leetcode.cn/problems/maximum-width-of-binary-tree/</a></p>
</blockquote>
<p>在二叉树中, 节点可以有编号, 这个编号类似于堆, 假设一个节点编号是<code>u</code>:</p>
<ul>
<li>左节点一般是<code>u * 2</code>, 右节点一般是<code>u * 2 + 1</code>.</li>
</ul>
<p>这个节点编号可以做很多事情, 这个题就是考察这个编号的用法.</p>
<p>但是, 如果二叉树节点一多, 编号每次都乘2, 那么很快就会爆<code>int</code>.</p>
<p>在这个题中, 只在意编号的相对关系, 因此可以让每层的编号强制从1开始.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>    LL ans = <span class="hljs-number">-1</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">widthOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// int stands for id for TreeNode</span><br>        queue&lt;pair&lt;TreeNode *, LL&gt;&gt; q;<br>        q.<span class="hljs-built_in">push</span>(&#123; root, <span class="hljs-number">1</span> &#125;);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            LL l = q.<span class="hljs-built_in">front</span>().second, r;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">auto</span> v = t.first;<br>                r = t.second;<br>                LL p = r - l + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (v-&gt;left) q.<span class="hljs-built_in">push</span>(&#123; v-&gt;left, p * <span class="hljs-number">2</span> &#125;);<br>                <span class="hljs-keyword">if</span> (v-&gt;right) q.<span class="hljs-built_in">push</span>(&#123; v-&gt;right, p * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &#125;);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="修建二叉搜索树"><a href="#修建二叉搜索树" class="headerlink" title="修建二叉搜索树"></a>修建二叉搜索树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">https://leetcode.cn/problems/trim-a-binary-search-tree/</a></p>
</blockquote>
<p>这个题有个规律, 如果一个节点要被删除了:</p>
<ul>
<li>如果节点小于low, 那么这个点连同左子树都要没, 直接把右子树提上来.</li>
<li>大于high的情况同理.</li>
<li>如果节点在区间范围, 只需要递归左右子树修剪即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">trimBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; low) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">if</span> (root-&gt;val &gt; high) <span class="hljs-keyword">return</span> <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;left = <span class="hljs-built_in">trimBST</span>(root-&gt;left, low, high);<br>        root-&gt;right = <span class="hljs-built_in">trimBST</span>(root-&gt;right, low, high);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树中第二小的节点"><a href="#二叉树中第二小的节点" class="headerlink" title="二叉树中第二小的节点"></a>二叉树中第二小的节点</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/description/">https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/description/</a></p>
</blockquote>
<p>直接遍历即可, 注意维护最小值和次小值的逻辑(<code>&lt;</code>和<code>&lt;=</code>).</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>    LL d1, d2;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findSecondMinimumValue</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        d1 = d2 = <span class="hljs-number">1e18</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">if</span> (d2 == <span class="hljs-number">1e18</span>) d2 = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> d2;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-comment">// 注意这里一定是&lt;, 不是&lt;=</span><br>        <span class="hljs-keyword">if</span> (root-&gt;val &lt; d1) d2 = d1, d1 = root-&gt;val;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;val &gt; d1 &amp;&amp; root-&gt;val &lt; d2) d2 = root-&gt;val;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left), <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="输出二叉树"><a href="#输出二叉树" class="headerlink" title="输出二叉树"></a>输出二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/print-binary-tree/">https://leetcode.cn/problems/print-binary-tree/</a></p>
</blockquote>
<p><font color="red">注意: 🌲的高度和深度的定义不同:</font></p>
<ul>
<li>高度: 从根节点到叶子节点的<strong>边</strong>的数量.</li>
<li>深度: 从根节点到叶子节点经过的<strong>节点</strong>数量.</li>
</ul>
<p>满二叉树第$n$层的节点个数是$2^{n}-1$​.</p>
<p>这个题直接递归打印即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>		<span class="hljs-comment">// 返回树的最大高度和最大宽度</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">dfs</span>(root-&gt;left), r = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-built_in">max</span>(l[<span class="hljs-number">0</span>], r[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>, <span class="hljs-built_in">max</span>(l[<span class="hljs-number">1</span>], r[<span class="hljs-number">1</span>]) * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(TreeNode * root, <span class="hljs-type">int</span> h, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        ans[h][mid] = <span class="hljs-built_in">to_string</span>(root-&gt;val);<br>        <span class="hljs-built_in">print</span>(root-&gt;left, h + <span class="hljs-number">1</span>, l, mid - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">print</span>(root-&gt;right, h + <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    &#125;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">printTree</span>(TreeNode* root) &#123;<br>        <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-type">int</span> h = t[<span class="hljs-number">0</span>], w = t[<span class="hljs-number">1</span>];<br>        ans = vector&lt;vector&lt;string&gt;&gt;(h, <span class="hljs-built_in">vector</span>&lt;string&gt;(w));<br>        <span class="hljs-built_in">print</span>(root, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, w - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树剪枝"><a href="#二叉树剪枝" class="headerlink" title="二叉树剪枝"></a>二叉树剪枝</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-pruning/">https://leetcode.cn/problems/binary-tree-pruning/</a></p>
</blockquote>
<p>dfs直接遍历一遍就可以.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">pruneTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// root没有1, 那么就要删掉</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(root)) root = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">// 返回root所在子树是否包含1</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 删除左右子树</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(root-&gt;left)) root-&gt;left = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(root-&gt;right)) root-&gt;right = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> root-&gt;val || root-&gt;left || root-&gt;right;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树中所有距离为k的点"><a href="#二叉树中所有距离为k的点" class="headerlink" title="二叉树中所有距离为k的点"></a>二叉树中所有距离为k的点</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/">https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/</a></p>
</blockquote>
<p>直接把二叉树变成一个无向图, 然后从target开始搜索即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;TreeNode *, vector&lt;TreeNode*&gt;&gt; g;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (root-&gt;left) &#123;<br>            g[root].<span class="hljs-built_in">push_back</span>(root-&gt;left);<br>            g[root-&gt;left].<span class="hljs-built_in">push_back</span>(root);<br>            <span class="hljs-built_in">dfs1</span>(root-&gt;left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;right) &#123;<br>            g[root].<span class="hljs-built_in">push_back</span>(root-&gt;right);<br>            g[root-&gt;right].<span class="hljs-built_in">push_back</span>(root);<br>            <span class="hljs-built_in">dfs1</span>(root-&gt;right);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(TreeNode *u, TreeNode *father, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!u) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">if</span> (!k) ans.<span class="hljs-built_in">push_back</span>(u-&gt;val);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> son : g[u]) &#123;<br>            <span class="hljs-keyword">if</span> (son != father) &#123;<br>                <span class="hljs-built_in">dfs2</span>(son, u, k - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">distanceK</span><span class="hljs-params">(TreeNode* root, TreeNode* target, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs1</span>(root);<br>        <span class="hljs-built_in">dfs2</span>(target, <span class="hljs-literal">NULL</span>, k);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="最深节点的最小子树"><a href="#最深节点的最小子树" class="headerlink" title="最深节点的最小子树"></a>最深节点的最小子树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/">https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/</a></p>
</blockquote>
<p>递归需要考虑两个问题:</p>
<ul>
<li>我需要维护什么信息.</li>
<li>知道左子树&#x2F;右子树的信息, 如何求出根的信息.</li>
</ul>
<p>这个题中, 我需要维护一个节点所在子树, 最深的节点的深度, 以及这个点最小子树的树根, 假设叫h:</p>
<ul>
<li>如果<code>left.h == right.h</code>, 那么根节点就是答案.</li>
<li>如果<code>left.h &gt; right.h</code>, 那么最深的点在左子树.</li>
<li>如果<code>left.h &lt; right.h</code>, 那么最深的点在右子树.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">pair&lt;TreeNode*, <span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">dfs</span>(root-&gt;left), r = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-keyword">if</span> (l.second == r.second) <span class="hljs-keyword">return</span> &#123; root, l.second + <span class="hljs-number">1</span> &#125;;<br>        <span class="hljs-keyword">if</span> (l.second &gt; r.second) <span class="hljs-keyword">return</span> &#123; l.first, l.second + <span class="hljs-number">1</span> &#125;;<br>        <span class="hljs-keyword">return</span> &#123; r.first, r.second + <span class="hljs-number">1</span> &#125;;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">subtreeWithAllDeepest</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root).first;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="所有可能的真二叉树"><a href="#所有可能的真二叉树" class="headerlink" title="所有可能的真二叉树"></a>所有可能的真二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-possible-full-binary-trees/">https://leetcode.cn/problems/all-possible-full-binary-trees/</a></p>
</blockquote>
<p>首先, 对于这种二叉树, 节点的个数必须是奇数, 因为边数肯定是偶数.</p>
<p>然后, 对于可能的解, 可以分为如下几类:</p>
<ul>
<li>左子树1个节点, 右子树n - 2个.</li>
<li>左子树3个节点, 右子树n - 4个.</li>
<li>…</li>
<li>左子树n - 2个, 右子树1个.</li>
</ul>
<p>每次递归左右子树后, 按照乘法原理, 从左右子树中任选一种方案都是合法方案.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;TreeNode*&gt; <span class="hljs-title">allPossibleFBT</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        <br>        vector&lt;TreeNode *&gt; ans;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>));<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i += <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">allPossibleFBT</span>(i);<br>            <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">allPossibleFBT</span>(n - <span class="hljs-number">1</span> - i);<br><br>            <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>);<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> l : left)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> r: right)<br>                    ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(<span class="hljs-number">0</span>, l, r));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="完全二叉树插入器"><a href="#完全二叉树插入器" class="headerlink" title="完全二叉树插入器"></a>完全二叉树插入器</h2><p>这个题考查的是完全二叉树的堆存储方式.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CBTInserter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode* R;<br>    <span class="hljs-comment">// 堆的存储方式</span><br>    vector&lt;TreeNode *&gt; h;<br>    <span class="hljs-built_in">CBTInserter</span>(TreeNode* root) &#123;<br>      <span class="hljs-comment">// 完全二叉树堆存储, 下标从1开始</span><br>        h.<span class="hljs-built_in">resize</span>(<span class="hljs-number">1</span>);<br>        R = root;<br>        <span class="hljs-comment">// 宽搜, 放到堆里</span><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            h.<span class="hljs-built_in">push_back</span>(t);<br>            <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>            <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val);<br>        h.<span class="hljs-built_in">push_back</span>(t);<br>        <span class="hljs-type">int</span> k = h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> p = k / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (p * <span class="hljs-number">2</span> == k) h[p]-&gt;left = t;<br>        <span class="hljs-keyword">else</span> h[p]-&gt;right = t;<br>        <span class="hljs-keyword">return</span> h[p]-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function">TreeNode* <span class="hljs-title">get_root</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> R;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="判断是否是完全二叉树"><a href="#判断是否是完全二叉树" class="headerlink" title="判断是否是完全二叉树"></a>判断是否是完全二叉树</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">https://leetcode.cn/problems/check-completeness-of-a-binary-tree/</a></p>
</blockquote>
<p>同样考察完全二叉树的堆式存储.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// n用来记录遍历了多少点, p用来记录下标的最大值</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>, p = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 节点数目最多100, 如果超过了就直接返回false, 避免x2溢出</span><br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">100</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        n ++;<br>        p = <span class="hljs-built_in">max</span>(p, k);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, k * <span class="hljs-number">2</span>) &amp;&amp; <span class="hljs-built_in">dfs</span>(root-&gt;right, k * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">dfs</span>(root, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 如果遍历的点正好等于p, 那么就是完全二叉树</span><br>        <span class="hljs-keyword">return</span> n == p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h2 id="二叉树的堂兄弟节点"><a href="#二叉树的堂兄弟节点" class="headerlink" title="二叉树的堂兄弟节点"></a>二叉树的堂兄弟节点</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cousins-in-binary-tree/">https://leetcode.cn/problems/cousins-in-binary-tree/</a></p>
</blockquote>
<p>在搜索的时候记录一下父亲节点和深度信息即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> depth)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;;<br>        <span class="hljs-keyword">if</span> (root-&gt;val == x) <span class="hljs-keyword">return</span> &#123; fa, depth &#125;;<br><br>        <span class="hljs-keyword">auto</span> l = <span class="hljs-built_in">dfs</span>(root-&gt;left, x, root-&gt;val, depth + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">auto</span> r = <span class="hljs-built_in">dfs</span>(root-&gt;right, x, root-&gt;val, depth + <span class="hljs-number">1</span>);<br>				<span class="hljs-comment">// 这里, l和r只会有一边有值, 另一边会返回&#123;0, 0&#125;, trick</span><br>        <span class="hljs-keyword">return</span> &#123; l[<span class="hljs-number">0</span>] + r[<span class="hljs-number">0</span>], l[<span class="hljs-number">1</span>] + r[<span class="hljs-number">1</span>] &#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCousins</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">dfs</span>(root, x, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">dfs</span>(root, y, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] != b[<span class="hljs-number">0</span>] &amp;&amp; a[<span class="hljs-number">1</span>] == b[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>


      
       <hr><span style="font-style: italic;color: gray;"> 向阳而生, 喜欢聪明的人. </span>
    </div>
</article>







    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©B1ueDrops
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
