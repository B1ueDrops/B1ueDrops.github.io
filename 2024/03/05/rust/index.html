<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>rust阅读学习 | B1ueDrops</title>
  <meta name="keywords" content="">
  <meta name="description" content="rust阅读学习 | B1ueDrops">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="变量栈&#x2F;堆 基本类型的值存储在线程的栈上, 因为基本类型大小固定, 并且栈的存储&#x2F;访问速度一般快.  基本类型有: 整数, 浮点, 字符, 以及仅包含它们的元组.   非基本类型存储在堆上, 因为非基本类型一般大小在编译时期不固定, 在栈中会存储数据在堆中地址.   可变&#x2F;不可变 对于一个变量, 如果你要修改它的某些值, 那么它就是可变变量, 需要用mut.  所有权">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust系统总结">
<meta property="og:url" content="https://b1uedrops.github.io/2024/04/01/rust_system/index.html">
<meta property="og:site_name" content="B1ueDrops">
<meta property="og:description" content="变量栈&#x2F;堆 基本类型的值存储在线程的栈上, 因为基本类型大小固定, 并且栈的存储&#x2F;访问速度一般快.  基本类型有: 整数, 浮点, 字符, 以及仅包含它们的元组.   非基本类型存储在堆上, 因为非基本类型一般大小在编译时期不固定, 在栈中会存储数据在堆中地址.   可变&#x2F;不可变 对于一个变量, 如果你要修改它的某些值, 那么它就是可变变量, 需要用mut.  所有权">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-04-01T11:24:52.360Z">
<meta property="article:modified_time" content="2024-04-01T13:27:40.396Z">
<meta property="article:author" content="B1ueDrops">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpeg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpeg"/>
</a>
<div class="author">
    <span>B1ueDrops</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/B1ueDrops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:bluedrops@yeah.net"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2381446488&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(33)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="编程语言">
            
            编程语言
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="并发编程">
            
            并发编程
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="工具/环境">
            
            工具/环境
            <small>(8)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="软件工程">
            
            软件工程
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(8)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="AI">
            
            AI
            <small>(1)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="English">
            
            English
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="33">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All 编程语言 "
           href="/2024/04/01/rust_system/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust系统总结">Rust系统总结</span>
            <span class="post-date" title="2024-04-01 19:24:52">2024/04/01</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/30/binary-tree/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二叉树/二叉搜索树全系列">二叉树/二叉搜索树全系列</span>
            <span class="post-date" title="2024-03-30 17:07:34">2024/03/30</span>
        </a>
        
        
        <a  class="All 并发编程 "
           href="/2024/03/30/multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多线程编程模型">多线程编程模型</span>
            <span class="post-date" title="2024-03-30 16:47:20">2024/03/30</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/30/profile/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="软件的性能分析">软件的性能分析</span>
            <span class="post-date" title="2024-03-30 13:49:01">2024/03/30</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/28/linkedlist/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="链表系列">链表系列</span>
            <span class="post-date" title="2024-03-28 09:53:10">2024/03/28</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/24/data-struct/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构系列">数据结构系列</span>
            <span class="post-date" title="2024-03-24 14:10:22">2024/03/24</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/23/vscode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="vscode插件配置">vscode插件配置</span>
            <span class="post-date" title="2024-03-23 15:50:58">2024/03/23</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/command_line/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shell脚本现用现学">Shell脚本现用现学</span>
            <span class="post-date" title="2024-03-22 12:50:32">2024/03/22</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/cpp-many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="C++之用到什么学什么">C++之用到什么学什么</span>
            <span class="post-date" title="2024-03-22 11:31:11">2024/03/22</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/21/prefix-sum-sub/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前缀和差分系列">前缀和差分系列</span>
            <span class="post-date" title="2024-03-21 15:44:29">2024/03/21</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/linear-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性动态规划系列">线性动态规划系列</span>
            <span class="post-date" title="2024-03-20 18:11:22">2024/03/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/tree-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="树形动态规划系列">树形动态规划系列</span>
            <span class="post-date" title="2024-03-20 18:10:56">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-method/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Methodology">英语科技论文写作模型-Methodology</span>
            <span class="post-date" title="2024-03-20 16:53:17">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-abstract/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Abstract">英语科技论文写作模型-Abstract</span>
            <span class="post-date" title="2024-03-20 16:49:54">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-conclusion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Conclusion">英语科技论文写作模型-Conclusion</span>
            <span class="post-date" title="2024-03-20 16:49:46">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-results/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Results">英语科技论文写作模型-Results</span>
            <span class="post-date" title="2024-03-20 16:49:31">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/19/sci-writing-introduction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Introduction">英语科技论文写作模型-Introduction</span>
            <span class="post-date" title="2024-03-19 10:16:07">2024/03/19</span>
        </a>
        
        
        <a  class="All AI "
           href="/2024/03/10/ai-cnn/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CNN的一些基础知识">CNN的一些基础知识</span>
            <span class="post-date" title="2024-03-10 15:57:42">2024/03/10</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/10/catalan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡特兰数系列">卡特兰数系列</span>
            <span class="post-date" title="2024-03-10 12:47:19">2024/03/10</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/05/rust/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="rust阅读学习">rust阅读学习</span>
            <span class="post-date" title="2024-03-05 20:58:51">2024/03/05</span>
        </a>
        
        
        <a  class="All 并发编程 "
           href="/2024/03/05/concurrent_sketch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="并发编程的概述">并发编程的概述</span>
            <span class="post-date" title="2024-03-05 15:00:50">2024/03/05</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/03/knapsack/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="背包问题的模板总结">背包问题的模板总结</span>
            <span class="post-date" title="2024-03-03 16:22:21">2024/03/03</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/02/jetbrains/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jetbrains系列IDE的配置">Jetbrains系列IDE的配置</span>
            <span class="post-date" title="2024-03-02 19:00:15">2024/03/02</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/03/02/tmux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tmux键位配置">tmux键位配置</span>
            <span class="post-date" title="2024-03-02 13:16:32">2024/03/02</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/01/clean_code/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码整洁之道">代码整洁之道</span>
            <span class="post-date" title="2024-03-01 14:30:08">2024/03/01</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/03/01/software_rule/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面向对象设计的基本原则">面向对象设计的基本原则</span>
            <span class="post-date" title="2024-03-01 14:30:02">2024/03/01</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/29/lazygit/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="lazygit的一些常见用法">lazygit的一些常见用法</span>
            <span class="post-date" title="2024-02-29 17:44:04">2024/02/29</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/28/yabai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="yabai窗口管理器键位配置">yabai窗口管理器键位配置</span>
            <span class="post-date" title="2024-02-28 13:01:35">2024/02/28</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/27/joshuto/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="joshuto的键位配置">joshuto的键位配置</span>
            <span class="post-date" title="2024-02-27 19:43:49">2024/02/27</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/27/neovim/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Neovim/Nvchad键位配置">Neovim/Nvchad键位配置</span>
            <span class="post-date" title="2024-02-27 19:40:03">2024/02/27</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/02/26/behaviour_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="行为型的设计模式">行为型的设计模式</span>
            <span class="post-date" title="2024-02-26 20:11:27">2024/02/26</span>
        </a>
        
        
        <a  class="All 工具/环境 "
           href="/2024/02/26/vimium/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Chrome中vimium键位">Chrome中vimium键位</span>
            <span class="post-date" title="2024-02-26 20:03:26">2024/02/26</span>
        </a>
        
        
        <a  class="All 软件工程 "
           href="/2024/02/25/build_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创建型的设计模式">创建型的设计模式</span>
            <span class="post-date" title="2024-02-25 15:27:36">2024/02/25</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-rust" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">rust阅读学习</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="编程语言">编程语言</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-04-01 19:20:11'>2024-03-05 20:58</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#rust%E5%9F%BA%E7%A1%80"><span class="toc-text">rust基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rust%E5%B7%A5%E5%85%B7"><span class="toc-text">rust工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cargo%E7%94%A8%E6%B3%95"><span class="toc-text">cargo用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E6%80%A7-%E5%BC%95%E7%94%A8-%E6%89%80%E6%9C%89%E6%9D%83"><span class="toc-text">可变性, 引用, 所有权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%BB%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">元组结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rust%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-text">rust的闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rust%E6%89%80%E6%9C%89%E6%9D%83%E8%BD%AC%E7%A7%BB"><span class="toc-text">rust所有权转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%A8%A1%E5%9D%97%E7%BC%96%E7%A8%8B"><span class="toc-text">分模块编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E6%81%A2%E5%A4%8D%E5%BC%82%E5%B8%B8"><span class="toc-text">不可恢复异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%81%A2%E5%A4%8D%E5%BC%82%E5%B8%B8"><span class="toc-text">可恢复异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rust%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">rust面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rust%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-text">rust高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84trait"><span class="toc-text">常见的trait</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Deref"><span class="toc-text">Deref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Drop"><span class="toc-text">Drop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Box"><span class="toc-text">Box&lt;T&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rc"><span class="toc-text">Rc&lt;T&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arc"><span class="toc-text">Arc&lt;T&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mutex"><span class="toc-text">Mutex</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-text">异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#async-await"><span class="toc-text">async&#x2F;await</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AAFuture%E4%B9%8B%E9%97%B4%E5%B9%B6%E5%8F%91"><span class="toc-text">多个Future之间并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">一个简单的例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rust%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5"><span class="toc-text">rust开发实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TDD%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91"><span class="toc-text">TDD测试驱动开发</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="rust基础"><a href="#rust基础" class="headerlink" title="rust基础"></a>rust基础</h2><h3 id="rust工具"><a href="#rust工具" class="headerlink" title="rust工具"></a>rust工具</h3><ul>
<li>rustup: 安装Rust, 以及切换Rust和标准库的版本.</li>
<li>cargo: Rust包管理器.</li>
</ul>
<h3 id="cargo用法"><a href="#cargo用法" class="headerlink" title="cargo用法"></a>cargo用法</h3><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li><code>let z = 10</code>, 其中, 这个<code>z</code>的类型会推导成<code>i32</code>.</li>
<li>强制类型转换用<code>as</code>: <code>let v: u16 = 38_u8 as u16;</code></li>
<li><code>x</code>位无符号整数最大值是$2^x - 1$, 最小值是0.</li>
<li><code>x</code>位有符号整数最大值是$2^{x-1}-1$, 最小值是$-2^{x-1}$​.</li>
</ul>
<h3 id="可变性-引用-所有权"><a href="#可变性-引用-所有权" class="headerlink" title="可变性, 引用, 所有权"></a>可变性, 引用, 所有权</h3><ul>
<li><p>最基础的一点, rust如果变量想要可变, 需要前面加上<code>mut</code>.</p>
</li>
<li><p>假设一个变量叫<code>a</code>, 是可变的, 你想取它的引用, 那么需要这样写: <code>&amp;mut a</code>, 而不是<code>&amp;a</code>.</p>
</li>
<li><p>引用可以实现<font color="red">所有权的借用(borrow)</font>, 借用规则是:</p>
<ul>
<li><p>同一个作用域内, 可以有多个不可变引用, 但是只能有一个可变引用.</p>
</li>
<li><p>不能对一个不可变的值进行可变借用, 例如下面代码是错误的:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">y</span> = &amp;<span class="hljs-keyword">mut</span> x;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>一个提醒: 如果你见到一个函数传参数不是传的引用, 那么就需要考虑<strong>所有权转移</strong>的问题.</p>
</li>
<li><p>数组索引, 一般都要用引用取, 例如<code>let query = &amp;args[1]</code>.</p>
</li>
</ul>
<h3 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h3><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Color</span>(<span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>, <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">black</span> = <span class="hljs-title function_ invoke__">Color</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 获取第0, 1, 2个元素</span><br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, black.<span class="hljs-number">0</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, black.<span class="hljs-number">1</span>);<br><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, black.<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>





<h3 id="rust的闭包"><a href="#rust的闭包" class="headerlink" title="rust的闭包"></a>rust的闭包</h3><p>格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">|参数1, 参数2, ...| -&gt; 返回值类型 &#123;<br>    // 函数体<br>&#125;<br></code></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">func</span> = |num: <span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> &#123;<br>    num + <span class="hljs-number">1</span><br>  &#125;;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-title function_ invoke__">func</span>(<span class="hljs-number">2</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>没有参数&#x2F;返回值的闭包可以当作线程函数, 写法是:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust">|| &#123;<br>  <span class="hljs-comment">// 线程逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="rust所有权转移"><a href="#rust所有权转移" class="headerlink" title="rust所有权转移"></a>rust所有权转移</h3><p>常见的有以下场景:</p>
<ol>
<li><p>非基本类型赋值:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1;<br><span class="hljs-comment">// 此时s1所有权给了s2, s1不能被使用</span><br><span class="hljs-comment">// 如果真要共享, 使用引用 let s2 = &amp;s1;</span><br><span class="hljs-comment">// 如果只需要s1的值, 可以用let s2 = s1.clone()</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>非基本类型作为函数参数:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br><span class="hljs-title function_ invoke__">function</span>(s1);<br><span class="hljs-comment">// 此处, s1会失效, 不能再次使用.</span><br></code></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>内部原理</p>
</blockquote>
<ul>
<li>首先, 基本类型完全存储在栈上, rust会直接拷贝, 不会发生所有权转移.</li>
<li>非基本类型数据存储在堆上, 引用存储在栈上, rust处于安全考虑, 会让原来的所有权失效.</li>
<li>堆上数据深拷贝可以用<code>clone</code>方法.</li>
</ul>
<h3 id="分模块编程"><a href="#分模块编程" class="headerlink" title="分模块编程"></a>分模块编程</h3><p>rust中, 一个package可以分为多个binary crate和至多一个libary crate:</p>
<ul>
<li>crate root是<code>src/main.rs</code>和<code>src/lib.rs</code>.</li>
<li>rust编译器只能看到crate root.</li>
</ul>
<p>一般来说, 你需要在crate root中声明依赖的模块, 然后再用<code>use</code>导入元素:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// src/main.rs或src/lib.rs</span><br><span class="hljs-comment">// 声明crate(main.rs)所依赖的module</span><br><span class="hljs-keyword">mod</span> A;<br><span class="hljs-keyword">mod</span> B;<br><span class="hljs-keyword">mod</span> C;<br><br><span class="hljs-keyword">use</span> A::funcA;<br></code></pre></td></tr></table></figure>

<p>对于模块, 你只需要理解下面几点:</p>
<ul>
<li>一个<code>rs</code>文件是一个模块, 其中的元素你可以用<code>pub</code>导出.</li>
<li>一个文件夹中, 你需要创建<code>mod.rs</code>, 然后在其中用<code>pub mod XX;</code>来将文件夹中的所有rust文件导出.</li>
<li>在crate root中需要用<code>mod XX;</code>声明上级模块.</li>
<li>如果在子模块中需要导入上级模块的东西, 可以用<code>use package名字::XXX</code>导入.</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>Rust中的异常分为两类:</p>
<ul>
<li><strong>可恢复异常</strong>: 用<code>Result&lt;T, E&gt;</code>恢复.</li>
<li>**不可恢复异常: **用<code>panic!()</code>处理.</li>
</ul>
<h4 id="不可恢复异常"><a href="#不可恢复异常" class="headerlink" title="不可恢复异常"></a>不可恢复异常</h4><ul>
<li><p><code>panic!()</code>如果在main线程中, 会直接停止main线程, 但是在子线程中panic不会让main线程挂, 因此不要让main线程承担大多数任务.</p>
</li>
<li><p><code>panic</code>有两种退出模式:</p>
<ul>
<li><p>栈回溯(backtrace): 退出时打印调用栈, 可以用在开发环境.</p>
</li>
<li><p>终止(abort): 直接退出, 适合生产环境, 能减少编译出的二进制文件大小.</p>
<figure class="highlight toml"><table><tr><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[profile.release]</span><br><span class="hljs-attr">panic</span> = <span class="hljs-string">&#x27;abort&#x27;</span><br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="可恢复异常"><a href="#可恢复异常" class="headerlink" title="可恢复异常"></a>可恢复异常</h4><p>一般来说, 可能存在异常的函数返回值都是<code>Result&lt;T, E&gt;</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Result</span>&lt;T, E&gt; &#123;<br>    <span class="hljs-title function_ invoke__">Ok</span>(T),<br>    <span class="hljs-title function_ invoke__">Err</span>(E),<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个类型之后可以用<code>unwrap()</code>或者<code>expect()</code>处理, 两者类似, 区别在于<code>expect()</code>可以接受一个字符串, panic后打印这个字符串信息:</p>
<ul>
<li><code>unwrap/expect</code>: 如果成功, 直接返回返回值, 如果失败, 直接<code>panic</code>.</li>
<li>这是异常处理最快的方法.</li>
</ul>
<blockquote>
<p>处理方法1: Match表达式</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>) &#123;<br>    	<span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>    	<span class="hljs-title function_ invoke__">Error</span>(error) =&gt; &#123;<br>        <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Cannot read file&quot;</span>);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以在<code>Error</code>后再用Match表达式处理:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io::ErrorKind;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>);<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> f &#123;<br>        <span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>        <span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-keyword">match</span> error.<span class="hljs-title function_ invoke__">kind</span>() &#123;<br>            ErrorKind::NotFound =&gt; <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">create</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>) &#123;<br>                <span class="hljs-title function_ invoke__">Ok</span>(fc) =&gt; fc,<br>                <span class="hljs-title function_ invoke__">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem creating the file: &#123;:?&#125;&quot;</span>, e),<br>            &#125;,<br>            other_error =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;Problem opening the file: &#123;:?&#125;&quot;</span>, other_error),<br>        &#125;,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>也可以直接不处理, 向上传播异常:</p>
<ul>
<li>原函数需要返回<code>Result&lt;T, E&gt;</code></li>
<li>match表达式如果是<code>Error</code>, 需要<code>return Err(error)</code>.</li>
</ul>
<p>Rust提供了专门的宏<code>?</code>来简化传播异常的写法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个写法就等价于:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs::File;<br><span class="hljs-keyword">use</span> std::io;<br><span class="hljs-keyword">use</span> std::io::Read;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">read_username_from_file</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;<span class="hljs-type">String</span>, io::Error&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">f</span> = <span class="hljs-keyword">match</span> File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>) &#123;<br>      	<span class="hljs-title function_ invoke__">Ok</span>(file) =&gt; file,<br>      	<span class="hljs-title function_ invoke__">Err</span>(error) =&gt; <span class="hljs-title function_ invoke__">Err</span>(error)<br>  	&#125;;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>?相比于match表达式, 还有另一种好处.</p>
</blockquote>
<ul>
<li><p><code>?</code>传播的异常, 返回的本质上是<code>Box&lt;dyn std::error:Error&gt;</code>类型.</p>
</li>
<li><p>在一个系统中, 你可以基于<code>Error</code>, 自定义异常.</p>
</li>
<li><p>自定义的异常需要实现<code>From</code> trait中的<code>from</code>函数, 用来转换到更大的异常类型.</p>
</li>
<li><p>这样, 在使用<code>?</code>时, rust就会根据你的签名, 自动给你转换到对应级别的异常.</p>
</li>
<li><p><code>Option&lt;T&gt;</code>也支持<code>?</code>.</p>
</li>
</ul>
<p>如果在main函数中使用了<code>?</code>, 那么main函数的签名需要改动:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::error::Error;<br><span class="hljs-keyword">use</span> std::fs::File;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;(), <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Error&gt;&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">f</span> = File::<span class="hljs-title function_ invoke__">open</span>(<span class="hljs-string">&quot;hello.txt&quot;</span>)?;<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>首先, 生命周期是对引用而言的, 定义为引用有效的作用域.</p>
<p>在rust中, 有时候需要显式标注生命周期, 考虑一个函数, 用来返回长度较长的字符串引用, 可以这么写:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>(x: &amp;<span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>  <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>    x<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    y<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个函数的返回是引用类型, 但是, 如果一个函数的返回类型是引用, 那么返回值的生命周期只可能取决于三个因素:</p>
<ul>
<li>函数参数的生命周期.</li>
<li>函数内部新建引用的生命周期.</li>
</ul>
<p>如果是后者, 那么就会出现Dangling References, 因为函数内部新建的引用在函数结束后就会失效.</p>
<p>如果是前者, rust需要在编译时期就知道返回值(引用)的生命周期到底和哪个参数的生命周期一致, 在这个函数中, 他显然不知道, 因为返回值取决于运行时结果, 因此就需要<strong>标注生命周期</strong>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>  <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>    x<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    y<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个标注的意思是, <strong>返回值的生命周期小于等于参数生命周期中最小的那个</strong>, 使用标注后, 下面的代码就会报错:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>);<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span>;<br>  &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xyz&quot;</span>);<br>    result = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(), str2.<span class="hljs-title function_ invoke__">as_str</span>());<br>  &#125;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为返回值的作用域比参数的作用域大.</p>
<p>同样, 结构体也可以使用这种标注语法:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcerpt</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个标注表示, <strong>结构体引用的生命周期要等于成员引用生命周期最小的那个</strong>.</p>
<p>Rust会用三条规则进行生命周期消除:</p>
<ul>
<li>每一个引用参数都有自己的生命周期.</li>
<li>如果只有一个输入生命周期, 那么返回值的生命周期至少等于这个生命周期.</li>
<li>如果有多个输入生命周期, 切其中一个是<code>&amp;self/&amp;mut self</code>, 那么返回值生命周期小于等于<code>&amp;self/&amp;mut</code>的生命周期.</li>
</ul>
<p>如果Rust发现你的代码并不符合这三条中的任何一个, 那么就会让你手动标注.</p>
<p>Rust中有一个特殊的生命周期是<code>&#39;static</code>, 这个生命周期和程序活得一样久, 会被编码到二进制文件中.</p>
<h2 id="rust面向对象"><a href="#rust面向对象" class="headerlink" title="rust面向对象"></a>rust面向对象</h2><ol>
<li>大致写法:</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 成员变量</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-keyword">pub</span> name: <span class="hljs-type">String</span>,<br>  age: <span class="hljs-type">i8</span><br>&#125;<br><br><span class="hljs-comment">// 成员方法</span><br><span class="hljs-comment">// impl可以不用pub, 但是成员方法要pub</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Student</span> &#123;<br>  <span class="hljs-comment">// 构造方法, 也是类方法</span><br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(name: <span class="hljs-type">String</span>, age: <span class="hljs-type">i8</span>) <span class="hljs-punctuation">-&gt;</span> Student &#123;<br>    Student &#123;<br>      name: name,<br>      age: age<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// public</span><br>  <span class="hljs-comment">// 如果需要改成员变量, 用&amp;mut self</span><br>  <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_age</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i8</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.age;<br>  &#125;<br>  <span class="hljs-comment">// private</span><br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">haha</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>    <br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  <span class="hljs-comment">// 创建对象</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">student</span> = Student::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;haha&quot;</span>), <span class="hljs-number">18</span>);<br>  student.<span class="hljs-title function_ invoke__">get_age</span>();<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="rust高级特性"><a href="#rust高级特性" class="headerlink" title="rust高级特性"></a>rust高级特性</h2><h3 id="常见的trait"><a href="#常见的trait" class="headerlink" title="常见的trait"></a>常见的trait</h3><h4 id="Deref"><a href="#Deref" class="headerlink" title="Deref"></a>Deref</h4><p>Deref是一个有关于解引用的trait.</p>
<p>假设我有一个结构体:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt;(T);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(x: T) <span class="hljs-punctuation">-&gt;</span> MyBox&lt;T&gt; &#123;<br>    <span class="hljs-title function_ invoke__">MyBox</span>(x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在, 你可以为这个结构体实现<code>Deref</code> 这个trait, 来让你能<code>*</code>一个结构体引用.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::ops::Deref;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyBox</span>&lt;T&gt; &#123;<br>  <span class="hljs-comment">// &amp;self是结构体引用类型, 在这个函数中, 你要通过这个结构体引用, find一个基本类型的引用, 然后返回</span><br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>    &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>本质上, <code>deref</code>会把一个结构体引用, 转换成一个基本类型引用.</p>
<p>实现&#96;&#96;deref<code>后, 你再</code><em><code>一个结构体引用</code>x<code>, 就等价于</code></em>(x.deref())&#96;</p>
<blockquote>
<p>自动deref机制</p>
</blockquote>
<p>看这段代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">display</span>(s: &amp;<span class="hljs-type">str</span>) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,s);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = MyBox::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>));<br>    <span class="hljs-title function_ invoke__">display</span>(&amp;s)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于<code>&amp;s</code>, 它会被连续<code>deref</code> , 直到转换成<code>&amp;str</code>为止.</p>
<p>在Rust中, 引用类型其实不用你手动<code>*</code>才能访问值, 例如你有一个结构体引用, 你不用<code>(*x).name</code>才能访问成员, 而是直接用<code>x.name</code>就可以, 背后的机制就是<code>deref trait</code>.</p>
<h4 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h4><p>Drop是一个<code>trait</code>, 如果一个结构体实现了<code>Drop</code>, 那么它的生命周期结束之后, 就会自动调用<code>drop</code>方法实现收尾工作, rust就是因为这个才可以不实现<code>GC</code>.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">XXX</span> &#123;<br>  <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是, 在这段代码中, <code>drop</code>的参数是<code>&amp;mut self</code>, 就表示一个结构体调用<code>drop</code>函数后, 它的所有权没有被收走.</p>
<ul>
<li>因此, 你不可以对一个结构体<code>x</code>显示地调用<code>x.drop()</code>函数.</li>
</ul>
<p>但是, 有些场景下, 你需要提前释放某些资源, 例如互斥锁等, 这个时候可以使用<code>std::prelude::drop</code>函数.</p>
<p>这个函数签名是:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>&lt;T&gt;(_x: T)<br></code></pre></td></tr></table></figure>

<p>会直接把所有权拿走, 调用完这个函数, 如果在下面再使用原变量, 就会编译错误.</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="Box"><a href="#Box" class="headerlink" title="Box&lt;T&gt;"></a>Box&lt;T&gt;</h4><p>Box指针本质上还是引用类型, 只是这个引用会把你原本的数据放到堆上, 然后再给你返回一个引用.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// a数据存在3上</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>

<p>如果你想打印<code>a</code>:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, a);<br></code></pre></td></tr></table></figure>

<p>这时可以打印, 并且不会报错的, 因为<code>a</code>会隐式调用<code>deref</code>进行解引用.</p>
<p>但是如果你想拿这个值做运算:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = a + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>这就会报错, 正确写法是<code>let b = *a + 1</code>, 这个时候需要手动调用<code>deref</code>.</p>
<p><font color="red">注意: Box指针会导致所有权的转移</font>, <code>Box::new(xxx)</code>之后, <code>xxx</code>的所有权会转移到接收变量中.</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello, world&quot;</span>);<br>    <span class="hljs-comment">// s在这里被转移给a</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(s);<br>    <span class="hljs-comment">// 报错！此处继续尝试将 s 转移给 b</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>Box指针有一个非常有效的应用场景:</strong></p>
<ul>
<li>在Rust中, 编译器要求类型的大小必须是固定的.</li>
<li>但是有些类型是无法在编译时期知道大小的, 例如递归的类型定义.</li>
<li>这时, 可以将递归的成员变量转换成<code>Box&lt;T&gt;</code>指针类型.</li>
</ul>
<p>例如, 如果你想用一个数组, 存储所有实现了某一个<code>trait</code>的对象(动态类型), 就需要用到<code>Box</code>指针, 例子如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Draw</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">draw</span>(&amp;<span class="hljs-keyword">self</span>);<br>&#125;<br><span class="hljs-comment">// 下面Button和Select都实现了Draw这个trait</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Button</span> &#123;<br>    id: <span class="hljs-type">u32</span><br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Draw</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">draw</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Button &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.id);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Select</span> &#123;<br>    id: <span class="hljs-type">u32</span><br>&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Draw</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Select</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">draw</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Select &#123;&#125;&quot;</span>, <span class="hljs-keyword">self</span>.id)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  	<span class="hljs-comment">// 定义类型时需要加上dyn, 因为实现trait的对象都是一个动态类型</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">elems</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Draw&gt;&gt; = <span class="hljs-built_in">vec!</span>[ <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Button &#123;id:<span class="hljs-number">1</span>&#125;), <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Select &#123;id: <span class="hljs-number">1</span>&#125;) ];<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">e</span> <span class="hljs-keyword">in</span> elems &#123;<br>        e.<span class="hljs-title function_ invoke__">draw</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果你要从Box指针数组中取出元素时, 你需要解两次引用, 例如下面这个例子:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = <span class="hljs-built_in">vec!</span>[ <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>), <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">2</span>) ];<br>    <span class="hljs-comment">// 注意, 这里必须取引用, 否则会发生所有权转移</span><br>    <span class="hljs-keyword">let</span> (first, second) = (&amp;arr[<span class="hljs-number">0</span>], &amp;arr[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">// 第一次将&amp;Box&lt;i32&gt;转成Box&lt;i32&gt;, 第二次将Box&lt;i32&gt;转成i32</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">sum</span> = **first + **second;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Rc"><a href="#Rc" class="headerlink" title="Rc&lt;T&gt;"></a>Rc&lt;T&gt;</h4><p>Rc&lt;T&gt;可以在单线程环境下, 创建一个数据的多个不可变引用, 并且提供了如下功能:</p>
<ul>
<li>实现了<code>Deref</code>和<code>Drop</code>.</li>
<li>提供了引用计数(reference counting), 一旦数据的引用计数是0, 就会自动释放.</li>
</ul>
<p>用法如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::rc::Rc;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  	<span class="hljs-comment">// 用Rc::new创建一个数据的引用, 类型是Rc&lt;String&gt;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Rc::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello world&quot;</span>));<br>  	<span class="hljs-comment">// 用Rc::clone创建数据的新的不可变引用, 这个clone是浅拷贝, 性能比较高</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = Rc::<span class="hljs-title function_ invoke__">clone</span>(&amp;a);<br>		<span class="hljs-comment">// 用Rc::strong_count输出变量的计数</span><br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">2</span>, Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>    <span class="hljs-built_in">assert_eq!</span>(Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a), Rc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;b));<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="Arc"><a href="#Arc" class="headerlink" title="Arc&lt;T&gt;"></a>Arc&lt;T&gt;</h4><p>Arc&lt;T&gt;可以在多线程环境下, 实现多个线程拥有同一个数据的多个不可变引用, 和<code>Rc&lt;T&gt;</code>的API完全相同.</p>
<ul>
<li>和<code>Rc&lt;T&gt;</code>不同之处在于, <code>Arc&lt;T&gt;</code>采用原子指令维护了引用计数, 会有一定的性能损耗.</li>
</ul>
<h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h4><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><h4 id="async-await"><a href="#async-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h4><ul>
<li>Rust中, 使用<code>async</code>定义的函数, 调用后会变成<code>Future</code>.</li>
<li><code>Future</code>需要一个执行器(executor)来执行.</li>
<li>当<code>Future</code>执行被阻塞后, 它会让出当前线程的控制权, 来执行其他<code>Future</code>, 不会导致整个线程被阻塞.</li>
<li>在一个<code>async</code>函数中, 调用另一个<code>async</code>函数可以对<code>Future</code>调用<code>await</code>, <code>await</code>会建立<code>Future</code>之间的依赖关系.<ul>
<li>因此, 执行<code>async</code>有两种方式:<ul>
<li>第一, 使用Executor.</li>
<li>第二, 在<code>async</code>函数中使用<code>.await</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="多个Future之间并发"><a href="#多个Future之间并发" class="headerlink" title="多个Future之间并发"></a>多个Future之间并发</h4><p>对于下面的代码:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">book</span>() &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;book&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dance</span>() &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;dance&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">async_main</span>() &#123;<br>  <span class="hljs-title function_ invoke__">book</span>().<span class="hljs-keyword">await</span><br>  <span class="hljs-title function_ invoke__">dance</span>().<span class="hljs-keyword">await</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>此处, 由于<font color="red">await是有顺序限制的</font>, <code>book</code>和<code>dance</code>之间并不是并行.</p>
<p>如果想让<code>book</code>和<code>dance</code>两个函数并发, 需要用到<code>future::join</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> futures::join;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">book</span>() &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;book&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">dance</span>() &#123;<br>  <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;dance&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">async_main</span>() &#123;<br>  join!(<span class="hljs-title function_ invoke__">book</span>(), <span class="hljs-title function_ invoke__">dance</span>());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要执行的<code>Future</code>很多, 那么可以把<code>Future</code>放到一个数组中, 然后调用<code>futures::future::join_all</code>.</p>
<h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::time::Duration;<br><span class="hljs-keyword">use</span> futures::executor::block_on;<br><span class="hljs-keyword">use</span> async_std::task;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">hello_world</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;hello world!&quot;</span>);<br>  <span class="hljs-comment">// 这里异步sleep后, 会调度到niubi</span><br>    task::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1000</span>)).<span class="hljs-keyword">await</span>;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;aba&quot;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">niubi</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;niubi&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">async_main</span>() &#123;<br>  <span class="hljs-comment">// async_main等待两个任务完成, 两个任务独立</span><br>    futures::join!(<span class="hljs-title function_ invoke__">hello_world</span>(), <span class="hljs-title function_ invoke__">niubi</span>());<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-title function_ invoke__">block_on</span>(<span class="hljs-title function_ invoke__">async_main</span>())<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="rust开发实践"><a href="#rust开发实践" class="headerlink" title="rust开发实践"></a>rust开发实践</h2><ul>
<li><p><code>dbg!()</code>: 快速打印变量&#x2F;表达式, 方便调试.</p>
</li>
<li><p>基础命令行参数读取:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::env;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">args</span>:<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = env::<span class="hljs-title function_ invoke__">args</span>().<span class="hljs-title function_ invoke__">collect</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">arg</span> <span class="hljs-keyword">in</span> args &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>读文件:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fs;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>  	<span class="hljs-comment">// 读取到String中</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">text</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(<span class="hljs-string">&quot;D:\\text.txt&quot;</span>).<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;文件读取失败的错误信息&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, text);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>if let</code>表达式简化代码: </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 简化异常处理</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Err</span>(e) = <span class="hljs-title function_ invoke__">run</span>(config) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Application error &#123;&#125;&quot;</span>, e);<br>    process::<span class="hljs-title function_ invoke__">exit</span>(<span class="hljs-number">1</span>);<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>实战来说, 一些顶层函数一般放到<code>lib.rs</code>中, <code>main.rs</code>一般保留最小的需要支持的元素和流程.</p>
</li>
</ul>
<h3 id="TDD测试驱动开发"><a href="#TDD测试驱动开发" class="headerlink" title="TDD测试驱动开发"></a>TDD测试驱动开发</h3><p>rust TDD的一般流程是:</p>
<ul>
<li><p>在<code>src</code>同级目录下创建<code>test</code>.</p>
</li>
<li><p>里面创建很多个rust文件, 随便起名.</p>
</li>
<li><p>每个文件的格式如下:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br><br>    <span class="hljs-keyword">use</span> package名字::*;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">two_result</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">query</span> = <span class="hljs-string">&quot;duct&quot;</span>;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">contents</span> = <span class="hljs-string">&quot;Rust:\nSafe duct\nniubi duct&quot;</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-built_in">vec!</span>[<span class="hljs-string">&quot;Safe duct&quot;</span>, <span class="hljs-string">&quot;niubi duct&quot;</span>], <span class="hljs-title function_ invoke__">search</span>(query, contents))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>#[cfg(test)]</code>表示只有在<code>cargo test</code>时才运行测试.</li>
<li><code>#[test]</code>表示单元测试.</li>
</ul>
</li>
<li><p>错误信息采用<code>eprintln</code>输出到<code>stderr</code>.</p>
</li>
</ul>
<p>之后只要运行<code>cargo test</code>就会运行所有单元测试.</p>
<p><font color="red">上述函数中, 无法对私有函数进行测试</font>, 如果真要对私有函数进行测试, 需要把测试函数<code>#[test]</code>写私有函数定义的地方.</p>

      
       <hr><span style="font-style: italic;color: gray;"> 向阳而生, 喜欢聪明的人. </span>
    </div>
</article>







    
        <!-- MathJax配置，可通过单美元符号书写行内公式等 -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    "HTML-CSS": {
        preferredFont: "TeX",
        availableFonts: ["STIX","TeX"],
        linebreaks: { automatic:true },
        EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
        inlineMath: [ ["$", "$"], ["\\(","\\)"] ],
        processEscapes: true,
        ignoreClass: "tex2jax_ignore|dno",
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        equationNumbers: { autoNumber: "AMS" },
        noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } },
        Macros: { href: "{}" }
    },
    messageStyle: "none"
    });
</script>
<!-- 给MathJax元素添加has-jax class -->
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<!-- 通过连接CDN加载MathJax的js代码 -->
<script type="text/javascript" async
        src="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<input type="hidden" id="MathJax-js"
        value="//cdn.jsdelivr.net/npm/mathjax@2.7.8/unpacked/MathJax.js?config=TeX-MML-AM_CHTML">
</input>
    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©B1ueDrops
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
