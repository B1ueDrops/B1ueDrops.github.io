<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>LeetCode-1000题题解 | B1ueDrops</title>
  <meta name="keywords" content="">
  <meta name="description" content="LeetCode-1000题题解 | B1ueDrops">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="向阳而生, 喜欢聪明的人.">
<meta property="og:type" content="website">
<meta property="og:title" content="B1ueDrops">
<meta property="og:url" content="https://b1uedrops.github.io/about.html">
<meta property="og:site_name" content="B1ueDrops">
<meta property="og:description" content="向阳而生, 喜欢聪明的人.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-02-09T08:49:59.399Z">
<meta property="article:modified_time" content="2024-02-09T08:49:59.394Z">
<meta property="article:author" content="B1ueDrops">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpeg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpeg"/>
</a>
<div class="author">
    <span>B1ueDrops</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/B1ueDrops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:bluedrops@yeah.net"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2381446488&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(93)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="编程语言">
            
            编程语言
            <small>(10)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="操作系统">
            
            操作系统
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="后端技术">
            
            后端技术
            <small>(19)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="金融知识">
            
            金融知识
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            
            开发工具
            <small>(6)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="控制基础">
            
            控制基础
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="脑机接口">
            
            脑机接口
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(24)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="体系结构">
            
            体系结构
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="AI-HPC">
            
            AI-HPC
            <small>(9)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="English">
            
            English
            <small>(9)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="93">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All 算法 "
           href="/2024/10/27/leetcode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LeetCode-1000题题解">LeetCode-1000题题解</span>
            <span class="post-date" title="2024-10-27 11:06:02">2024/10/27</span>
        </a>
        
        
        <a  class="All 金融知识 "
           href="/2024/10/14/economics/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="资源与可持续发展">资源与可持续发展</span>
            <span class="post-date" title="2024-10-14 12:41:46">2024/10/14</span>
        </a>
        
        
        <a  class="All 控制基础 "
           href="/2024/10/07/probability/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="概率论与数理统计">概率论与数理统计</span>
            <span class="post-date" title="2024-10-07 15:43:28">2024/10/07</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/09/27/jetbrains/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jetbrains系列IDE的使用方式">Jetbrains系列IDE的使用方式</span>
            <span class="post-date" title="2024-09-27 22:37:32">2024/09/27</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/22/x86_arch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="x86-CPU的体系结构基础">x86-CPU的体系结构基础</span>
            <span class="post-date" title="2024-09-22 13:23:27">2024/09/22</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/20/program_time/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="理解程序运行的时间">理解程序运行的时间</span>
            <span class="post-date" title="2024-09-20 14:22:52">2024/09/20</span>
        </a>
        
        
        <a  class="All 控制基础 "
           href="/2024/09/17/signal_process/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="信号与系统">信号与系统</span>
            <span class="post-date" title="2024-09-17 19:06:32">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/transformer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Transformer的工作原理">Transformer的工作原理</span>
            <span class="post-date" title="2024-09-17 14:16:16">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/fast-ai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="推理加速相关的评价指标">推理加速相关的评价指标</span>
            <span class="post-date" title="2024-09-17 14:16:00">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/pytorch_quant/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="模型量化的理论和实战">模型量化的理论和实战</span>
            <span class="post-date" title="2024-09-17 14:15:30">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/pytorch_arch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Pytorch的前后端架构">Pytorch的前后端架构</span>
            <span class="post-date" title="2024-09-17 14:15:03">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/ai_basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="构建AI模型理论与实战">构建AI模型理论与实战</span>
            <span class="post-date" title="2024-09-17 14:14:52">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/welford/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Welford算法计算方差">Welford算法计算方差</span>
            <span class="post-date" title="2024-09-17 14:14:12">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/data-augmentation-metric/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="理解数据增广的本质">理解数据增广的本质</span>
            <span class="post-date" title="2024-09-17 14:14:03">2024/09/17</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/09/10/design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="设计模式的实际操作">设计模式的实际操作</span>
            <span class="post-date" title="2024-09-10 18:29:51">2024/09/10</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/09/08/windows_msys2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Windows环境配置">Windows环境配置</span>
            <span class="post-date" title="2024-09-08 13:53:44">2024/09/08</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/09/06/network_application_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-应用层">计算机网络-应用层</span>
            <span class="post-date" title="2024-09-06 14:31:30">2024/09/06</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/09/06/network_tcp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-传输层">计算机网络-传输层</span>
            <span class="post-date" title="2024-09-06 14:31:18">2024/09/06</span>
        </a>
        
        
        <a  class="All 操作系统 "
           href="/2024/08/16/concurrent_sketch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="并发编程的概述">并发编程的概述</span>
            <span class="post-date" title="2024-08-16 13:48:22">2024/08/16</span>
        </a>
        
        
        <a  class="All 操作系统 "
           href="/2024/08/16/multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多进程/多线程编程模型">多进程/多线程编程模型</span>
            <span class="post-date" title="2024-08-16 13:48:12">2024/08/16</span>
        </a>
        
        
        <a  class="All 操作系统 "
           href="/2024/08/16/linux_process/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux上的进程控制">Linux上的进程控制</span>
            <span class="post-date" title="2024-08-16 13:48:03">2024/08/16</span>
        </a>
        
        
        <a  class="All 脑机接口 "
           href="/2024/08/16/ssvep_stimulus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SSVEP刺激设计">SSVEP刺激设计</span>
            <span class="post-date" title="2024-08-16 13:47:39">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/network_network_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-网络层">计算机网络-网络层</span>
            <span class="post-date" title="2024-08-16 13:46:58">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/network_datalink_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-数据链路层">计算机网络-数据链路层</span>
            <span class="post-date" title="2024-08-16 13:46:50">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/tcp_stick/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何解决TCP粘包问题">如何解决TCP粘包问题</span>
            <span class="post-date" title="2024-08-16 13:46:38">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/vimium/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Chrome中vimium键位">Chrome中vimium键位</span>
            <span class="post-date" title="2024-08-16 13:46:08">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/yabai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="yabai窗口管理器键位配置">yabai窗口管理器键位配置</span>
            <span class="post-date" title="2024-08-16 13:45:41">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/lazygit/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="试用LazyGit进行版本控制">试用LazyGit进行版本控制</span>
            <span class="post-date" title="2024-08-16 13:45:31">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/tmux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tmux键位配置">tmux键位配置</span>
            <span class="post-date" title="2024-08-16 13:45:09">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/build_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创建型的设计模式">创建型的设计模式</span>
            <span class="post-date" title="2024-08-16 13:35:12">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/behaviour_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="行为型的设计模式">行为型的设计模式</span>
            <span class="post-date" title="2024-08-16 13:35:00">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/combine_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="组合型的设计模式">组合型的设计模式</span>
            <span class="post-date" title="2024-08-16 13:33:52">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/dns/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DNS-客户端连接到机房的技术">DNS-客户端连接到机房的技术</span>
            <span class="post-date" title="2024-08-16 13:33:38">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/lvs_nginx/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LVS/Nginx-服务器调度的技术">LVS/Nginx-服务器调度的技术</span>
            <span class="post-date" title="2024-08-16 13:33:27">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/service_discovery/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="服务发现架构设计">服务发现架构设计</span>
            <span class="post-date" title="2024-08-16 13:33:15">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/storage_rpc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="存储微服务的架构">存储微服务的架构</span>
            <span class="post-date" title="2024-08-16 13:33:00">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/mq/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="消息中间件技术">消息中间件技术</span>
            <span class="post-date" title="2024-08-16 13:32:10">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/concurrent_arch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="高并发架构通用设计">高并发架构通用设计</span>
            <span class="post-date" title="2024-08-16 13:31:33">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/10/data_replication_center/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机房高可用技术">机房高可用技术</span>
            <span class="post-date" title="2024-08-10 20:04:18">2024/08/10</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/07/08/time_complexity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="时间复杂度">时间复杂度</span>
            <span class="post-date" title="2024-07-08 19:42:58">2024/07/08</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/07/05/parser/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="编译原理-Parser的知识合集">编译原理-Parser的知识合集</span>
            <span class="post-date" title="2024-07-05 16:29:19">2024/07/05</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/07/04/raii/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="资源管理中RAII的概念">资源管理中RAII的概念</span>
            <span class="post-date" title="2024-07-04 16:16:39">2024/07/04</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/07/04/char_encode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="字符集与字符编码的深度理解">字符集与字符编码的深度理解</span>
            <span class="post-date" title="2024-07-04 11:32:31">2024/07/04</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/07/04/ieee_754/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="体系结构中的浮点数">体系结构中的浮点数</span>
            <span class="post-date" title="2024-07-04 11:24:35">2024/07/04</span>
        </a>
        
        
        <a  class="All 控制基础 "
           href="/2024/06/02/quaternion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="描述旋转的几种方式">描述旋转的几种方式</span>
            <span class="post-date" title="2024-06-02 13:08:26">2024/06/02</span>
        </a>
        
        
        <a  class="All 控制基础 "
           href="/2024/06/01/linear_algebra/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性代数">线性代数</span>
            <span class="post-date" title="2024-06-01 15:30:18">2024/06/01</span>
        </a>
        
        
        <a  class="All 控制基础 "
           href="/2024/06/01/kalman/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡尔曼滤波数学推导">卡尔曼滤波数学推导</span>
            <span class="post-date" title="2024-06-01 14:10:10">2024/06/01</span>
        </a>
        
        
        <a  class="All 金融知识 "
           href="/2024/05/22/quant_analysis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="金融量化分析模型">金融量化分析模型</span>
            <span class="post-date" title="2024-05-22 18:08:38">2024/05/22</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/17/car-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="汽车英语">汽车英语</span>
            <span class="post-date" title="2024-05-17 13:37:34">2024/05/17</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/14/regular_expression/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="正则表达式原理和实战">正则表达式原理和实战</span>
            <span class="post-date" title="2024-05-14 20:14:59">2024/05/14</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/05/14/recursion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="递归系列">递归系列</span>
            <span class="post-date" title="2024-05-14 16:02:10">2024/05/14</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/13/restaurant_english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="饭店英语">饭店英语</span>
            <span class="post-date" title="2024-05-13 20:25:52">2024/05/13</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/12/frontend-lang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Javascript原理与实战">Javascript原理与实战</span>
            <span class="post-date" title="2024-05-12 21:13:45">2024/05/12</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/12/hotel-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="酒店英语">酒店英语</span>
            <span class="post-date" title="2024-05-12 12:29:02">2024/05/12</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/10/airport-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机场英语">机场英语</span>
            <span class="post-date" title="2024-05-10 10:12:57">2024/05/10</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/09/practical-go/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Go语言原理与实战">Go语言原理与实战</span>
            <span class="post-date" title="2024-05-09 20:48:25">2024/05/09</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/05/09/database-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostgreSQL数据库教程">PostgreSQL数据库教程</span>
            <span class="post-date" title="2024-05-09 20:24:37">2024/05/09</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/05/09/cache-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cache的基础知识与设计策略">Cache的基础知识与设计策略</span>
            <span class="post-date" title="2024-05-09 20:12:19">2024/05/09</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/05/09/sort-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="排序算法">排序算法</span>
            <span class="post-date" title="2024-05-09 17:10:04">2024/05/09</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/04/14/two_pointer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="双指针">双指针</span>
            <span class="post-date" title="2024-04-14 19:46:01">2024/04/14</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/13/practical-rust/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust原理与实战">Rust原理与实战</span>
            <span class="post-date" title="2024-04-13 17:05:26">2024/04/13</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/07/python_many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python原理与实战">Python原理与实战</span>
            <span class="post-date" title="2024-04-07 10:46:59">2024/04/07</span>
        </a>
        
        
        <a  class="All 脑机接口 "
           href="/2024/04/06/eeg_device/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="脑电的原理">脑电的原理</span>
            <span class="post-date" title="2024-04-06 10:35:04">2024/04/06</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/30/binary-tree/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二叉树系列">二叉树系列</span>
            <span class="post-date" title="2024-03-30 17:07:34">2024/03/30</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/28/linkedlist/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="链表系列">链表系列</span>
            <span class="post-date" title="2024-03-28 09:53:10">2024/03/28</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/24/data-struct/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构系列">数据结构系列</span>
            <span class="post-date" title="2024-03-24 14:10:22">2024/03/24</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/shell_script/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shell脚本基础与实战">Shell脚本基础与实战</span>
            <span class="post-date" title="2024-03-22 12:50:32">2024/03/22</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/modern_cpp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Modern C++基础与实战">Modern C++基础与实战</span>
            <span class="post-date" title="2024-03-22 11:31:11">2024/03/22</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/linear-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性DP">线性DP</span>
            <span class="post-date" title="2024-03-20 18:11:22">2024/03/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/tree-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="树形DP">树形DP</span>
            <span class="post-date" title="2024-03-20 18:10:56">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-method/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Methodology">英语科技论文写作模型-Methodology</span>
            <span class="post-date" title="2024-03-20 16:53:17">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-abstract/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Abstract">英语科技论文写作模型-Abstract</span>
            <span class="post-date" title="2024-03-20 16:49:54">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-conclusion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Conclusion">英语科技论文写作模型-Conclusion</span>
            <span class="post-date" title="2024-03-20 16:49:46">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-results/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Results">英语科技论文写作模型-Results</span>
            <span class="post-date" title="2024-03-20 16:49:31">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/19/sci-writing-introduction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Introduction">英语科技论文写作模型-Introduction</span>
            <span class="post-date" title="2024-03-19 10:16:07">2024/03/19</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/10/catalan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡特兰数系列">卡特兰数系列</span>
            <span class="post-date" title="2024-03-10 12:47:19">2024/03/10</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/03/knapsack/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="背包问题">背包问题</span>
            <span class="post-date" title="2024-03-03 16:22:21">2024/03/03</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/03/02/virtualmem/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="虚拟内存的基础知识和设计">虚拟内存的基础知识和设计</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/sim-plus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="高精度加减乘除">高精度加减乘除</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/prefix-sum-diff/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前缀和/差分">前缀和/差分</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/parathesis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="括号序列">括号序列</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/other-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="其他算法/模拟题">其他算法/模拟题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/mathematic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数学问题">数学问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/interval/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="区间问题">区间问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/greedy/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="贪心算法">贪心算法</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/graph/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="图论">图论</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/dfs/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深度优先搜索">深度优先搜索</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/03/02/cache-coherence/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="缓存一致性">缓存一致性</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/catch-rain/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="接雨水问题">接雨水问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/binary-search/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二分系列">二分系列</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/bfs/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="广度优先搜索">广度优先搜索</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/03/01/clean_code/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码整洁之道">代码整洁之道</span>
            <span class="post-date" title="2024-03-01 14:30:08">2024/03/01</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/03/01/software_rule/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面向对象设计的基本原则">面向对象设计的基本原则</span>
            <span class="post-date" title="2024-03-01 14:30:02">2024/03/01</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-leetcode" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">LeetCode-1000题题解</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="算法">算法</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-10-31 15:13:46'>2024-10-27 11:06</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-easy"><span class="toc-text">1. *两数之和(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-easy"><span class="toc-text">2. *两数相加 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-medium"><span class="toc-text">3. *无重复字符的最长子串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8-medium"><span class="toc-text">11. *盛水最多的容器(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">15. *三数之和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-medium"><span class="toc-text">17. *电话号码的字母组合(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-medium"><span class="toc-text">19. *删除链表的倒数第n个节点(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-easy"><span class="toc-text">20. *有效的括号(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">21. *合并两个有序的链表 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90-medium"><span class="toc-text">22. *括号生成(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-hard"><span class="toc-text">23. *合并K个升序链表(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-medium"><span class="toc-text">24. *两两交换链表中的节点(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-hard"><span class="toc-text">25. *K个一组反转链表(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5-medium"><span class="toc-text">34. *二分插入(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-easy"><span class="toc-text">35. *搜索插入位置(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-medium"><span class="toc-text">39. *组合总和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0-medium"><span class="toc-text">41. *缺失的第一个整数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-hard"><span class="toc-text">42. *接雨水(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII-medium"><span class="toc-text">45. *跳跃游戏II(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97-medium"><span class="toc-text">46. *全排列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-medium"><span class="toc-text">48. *旋转图像(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-medium"><span class="toc-text">49. *字母异位词(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N%E7%9A%87%E5%90%8E-hard"><span class="toc-text">51. *N皇后 (hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-medium"><span class="toc-text">53. *最大子数组和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-medium"><span class="toc-text">54. *螺旋矩阵(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-medium"><span class="toc-text">55. *跳跃游戏(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-medium"><span class="toc-text">56. *合并区间(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF-easy"><span class="toc-text">70. *爬楼梯 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6-medium"><span class="toc-text">73. *矩阵置零(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-text">74. 搜索二维矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-hard"><span class="toc-text">76. *最小覆盖子串(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86-medium"><span class="toc-text">78. *子集(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-medium"><span class="toc-text">79. *单词搜索(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-hard"><span class="toc-text">84. *柱状图中最大的矩形(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-easy"><span class="toc-text">94. *二叉树的中序遍历(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="toc-text">98. *验证二叉搜索树(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="toc-text">101. *对称二叉树(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">102. *二叉树的层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-easy"><span class="toc-text">104. *二叉树的最大深度(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-medium"><span class="toc-text">105. *从前序与中序遍历序列构造二叉树 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="toc-text">108. *将有序数组转换为二叉搜索树(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8-medium"><span class="toc-text">114. *二叉树展开为链表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-easy"><span class="toc-text">118. *杨辉三角(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-easy"><span class="toc-text">121. *买卖股票的最佳时机(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-hard"><span class="toc-text">124. *二叉树中的最大路径和(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97-medium"><span class="toc-text">128. *最长连续序列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-medium"><span class="toc-text">131. *分割回文串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">138. *随机链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">141. *环形链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II-medium"><span class="toc-text">142. *环形链表II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-medium"><span class="toc-text">144. 二叉树的前序遍历(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU%E7%BC%93%E5%AD%98-medium"><span class="toc-text">146. *LRU缓存(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-medium"><span class="toc-text">153. *寻找旋转排序数组中的最小值(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88-medium"><span class="toc-text">155. 最小栈(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">160. *相交链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84-medium"><span class="toc-text">189 *轮转数组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-medium"><span class="toc-text">198. *打家劫舍 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE-medium"><span class="toc-text">199. *二叉树的右视图(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-medium"><span class="toc-text">200. *岛屿数量 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">206. *反转链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8-medium"><span class="toc-text">207. *课程表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">208. *实现Trie(前缀树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-medium"><span class="toc-text">215. *数组中的第K个最大元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="toc-text">226. *翻转二叉树(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">230. *二叉搜索树中第K小的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">234. *回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">236. *二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-text">238. *除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-hard"><span class="toc-text">239. *滑动窗口最大值(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-text">240. *搜索二维矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A80-medium"><span class="toc-text">283. *移动0(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-hard"><span class="toc-text">295. *数据流的中位数(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-medium"><span class="toc-text">347. *前k个高频元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81-medium"><span class="toc-text">394. *字符串解码(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-medium"><span class="toc-text">437. *路径总和 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-medium"><span class="toc-text">438 *找到字符串中所有字母异位词(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-easy"><span class="toc-text">543. *二叉树的直径(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="toc-text">560. *和为k的子数组 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-medium"><span class="toc-text">739. *每日温度(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-medium"><span class="toc-text">763. *划分字母区间(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%F0%9F%8D%8A-medium"><span class="toc-text">994. *腐烂的🍊 (medium)</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>*是LeetCode Hot 100中的题</p>
</blockquote>
<p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-easy"><span class="toc-text">1. *两数之和(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-easy"><span class="toc-text">2. *两数相加 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-medium"><span class="toc-text">3. *无重复字符的最长子串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8-medium"><span class="toc-text">11. *盛水最多的容器(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">15. *三数之和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-medium"><span class="toc-text">17. *电话号码的字母组合(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-medium"><span class="toc-text">19. *删除链表的倒数第n个节点(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-easy"><span class="toc-text">20. *有效的括号(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">21. *合并两个有序的链表 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90-medium"><span class="toc-text">22. *括号生成(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-hard"><span class="toc-text">23. *合并K个升序链表(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-medium"><span class="toc-text">24. *两两交换链表中的节点(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-hard"><span class="toc-text">25. *K个一组反转链表(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5-medium"><span class="toc-text">34. *二分插入(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-easy"><span class="toc-text">35. *搜索插入位置(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-medium"><span class="toc-text">39. *组合总和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0-medium"><span class="toc-text">41. *缺失的第一个整数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-hard"><span class="toc-text">42. *接雨水(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII-medium"><span class="toc-text">45. *跳跃游戏II(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97-medium"><span class="toc-text">46. *全排列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-medium"><span class="toc-text">48. *旋转图像(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-medium"><span class="toc-text">49. *字母异位词(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N%E7%9A%87%E5%90%8E-hard"><span class="toc-text">51. *N皇后 (hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-medium"><span class="toc-text">53. *最大子数组和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-medium"><span class="toc-text">54. *螺旋矩阵(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-medium"><span class="toc-text">55. *跳跃游戏(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-medium"><span class="toc-text">56. *合并区间(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF-easy"><span class="toc-text">70. *爬楼梯 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6-medium"><span class="toc-text">73. *矩阵置零(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-text">74. 搜索二维矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-hard"><span class="toc-text">76. *最小覆盖子串(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86-medium"><span class="toc-text">78. *子集(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-medium"><span class="toc-text">79. *单词搜索(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-hard"><span class="toc-text">84. *柱状图中最大的矩形(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-easy"><span class="toc-text">94. *二叉树的中序遍历(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="toc-text">98. *验证二叉搜索树(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="toc-text">101. *对称二叉树(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">102. *二叉树的层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-easy"><span class="toc-text">104. *二叉树的最大深度(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-medium"><span class="toc-text">105. *从前序与中序遍历序列构造二叉树 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="toc-text">108. *将有序数组转换为二叉搜索树(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8-medium"><span class="toc-text">114. *二叉树展开为链表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-easy"><span class="toc-text">118. *杨辉三角(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-easy"><span class="toc-text">121. *买卖股票的最佳时机(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-hard"><span class="toc-text">124. *二叉树中的最大路径和(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97-medium"><span class="toc-text">128. *最长连续序列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-medium"><span class="toc-text">131. *分割回文串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">138. *随机链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">141. *环形链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II-medium"><span class="toc-text">142. *环形链表II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-medium"><span class="toc-text">144. 二叉树的前序遍历(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU%E7%BC%93%E5%AD%98-medium"><span class="toc-text">146. *LRU缓存(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-medium"><span class="toc-text">153. *寻找旋转排序数组中的最小值(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88-medium"><span class="toc-text">155. 最小栈(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">160. *相交链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84-medium"><span class="toc-text">189 *轮转数组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-medium"><span class="toc-text">198. *打家劫舍 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE-medium"><span class="toc-text">199. *二叉树的右视图(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-medium"><span class="toc-text">200. *岛屿数量 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">206. *反转链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8-medium"><span class="toc-text">207. *课程表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">208. *实现Trie(前缀树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-medium"><span class="toc-text">215. *数组中的第K个最大元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="toc-text">226. *翻转二叉树(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">230. *二叉搜索树中第K小的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="toc-text">234. *回文链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-text">236. *二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-text">238. *除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-hard"><span class="toc-text">239. *滑动窗口最大值(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5"><span class="toc-text">240. *搜索二维矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A80-medium"><span class="toc-text">283. *移动0(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-hard"><span class="toc-text">295. *数据流的中位数(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-medium"><span class="toc-text">347. *前k个高频元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81-medium"><span class="toc-text">394. *字符串解码(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-medium"><span class="toc-text">437. *路径总和 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-medium"><span class="toc-text">438 *找到字符串中所有字母异位词(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-easy"><span class="toc-text">543. *二叉树的直径(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="toc-text">560. *和为k的子数组 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-medium"><span class="toc-text">739. *每日温度(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-medium"><span class="toc-text">763. *划分字母区间(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%F0%9F%8D%8A-medium"><span class="toc-text">994. *腐烂的🍊 (medium)</span></a></li></ol></div></p>
<h2 id="1-两数之和-easy"><a href="#1-两数之和-easy" class="headerlink" title="1. *两数之和(easy)"></a>1. *两数之和(easy)</h2>
<ul>
<li>
<p>哈希表算法</p>
<ul>
<li>思路: 要遍历一次数组, 判断<code>target</code>减去当前值是否在数组中. 遍历时, 用哈希表把之前数组的值的信息保存在哈希表就可以.</li>
<li>时间复杂度: <svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-1-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"/></g></g></g></svg></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>      vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>      unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(target - nums[i])) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(i);<br>            ans.<span class="hljs-built_in">push_back</span>(hash[target - nums[i]]);<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>        hash[nums[i]] = i;<br>      &#125;<br>      <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-两数相加-easy"><a href="#2-两数相加-easy" class="headerlink" title="2. *两数相加 (easy)"></a>2. *两数相加 (easy)</h2>
<ul>
<li>两个数位相加后, <code>t % 10</code>就是数位的值, 进位的值就是<code>t / 10</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">auto</span> cur = dummy;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 || l2 || t) &#123;<br>            <span class="hljs-keyword">if</span> (l1) t += l1-&gt;val, l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span> (l2) t += l2-&gt;val, l2 = l2-&gt;next;<br>            cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t % <span class="hljs-number">10</span>); <br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="3-无重复字符的最长子串-medium"><a href="#3-无重复字符的最长子串-medium" class="headerlink" title="3. *无重复字符的最长子串(medium)"></a>3. *无重复字符的最长子串(medium)</h2>
<ul>
<li>注意: 子串要求元素连续, 子序列不要求连续.</li>
<li>用一个哈希表维护从前到后, 元素出现的次数.</li>
<li>从前到后遍历, 如果发现<code>hash[s[i]] &gt; 1</code>, 说明出现了重复字符, 然后就把指针<code>j</code>向前移动, 直到没有重复字符, 最后统计子串的长度.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>       <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>       unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            hash[s[i]] ++;<br>            <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; hash[s[i]] &gt; <span class="hljs-number">1</span>) hash[s[j ++]] --;<br>            res = <span class="hljs-built_in">max</span>(res, i - j + <span class="hljs-number">1</span>);<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="11-盛水最多的容器-medium"><a href="#11-盛水最多的容器-medium" class="headerlink" title="11. *盛水最多的容器(medium)"></a>11. *盛水最多的容器(medium)</h2>
<ul>
<li>
<p>双指针:</p>
<ul>
<li>思路: 假设两根棍子<code>i, j</code>, 它们之间的盛水量就是<code>min(height[i], height[j]) * (j - i)</code>, 只需要枚举<code>i, j</code>即可.</li>
<li>如果<code>height[i] &lt; height[j]</code>, 那么只需要<code>i++</code>即可, 因为只有棍子变大, 盛水量才能更多, 因此不需要用<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-2-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-2-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-2-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-2-TEX-N-28"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-2-TEX-I-1D45B"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><use data-c="32" xlink:href="#MJX-2-TEX-N-32"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><use data-c="29" xlink:href="#MJX-2-TEX-N-29"/></g></g></g></svg>枚举i, j.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; ) &#123;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">min</span>(height[i], height[j]) * (j - i));<br>            <span class="hljs-keyword">if</span> (height[i] &lt; height[j]) i ++;<br>            <span class="hljs-keyword">else</span> j --;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="15-三数之和-medium"><a href="#15-三数之和-medium" class="headerlink" title="15. *三数之和(medium)"></a>15. *三数之和(medium)</h2>
<ul>
<li>双指针.</li>
<li>思路: 首先把数组排序(不要忘), 然后枚举第一个数, 再从后面根据双指针枚举第二个和第三个数.</li>
<li>枚举第二/第三个数时, 数组具有单调性, 第二个指针在前, 第三个指针在后, 根据<code>nums[i] + nums[l] + nums[r]</code>和<code>target</code>的大小关系前后调整指针即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>       vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>       <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> sum = nums[i] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>                    ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[l], nums[r]&#125;);<br>                    <span class="hljs-keyword">do</span> &#123; l ++; &#125; <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="hljs-number">1</span>]);<br>                    <span class="hljs-keyword">do</span> &#123; r --; &#125; <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) l ++;<br>                <span class="hljs-keyword">else</span> r --;<br>            &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="17-电话号码的字母组合-medium"><a href="#17-电话号码的字母组合-medium" class="headerlink" title="17. *电话号码的字母组合(medium)"></a>17. *电话号码的字母组合(medium)</h2>
<ul>
<li>枚举每一个数字对应的字符集选哪一个字符即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string str[<span class="hljs-number">10</span>] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>,<br>        <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>,<br>        <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>,<br>        <span class="hljs-string">&quot;wxyz&quot;</span><br>    &#125;;<br>    vector&lt;string&gt; ans;<br>    string path = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-built_in">dfs</span>(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string digits, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: str[digits[u] - <span class="hljs-string">&#x27;0&#x27;</span>]) &#123;<br>            path.<span class="hljs-built_in">push_back</span>(c);<br>            <span class="hljs-built_in">dfs</span>(digits, u + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="19-删除链表的倒数第n个节点-medium"><a href="#19-删除链表的倒数第n个节点-medium" class="headerlink" title="19. *删除链表的倒数第n个节点(medium)"></a>19. *删除链表的倒数第n个节点(medium)</h2>
<ul>
<li>
<p>首先, 链表头可能被删除, 需要虚拟头节点.</p>
</li>
<li>
<p>假设链表一共有<code>N</code>个节点:</p>
<ul>
<li>倒数第n个节点, 就是正数第<code>N - n + 1</code>个节点, 那么从虚拟头节点跳到这里, 需要跳<code>N - n + 1</code>次.</li>
<li>但是我要删除这个节点, 需要跳到这个节点的前一个节点, 就需要从虚拟头节点跳<code>N - n</code>次.</li>
</ul>
</li>
<li>
<p>如果需要遍历一次, 那么就需要搞两个指针.</p>
<ul>
<li>加上虚拟头节点, 一共能跳<code>N</code>次.</li>
<li>先让一个指针跳<code>n</code>次, 然后再让另一个指针开始动, 直到前一个指针跳到最后一个节点.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br>        ListNode *p = dummy, *q = dummy;<br>        <span class="hljs-keyword">while</span> (n --) p = p-&gt;next;<br>        <span class="hljs-keyword">while</span> (p-&gt;next) &#123;<br>            p = p-&gt;next, q = q-&gt;next;<br>        &#125;<br>        q-&gt;next = q-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="20-有效的括号-easy"><a href="#20-有效的括号-easy" class="headerlink" title="20. *有效的括号(easy)"></a>20. *有效的括号(easy)</h2>
<ul>
<li>遇到左括号就压栈, 遇到右括号就弹出.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span>) stk.<span class="hljs-built_in">push</span>(c);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span>) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;&#123;&#x27;</span>) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;[&#x27;</span>) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="21-合并两个有序的链表-easy"><a href="#21-合并两个有序的链表-easy" class="headerlink" title="21. *合并两个有序的链表 (easy)"></a>21. *合并两个有序的链表 (easy)</h2>
<ul>
<li>和归并排序合并的过程差不多.</li>
<li>注意, 不要忘记合并剩下的链表, 因为肯定有一个链表先走完.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">auto</span> cur = dummy;<br>        <span class="hljs-keyword">auto</span> l1 = list1, l2 = list2;<br>        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;<br>                cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(l1-&gt;val);<br>                l1 = l1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(l2-&gt;val);<br>                l2 = l2-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l1) cur-&gt;next = l1;<br>        <span class="hljs-keyword">if</span> (l2) cur-&gt;next = l2;<br>        <br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="22-括号生成-medium"><a href="#22-括号生成-medium" class="headerlink" title="22. *括号生成(medium)"></a>22. *括号生成(medium)</h2>
<ul>
<li>
<p>一个括号序列是合法的充要条件是:</p>
<ul>
<li>序列中, 左右括号数量相等.</li>
<li>任意前缀, 左括号数量大于等于有括号数量.</li>
</ul>
</li>
<li>
<p>给定了n对括号, 那么序列中左右括号的数量一定相等, 那么对于括号序列的这<code>2n</code>个位置:</p>
<ul>
<li>
<p>如果左括号的数量小于n, 那么就可以填<code>(</code>.</p>
</li>
<li>
<p>如果右括号数量小于n, 并且右括号数量小于左括号数量, 那么就可以填<code>)</code>.</p>
</li>
<li>
<p>递归即可.</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> _n)</span> </span>&#123;<br>        n = _n;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc, string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lc == n &amp;&amp; rc == n) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lc &lt; n) <span class="hljs-built_in">dfs</span>(lc + <span class="hljs-number">1</span>, rc, s + <span class="hljs-string">&#x27;(&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (rc &lt; n &amp;&amp; rc &lt; lc) <span class="hljs-built_in">dfs</span>(lc, rc + <span class="hljs-number">1</span>, s + <span class="hljs-string">&#x27;)&#x27;</span>);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="23-合并K个升序链表-hard"><a href="#23-合并K个升序链表-hard" class="headerlink" title="23. *合并K个升序链表(hard)"></a>23. *合并K个升序链表(hard)</h2>
<ul>
<li>链表的k路归并问题, 可以采用堆排序解决.
<ul>
<li>将每一个链表头节点插入堆.</li>
<li>然后从堆中找到最小元素.</li>
<li>之后再将下一个头节点插入堆.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(ListNode *a, ListNode *b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">auto</span> cur = dummy;<br><br>        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; heap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> l: lists)<br>            <span class="hljs-keyword">if</span> (l) heap.<span class="hljs-built_in">push</span>(l);<br>            <br>        <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();<br>            cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t-&gt;val);<br>            <span class="hljs-keyword">if</span> (t-&gt;next) heap.<span class="hljs-built_in">push</span>(t-&gt;next);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="24-两两交换链表中的节点-medium"><a href="#24-两两交换链表中的节点-medium" class="headerlink" title="24. *两两交换链表中的节点(medium)"></a>24. *两两交换链表中的节点(medium)</h2>
<ul>
<li>首先, 链表头节点可能没有, 所以需要虚拟头节点.</li>
<li>其次, 如果要交换<code>p-&gt;a-&gt;b-&gt;b.next</code>中的节点<code>a</code>和<code>b</code>:
<ul>
<li>首先, 将<code>a, b</code>看成一个整体, 动外面的指针: <code>p-&gt;next = b</code>, <code>a-&gt;next = b-&gt;next</code>.</li>
<li>然后, 再动<code>a, b</code>内部的指针<code>b-&gt;next = a</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;) &#123;<br>            <span class="hljs-keyword">auto</span> a = p-&gt;next, b = a-&gt;next;<br>            p-&gt;next = b;<br>            a-&gt;next = b-&gt;next;<br>            b-&gt;next = a;<br>            p = a;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="25-K个一组反转链表-hard"><a href="#25-K个一组反转链表-hard" class="headerlink" title="25. *K个一组反转链表(hard)"></a>25. *K个一组反转链表(hard)</h2>
<ul>
<li>首先, 头节点会被改变, 因此要加上虚拟头节点.</li>
<li>其次, 先找到这k个节点组成的一个集团, 以及这个集团的前一个节点<code>p</code>, 和最后的节点<code>q</code>.</li>
<li>之后, 先动边界节点, 然后修改集团内部的节点.</li>
<li>最后, 注意指针<code>p</code>的移动.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>       <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>       dummy-&gt;next = head;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = dummy;; ) &#123;<br>            <span class="hljs-keyword">auto</span> q = p;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; q; i ++) q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (!q) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">auto</span> u = p-&gt;next;<br>            <span class="hljs-keyword">auto</span> a = p-&gt;next, b = p-&gt;next-&gt;next;<br>            p-&gt;next = q;<br>            a-&gt;next = q-&gt;next;<br>            <span class="hljs-keyword">while</span> (a != q) &#123;<br>                <span class="hljs-keyword">auto</span> c = b-&gt;next;<br>                b-&gt;next = a;<br>                a = b, b = c;<br>            &#125;<br>            p = u;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="34-二分插入-medium"><a href="#34-二分插入-medium" class="headerlink" title="34. *二分插入(medium)"></a>34. *二分插入(medium)</h2>
<ul>
<li>整数二分边界问题.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[l] != target) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> left = l;<br>        l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[l] != target) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> right = l;<br>        <span class="hljs-keyword">return</span> &#123;left, right&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="35-搜索插入位置-easy"><a href="#35-搜索插入位置-easy" class="headerlink" title="35. *搜索插入位置(easy)"></a>35. *搜索插入位置(easy)</h2>
<ul>
<li>整数二分的边界: 假设左右两侧性质分别为<code>A</code>和<code>~A</code>
<ul>
<li>左边界:
<ul>
<li><code>mid = l + (r - l) / 2 + 1</code></li>
<li><code>A</code>: <code>l = mid</code></li>
<li><code>~A</code>: <code>r = mid - 1</code></li>
</ul>
</li>
<li>右边界:
<ul>
<li><code>mid = l + (r - l) / 2</code></li>
<li><code>A</code>: <code>l = mid + 1</code></li>
<li><code>~A</code>: <code>r = mid</code></li>
</ul>
</li>
</ul>
</li>
<li>注意, 如果插入位置在最后, 那么需要特判, 因为二分只能二分到数组内合法的索引.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">return</span> n;<br>        <br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125; <br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="39-组合总和-medium"><a href="#39-组合总和-medium" class="headerlink" title="39. *组合总和(medium)"></a>39. *组合总和(medium)</h2>
<ul>
<li>虽然每一个元素可以任意选择, 但是由于有总和是<code>target</code>的限制, 可以选择的个数也是有限的, 枚举每一个元素以及这个元素的选择次数即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">dfs</span>(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == nums.<span class="hljs-built_in">size</span>() || sum == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>)<br>                ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; nums[u] * i &lt;= sum; i ++) &#123;<br>            <span class="hljs-built_in">dfs</span>(nums, sum - nums[u] * i, u + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">push_back</span>(nums[u]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; nums[u] * i &lt;= sum; i ++)<br>            path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="41-缺失的第一个整数-medium"><a href="#41-缺失的第一个整数-medium" class="headerlink" title="41. *缺失的第一个整数(medium)"></a>41. *缺失的第一个整数(medium)</h2>
<ul>
<li>思路:
<ul>
<li>将所有数值“归位”, 就是让<code>nums[i] = i</code>, 然后遍历数组, 如果有不符合的, 那么就找到了最小没出现的正整数.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != INT_MIN) nums[i] --;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">while</span> (nums[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; n &amp;&amp; nums[nums[i]] != nums[i]) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (nums[i] != i) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125; <br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="42-接雨水-hard"><a href="#42-接雨水-hard" class="headerlink" title="42. *接雨水(hard)"></a>42. *接雨水(hard)</h2>
<ul>
<li>思路: 假设<code>l[i], r[i]</code>分别代表格子<code>h[i]</code>左右范围 (包括<code>h[i]</code>)的最大值, 那么这个格子对雨水的贡献量就是<code>min(l[i], r[i]) - h[i]</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>       <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20010</span>;<br>       <span class="hljs-type">int</span> l[N], r[N];<br><br>       <span class="hljs-type">int</span> maxv = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            maxv = <span class="hljs-built_in">max</span>(maxv, height[i]);<br>            l[i] = maxv;<br>       &#125;<br>       maxv = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            maxv = <span class="hljs-built_in">max</span>(maxv, height[i]);<br>            r[i] = maxv;<br>       &#125;<br>       <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            res += <span class="hljs-built_in">min</span>(l[i], r[i]) - height[i];<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="45-跳跃游戏II-medium"><a href="#45-跳跃游戏II-medium" class="headerlink" title="45. *跳跃游戏II(medium)"></a>45. *跳跃游戏II(medium)</h2>
<ul>
<li>动态规划问题: 基于先验知识作出的最优选择, 也是全局视角下的最优选择.</li>
<li>假设<code>f[i]</code>表示跳到<code>i</code>位置的最小步数.
<ul>
<li>那么<code>i</code>位置怎么才能从一个位置<code>j</code>一步跳到, 并且<code>j</code>离<code>i</code>最远呢.</li>
<li>就是找最小的<code>j</code>, 但是<code>j + nums[j] &gt;= i</code>的.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">while</span> (j + nums[j] &lt; i) j ++;<br>            f[i] = f[j] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="46-全排列-medium"><a href="#46-全排列-medium" class="headerlink" title="46. *全排列(medium)"></a>46. *全排列(medium)</h2>
<ul>
<li>本题是无重复元素的数组求全排列.</li>
<li>dfs时, 对于全排列的每一个位置, 枚举给定数组中的每一个元素, 看用哪一个元素放在这个位置, 选定位置后, 就递归到下一个位置.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">bool</span>&gt; st;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        st.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (st[i]) <span class="hljs-keyword">continue</span>;<br>            st[i] = <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">dfs</span>(nums, u + <span class="hljs-number">1</span>);<br>            st[i] = <span class="hljs-literal">false</span>;<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="48-旋转图像-medium"><a href="#48-旋转图像-medium" class="headerlink" title="48. *旋转图像(medium)"></a>48. *旋转图像(medium)</h2>
<ul>
<li>顺时针90度: 主对角线对称(左上-右下), 竖直轴线对称.</li>
<li>逆时针90度: 水平轴线对称.</li>
<li>顺时针/逆时针180度: 主对角线对称 + 副对角线对称.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>       <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, k = n - <span class="hljs-number">1</span>; j &lt; k; j ++, k --)<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[i][k]);<br>        <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="49-字母异位词-medium"><a href="#49-字母异位词-medium" class="headerlink" title="49. *字母异位词(medium)"></a>49. *字母异位词(medium)</h2>
<ul>
<li>
<p>哈希表:</p>
<ul>
<li>思路: 一个单词的字母异位词, 指的是和它字母相同, 但是字母排列不同的所有单词组成的集合. 题目中要求集合中的单词必须在给定的数组中.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;str: strs) &#123;<br>            string nstr = str;<br>            <span class="hljs-built_in">sort</span>(nstr.<span class="hljs-built_in">begin</span>(), nstr.<span class="hljs-built_in">end</span>());<br>            hash[nstr].<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: hash) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(item.second);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="51-N皇后-hard"><a href="#51-N皇后-hard" class="headerlink" title="51. *N皇后 (hard)"></a>51. *N皇后 (hard)</h2>
<ul>
<li>用<code>col</code>, <code>dg</code>, <code>udg</code>分别记录每一列, 对角线/反对角线上是否有<code>Q</code>.</li>
<li>遍历时先遍历每一行<code>u</code>, 然后遍历每一列<code>i</code>, 如果一个位置<code>(u, i)</code>在列, 对角线, 反对角线上都没有棋子, 那么就可以放下棋子, 然后递归到下一个位置.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">bool</span>&gt; col;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; dg;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; udg;<br>    vector&lt;string&gt; g;<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> n) &#123;<br>        col = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        dg = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        udg = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        g = <span class="hljs-built_in">vector</span>&lt;string&gt;(n, <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27;.&#x27;</span>));<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = g.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (u == n) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(g);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (col[i] || dg[u + i] || udg[n + u - i]) <span class="hljs-keyword">continue</span>;<br>            g[u][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            col[i] = dg[u + i] = udg[n + u - i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            g[u][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            col[i] = dg[u + i] = udg[n + u - i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="53-最大子数组和-medium"><a href="#53-最大子数组和-medium" class="headerlink" title="53. *最大子数组和(medium)"></a>53. *最大子数组和(medium)</h2>
<ul>
<li>思路:
<ul>
<li>对于这样一个连续和, 要么一直累加, 要么就从一个元素开始重开, 直接遍历即可.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>];<br>       <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>            k = <span class="hljs-built_in">max</span>(k + x, x);<br>            ans = <span class="hljs-built_in">max</span>(ans, k);<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="54-螺旋矩阵-medium"><a href="#54-螺旋矩阵-medium" class="headerlink" title="54. *螺旋矩阵(medium)"></a>54. *螺旋矩阵(medium)</h2>
<ul>
<li>按照<code>dx, dy</code>向量方法遍历矩阵比较简单.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (matrix.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> ans;<br><br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">st</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br><br>        <span class="hljs-type">int</span> dx[] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span> &#125;;<br>        <span class="hljs-type">int</span> dy[] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span> &#125;;<br><br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n * m; k ++) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(matrix[x][y]);<br>            st[x][y] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> a = x + dx[d], b = y + dy[d];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m || st[a][b])<br>                d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            x = x + dx[d], y = y + dy[d];<br>        &#125; <br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="55-跳跃游戏-medium"><a href="#55-跳跃游戏-medium" class="headerlink" title="55. *跳跃游戏(medium)"></a>55. *跳跃游戏(medium)</h2>
<ul>
<li>枚举数组中的每一个数<code>nums[i]</code>, 它能够跳到的最大的位置就是<code>i + nums[i]</code>.</li>
<li>那么, 当遍历到<code>i</code>时, 如果之前能够跳到的最大位置<code>j &lt; i</code>, 那么就无法到达这个位置, 因此, 就无法到达终点.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> range = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (range &lt; i) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            range = <span class="hljs-built_in">max</span>(range, i + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="56-合并区间-medium"><a href="#56-合并区间-medium" class="headerlink" title="56. *合并区间(medium)"></a>56. *合并区间(medium)</h2>
<ul>
<li>该题的意思是, 对于给定的任意两个区间, 如果有交集, 那么就合并成一个区间, 最后返回剩下的区间.
<ul>
<li>首先, 所有区间按照左端点排序.</li>
<li>之后, 维护一个区间<code>[st, ed]</code>, 这个区间是右端点最大的区间, 然后遍历所有区间<code>[l, r]</code>:
<ul>
<li>如果<code>l &lt;= ed</code>, 那么当前区间和维护的区间有交集, 直接合并<code>ed = max(ed, r)</code></li>
<li>如果<code>l &gt; ed</code>, 那么当前区间和维护的区间没有交集, 需要更新<code>st = l, ed = r</code>.</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br><br>        <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ra: intervals) &#123;<br>            <span class="hljs-type">int</span> l = ra[<span class="hljs-number">0</span>], r = ra[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (l &lt;= ed) ed = <span class="hljs-built_in">max</span>(ed, r);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (ed != <span class="hljs-number">-2e9</span>) ans.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>                st = l, ed = r;<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">// 不要忘记最后还要push_back一下</span><br>        ans.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="70-爬楼梯-easy"><a href="#70-爬楼梯-easy" class="headerlink" title="70. *爬楼梯 (easy)"></a>70. *爬楼梯 (easy)</h2>
<ul>
<li>注意: 需要考虑Fib数列的值是否会爆<code>int</code>.</li>
<li>Fib数列的第0项是1, 第1项也是1.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>        LL a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (n --) &#123;<br>            LL c = a + b;<br>            a = b, b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="73-矩阵置零-medium"><a href="#73-矩阵置零-medium" class="headerlink" title="73. *矩阵置零(medium)"></a>73. *矩阵置零(medium)</h2>
<ul>
<li>原地算法:
<ul>
<li>首先记录一下第0行和第0列是否需要清0.</li>
<li>然后从第1行/第1列开始对矩阵进行判断, 如果第i行包含0元素, 就在<code>matrix[i][0]</code>处标记为0.
<ul>
<li>原来的<code>matrix[i][0]</code>可能是0, 也可能不是0, 这个时候如果标记为0, 那么原来的值就不知道, 那么后面就无法判断第0行和第0列是否需要清0, 所以需要预先处理一下第0行和第0列.</li>
</ul>
</li>
<li>然后根据标记的<code>matrix[i][0]</code>和<code>matrix[0][i]</code>进行清理.</li>
<li>之后清理第0行和第0列.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <br>        <span class="hljs-type">bool</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span> (!matrix[i][<span class="hljs-number">0</span>]) col = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>            <span class="hljs-keyword">if</span> (!matrix[<span class="hljs-number">0</span>][i]) row = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (!matrix[i][j])<br>                    matrix[i][<span class="hljs-number">0</span>] = matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (!matrix[i][<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j ++) &#123;<br>            <span class="hljs-keyword">if</span> (!matrix[<span class="hljs-number">0</span>][j]) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (col) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (row) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>                matrix[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a>74. 搜索二维矩阵</h2>
<ul>
<li>二维矩阵和一维数组没有什么区别, 一位数组的下标<code>idx</code>分别除以/模矩阵列数就是在矩阵中的坐标<code>(idx / m, idx % m)</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> s = n * m;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = s - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> x = mid / m, y = mid % m;<br>            <span class="hljs-keyword">if</span> (matrix[x][y] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix[l / m][l % m] == target;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="76-最小覆盖子串-hard"><a href="#76-最小覆盖子串-hard" class="headerlink" title="76. *最小覆盖子串(hard)"></a>76. *最小覆盖子串(hard)</h2>
<ul>
<li>双指针:
<ul>
<li>思路: 向右移动指针, 直到完全覆盖<code>t</code>中的所有字符.</li>
<li>然后向左移动指针, 找到长度最小的, 也可以完全覆盖<code>t</code>中字符的最小子串.
<ul>
<li><code>hash[s[i]]</code>表示<code>t</code>中字符在<code>s</code>中出现的次数, 如果<code>hash[s[j]] + 1 &gt; 0</code>, 那么表示如果<code>j</code>再向前移动, 就无法覆盖<code>t</code>中所有字符了.</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), m = t.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: t) hash[c] ++;<br>        <span class="hljs-type">int</span> tot = hash.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len = n;<br>        string ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(s[i]) &amp;&amp; --hash[s[i]] == <span class="hljs-number">0</span>) k ++;<br>            <span class="hljs-keyword">if</span> (k == tot) &#123;<br>                <span class="hljs-keyword">while</span> (j &lt; i) &#123;<br>                    <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(s[j])) &#123;<br>                        <span class="hljs-keyword">if</span> (hash[s[j]] + <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        hash[s[j]] ++;<br>                    &#125;<br>                    j ++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i - j + <span class="hljs-number">1</span> &lt;= len) &#123;<br>                    len = i - j + <span class="hljs-number">1</span>;<br>                    ans = s.<span class="hljs-built_in">substr</span>(j, i - j + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="78-子集-medium"><a href="#78-子集-medium" class="headerlink" title="78. *子集(medium)"></a>78. *子集(medium)</h2>
<ul>
<li>递归写法:
<ul>
<li>枚举数组中的每个数选/不选即可.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(nums, u + <span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">push_back</span>(nums[u]);<br>        <span class="hljs-built_in">dfs</span>(nums, u + <span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>迭代写法: 用二进制枚举子集</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; path;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>                <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>)<br>                    path.<span class="hljs-built_in">push_back</span>(nums[j]);<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="79-单词搜索-medium"><a href="#79-单词搜索-medium" class="headerlink" title="79. *单词搜索(medium)"></a>79. *单词搜索(medium)</h2>
<ul>
<li>从每一个格子位置开始DFS即可, 注意边界.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>       <span class="hljs-type">int</span> n = board.<span class="hljs-built_in">size</span>(), m = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, <span class="hljs-number">0</span>, i, j))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board, string word, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (board[x][y] != word[u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (u == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">char</span> t = board[x][y];<br>        board[x][y] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        <span class="hljs-type">int</span> n = board.<span class="hljs-built_in">size</span>(), m = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m || board[a][b] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, u + <span class="hljs-number">1</span>, a, b)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        board[x][y] = t;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="84-柱状图中最大的矩形-hard"><a href="#84-柱状图中最大的矩形-hard" class="headerlink" title="84. *柱状图中最大的矩形(hard)"></a>84. *柱状图中最大的矩形(hard)</h2>
<ul>
<li>首先思考如何枚举每一个矩形, 假设某个矩形的高度是<code>h</code>, 那么从左边, 从右边第一个比<code>h</code>小的位置的右侧/左侧就是边界.</li>
<li>这个边界可以用单调栈预处理.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; h)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; left, right;<br><br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>() &amp;&amp; h[i] &lt;= h[stk.<span class="hljs-built_in">top</span>()]) stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) left.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">else</span> left.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>() + <span class="hljs-number">1</span>);<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        stk = <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>() &amp;&amp; h[i] &lt;= h[stk.<span class="hljs-built_in">top</span>()]) stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) right.<span class="hljs-built_in">push_back</span>(h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> right.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>);<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(right.<span class="hljs-built_in">begin</span>(), right.<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h.<span class="hljs-built_in">size</span>(); i ++)<br>            ans = <span class="hljs-built_in">max</span>(ans, h[i] * (right[i] - left[i] + <span class="hljs-number">1</span>));<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="94-二叉树的中序遍历-easy"><a href="#94-二叉树的中序遍历-easy" class="headerlink" title="94. *二叉树的中序遍历(easy)"></a>94. *二叉树的中序遍历(easy)</h2>
<ul>
<li>
<p>递归写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>迭代写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>      <span class="hljs-comment">// 这里root和stk.size()是两个判断条件.</span><br>      <span class="hljs-comment">// root用来判断上一个处理节点是否有右节点, 如果有就递归到右节点</span><br>      <span class="hljs-comment">// stk.size()用来判断上一个节点如果没有右节点, 就从栈中弹出上一个节点处理</span><br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="98-验证二叉搜索树-medium"><a href="#98-验证二叉搜索树-medium" class="headerlink" title="98. *验证二叉搜索树(medium)"></a>98. *验证二叉搜索树(medium)</h2>
<ul>
<li>dfs函数返回一个节点所在子树的元素最小值和最大值.</li>
<li>递归向上比较左子树最大值, 右子树最小值和当前节点值的关系即可验证.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> ans = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minv = root-&gt;val, maxv = root-&gt;val;<br>        <span class="hljs-keyword">if</span> (root-&gt;left) &#123;<br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>            <span class="hljs-keyword">if</span> (t[<span class="hljs-number">1</span>] &gt;= root-&gt;val) ans = <span class="hljs-literal">false</span>;<br>            minv = <span class="hljs-built_in">min</span>(minv, t[<span class="hljs-number">0</span>]);<br>            maxv = <span class="hljs-built_in">max</span>(maxv, t[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;right) &#123;<br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>            <span class="hljs-keyword">if</span> (t[<span class="hljs-number">0</span>] &lt;= root-&gt;val) ans = <span class="hljs-literal">false</span>;<br>            minv = <span class="hljs-built_in">min</span>(minv, t[<span class="hljs-number">0</span>]);<br>            maxv = <span class="hljs-built_in">max</span>(maxv, t[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;minv, maxv&#125;;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="101-对称二叉树-easy"><a href="#101-对称二叉树-easy" class="headerlink" title="101. *对称二叉树(easy)"></a>101. *对称二叉树(easy)</h2>
<ul>
<li>
<p>递归判断一个节点的左节点和右节点是否相等即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, root-&gt;right); <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> !p &amp;&amp; !q;<br>        <span class="hljs-keyword">if</span> (p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="hljs-built_in">dfs</span>(p-&gt;right, q-&gt;left);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. *二叉树的层序遍历"></a>102. *二叉树的层序遍历</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>          <span class="hljs-comment">// 这里的q.size()就是一层的长度</span><br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-keyword">while</span> (len --) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度-easy"><a href="#104-二叉树的最大深度-easy" class="headerlink" title="104. *二叉树的最大深度(easy)"></a>104. *二叉树的最大深度(easy)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="105-从前序与中序遍历序列构造二叉树-medium"><a href="#105-从前序与中序遍历序列构造二叉树-medium" class="headerlink" title="105. *从前序与中序遍历序列构造二叉树 (medium)"></a>105. *从前序与中序遍历序列构造二叉树 (medium)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) hash[inorder[i]] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;preorder, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inorder, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (pl &gt; pr) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>       <span class="hljs-type">int</span> r = preorder[pl];<br>       <span class="hljs-type">int</span> k = hash[r];<br>       <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(r);<br>       root-&gt;left = <span class="hljs-built_in">dfs</span>(preorder, inorder, pl + <span class="hljs-number">1</span>, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il + <span class="hljs-number">1</span> - <span class="hljs-number">1</span>, il, k - <span class="hljs-number">1</span>);<br>       root-&gt;right = <span class="hljs-built_in">dfs</span>(preorder, inorder, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il + <span class="hljs-number">1</span>, pr, k + <span class="hljs-number">1</span>, ir);<br>       <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="108-将有序数组转换为二叉搜索树-medium"><a href="#108-将有序数组转换为二叉搜索树-medium" class="headerlink" title="108. *将有序数组转换为二叉搜索树(medium)"></a>108. *将有序数组转换为二叉搜索树(medium)</h2>
<ul>
<li>从中点开始创造节点, 然后左子树和右子树从中点前后范围递归构建.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(nums, l, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(nums, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="114-二叉树展开为链表-medium"><a href="#114-二叉树展开为链表-medium" class="headerlink" title="114. *二叉树展开为链表(medium)"></a>114. *二叉树展开为链表(medium)</h2>
<ul>
<li>从直观上来看, 需要把一个节点的左子树, 归并到这个节点和右节点之间.</li>
<li>左子树有两个关键的节点:
<ul>
<li>左子树根节点, 当前节点的右指针要指向左子树根节点.</li>
<li>当前节点中序遍历的前驱, 前驱的右节点需要只想右子树根节点.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur = root;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                <span class="hljs-keyword">auto</span> prev = cur-&gt;left;<br>                <span class="hljs-keyword">while</span> (prev-&gt;right) prev = prev-&gt;right;<br>                prev-&gt;right = cur-&gt;right;<br>                cur-&gt;right = cur-&gt;left;<br>                cur-&gt;left = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="118-杨辉三角-easy"><a href="#118-杨辉三角-easy" class="headerlink" title="118. *杨辉三角(easy)"></a>118. *杨辉三角(easy)</h2>
<ul>
<li>注意: 杨辉三角每一行的第一个数和最后一个数都是1.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; f;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i ++) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">line</span><span class="hljs-params">(i + <span class="hljs-number">1</span>)</span></span>;<br>            line[<span class="hljs-number">0</span>] = line[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)<br>                line[j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + f[i - <span class="hljs-number">1</span>][j];<br>            f.<span class="hljs-built_in">push_back</span>(line);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="121-买卖股票的最佳时机-easy"><a href="#121-买卖股票的最佳时机-easy" class="headerlink" title="121. *买卖股票的最佳时机(easy)"></a>121. *买卖股票的最佳时机(easy)</h2>
<ul>
<li>
<p>直接倒序遍历的过程中, 统计股票价格最大值即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> v = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">if</span> (v != <span class="hljs-number">-1</span>) &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, v - prices[i]);<br>                v = <span class="hljs-built_in">max</span>(v, prices[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> v = prices[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="124-二叉树中的最大路径和-hard"><a href="#124-二叉树中的最大路径和-hard" class="headerlink" title="124. *二叉树中的最大路径和(hard)"></a>124. *二叉树中的最大路径和(hard)</h2>
<ul>
<li><code>dfs</code>函数是从当前节点出发, 伸到子树中所有节点的单向路径的最大权值之和.</li>
<li>那么对于一条路径, 他有三种情况:
<ul>
<li>从左节点向下延伸.</li>
<li>从右节点向下延伸.</li>
<li>从左右节点同时向下延伸.</li>
</ul>
</li>
<li>只需要对这三种情况取一个max即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">dfs</span>(root-&gt;left), r = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> maxv = root-&gt;val;<br>        maxv = <span class="hljs-built_in">max</span>(maxv, root-&gt;val + l);<br>        maxv = <span class="hljs-built_in">max</span>(maxv, root-&gt;val + r);<br>        <span class="hljs-type">int</span> c = maxv;<br>        maxv = <span class="hljs-built_in">max</span>(maxv, l + r + root-&gt;val);<br>        ans = <span class="hljs-built_in">max</span>(ans, maxv);<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="128-最长连续序列-medium"><a href="#128-最长连续序列-medium" class="headerlink" title="128. *最长连续序列(medium)"></a>128. *最长连续序列(medium)</h2>
<ul>
<li>哈希表:
<ul>
<li>思路:
<ul>
<li>首先, 将数组中所有数字插入哈希表.</li>
<li>然后, 枚举每一个数字作为起点, 看最连续能到达哪里, 统计最大长度即可.</li>
</ul>
</li>
<li>时间复杂度: <svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-3-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-3-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-3-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-3-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-3-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-3-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-3-TEX-N-29"/></g></g></g></svg></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       unordered_set&lt;<span class="hljs-type">int</span>&gt; hash;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>            hash.<span class="hljs-built_in">insert</span>(x);<br>       &#125;<br>       <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (!hash.<span class="hljs-built_in">count</span>(x - <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-type">int</span> y = x;<br>                <span class="hljs-keyword">while</span> (hash.<span class="hljs-built_in">count</span>(y + <span class="hljs-number">1</span>)) y ++;<br>                ans = <span class="hljs-built_in">max</span>(ans, y - x + <span class="hljs-number">1</span>);<br>            &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="131-分割回文串-medium"><a href="#131-分割回文串-medium" class="headerlink" title="131. *分割回文串(medium)"></a>131. *分割回文串(medium)</h2>
<ul>
<li>首先, 如果一个字符串是<code>aaaaa..</code>, 那么枚举分割方案的时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.765ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2548.3 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-4-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-4-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-4-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-4-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-4-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-4-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-4-TEX-N-28"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-4-TEX-N-32"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-4-TEX-I-1D45B"/></g></g><g data-mml-node="mo" transform="translate(2159.3,0)"><use data-c="29" xlink:href="#MJX-4-TEX-N-29"/></g></g></g></svg>, 所以这个问题是一个爆搜问题.</li>
<li>其次, 枚举分割方案的方法是, 枚举一个起点<code>u</code>, 然后从<code>u</code>向后 (包括<code>u</code>), 枚举终点<code>i</code>, 枚举终点后, 递归到下一个起点<code>i + 1</code>.</li>
<li>可以用一个<code>f[i][j]</code>预处理<code>s[i, j]</code>是否是回文串, 递推式是:
<ul>
<li><code>f[i][j] = f[i + 1][j - 1] &amp;&amp; s[i] == s[j]</code>.</li>
<li>注意由于要满足拓扑序, <code>i</code>要从后向前, <code>j</code>要从前向后.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; f;<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        f = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = j; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>                <span class="hljs-keyword">if</span> (i == j) f[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt; j - <span class="hljs-number">1</span>) f[i][j] = (s[i] == s[j]);<br>                <span class="hljs-keyword">else</span> f[i][j] = (s[i] == s[j]) &amp;&amp; f[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = u; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (!f[u][i]) <span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(u, i - u + <span class="hljs-number">1</span>));<br>            <span class="hljs-built_in">dfs</span>(s, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138. *随机链表的复制"></a>138. *随机链表的复制</h2>
<ul>
<li>首先, 对于旧链表中的每一个节点, 在后面插入一个新的节点, 那么我就可以通过旧链表的位置相对关系, 推导出新链表的位置相对关系.</li>
<li>之后, 如果要复制<code>random</code>边, 只需要让旧链表中的节点<code>p</code>, 让<code>p-&gt;next-&gt;random = p-&gt;random-&gt;next</code>.
<ul>
<li>其中<code>p-&gt;next</code>是新链表中的对应节点, <code>p-&gt;random-&gt;next</code>就是<code>p-&gt;random</code>在新链表中的相对位置.</li>
</ul>
</li>
<li>之后, 再把新链表节点从原链表拆出来就可以.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p ; p = p-&gt;next-&gt;next) &#123;<br>            <span class="hljs-keyword">auto</span> q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(p-&gt;val);<br>            q-&gt;next = p-&gt;next;<br>            p-&gt;next = q;<br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;random)<br>                p-&gt;next-&gt;random = p-&gt;random-&gt;next;<br>            <span class="hljs-keyword">else</span><br>                p-&gt;next-&gt;random = <span class="hljs-literal">NULL</span>;<br>       &#125;<br>       <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>);<br>       dummy-&gt;next = head;<br>       <span class="hljs-keyword">auto</span> cur = dummy;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next) &#123;<br>            <span class="hljs-keyword">auto</span> q = p-&gt;next;<br>            cur = cur-&gt;next = q;<br>            p-&gt;next = p-&gt;next-&gt;next;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="141-环形链表-easy"><a href="#141-环形链表-easy" class="headerlink" title="141. *环形链表(easy)"></a>141. *环形链表(easy)</h2>
<ul>
<li>检测链表中有没有环:
<ul>
<li>首先特判链表为空, 或者只有一个节点的情况.</li>
<li>之后, 用快慢指针, 快指针一次两个, 慢指针一次一个, 最终相遇, 就证明有环.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        ListNode *p = head, *q = head;        <br>        <span class="hljs-keyword">while</span> (p &amp;&amp; q) &#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (q) q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (p == q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="142-环形链表II-medium"><a href="#142-环形链表II-medium" class="headerlink" title="142. *环形链表II (medium)"></a>142. *环形链表II (medium)</h2>
<ul>
<li>继上一题, 如果要找环形链表的环入口:
<ul>
<li>当快慢指针第一次相遇时, 让慢指针退后到起始点.</li>
<li>然后快指针和慢指针同时向后移动一次, 最终相遇点就是环的入口.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">auto</span> p = head, q = head;<br>        <span class="hljs-keyword">while</span> (p &amp;&amp; q) &#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (q) q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (q &amp;&amp; p == q) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!q) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        p = head;<br>        <span class="hljs-keyword">while</span> (p != q) &#123;<br>            p = p-&gt;next, q = q-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="144-二叉树的前序遍历-medium"><a href="#144-二叉树的前序遍历-medium" class="headerlink" title="144. 二叉树的前序遍历(medium)"></a>144. 二叉树的前序遍历(medium)</h2>
<ul>
<li>递归写法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>迭代写法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="146-LRU缓存-medium"><a href="#146-LRU缓存-medium" class="headerlink" title="146. *LRU缓存(medium)"></a>146. *LRU缓存(medium)</h2>
<ul>
<li>LRU缓存需要用一个双向链表和一个哈希表实现.
<ul>
<li>双向链表: 存储实际的<code>key</code>和<code>value</code>.</li>
<li>哈希表: 用于快速通过<code>key</code>获取双向链表节点的位置.</li>
</ul>
</li>
<li>构造函数逻辑:
<ul>
<li>主要初始化双向链表的哨兵节点.</li>
</ul>
</li>
<li><code>get</code>函数逻辑:
<ul>
<li>首先通过<code>key</code>, 在哈希表中找到节点 (如果节点不存在就直接返回<code>NULL</code>).</li>
<li>然后把这个节点从双向链表中删除, 放到头节点.</li>
</ul>
</li>
<li><code>put</code>函数逻辑:
<ul>
<li>如果哈希表原来存在, 那么就修改, 从双链表中删除, 放到头节点.</li>
<li>如果没有:
<ul>
<li>如果容量满了, 那么就要删除双向链表的尾部节点, 并且从哈希表中清除记录.</li>
<li>从哈希表中创建节点, 然后放到双链表最左侧.</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key, val;<br>        Node *left, *right;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _val): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">val</span>(_val), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>    &#125; *L, *R;<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; hash;<br><br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        n = capacity;<br>        L = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);<br>        R = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);<br>        L-&gt;right = R;<br>        R-&gt;left = L;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node *p)</span> </span>&#123;<br>        p-&gt;right-&gt;left = p-&gt;left;<br>        p-&gt;left-&gt;right = p-&gt;right;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Node *p)</span> </span>&#123;<br>        p-&gt;right = L-&gt;right;<br>        p-&gt;left = L;<br>        L-&gt;right-&gt;left = p;<br>        L-&gt;right = p;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!hash.<span class="hljs-built_in">count</span>(key)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">auto</span> p = hash[key];<br>        <span class="hljs-built_in">remove</span>(p);<br>        <span class="hljs-built_in">insert</span>(p);<br>        <span class="hljs-keyword">return</span> p-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> p = hash[key];<br>            p-&gt;val = value;<br>            <span class="hljs-built_in">remove</span>(p);<br>            <span class="hljs-built_in">insert</span>(p);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">size</span>() == n) &#123;<br>                <span class="hljs-keyword">auto</span> t = R-&gt;left;<br>                <span class="hljs-built_in">remove</span>(t);<br>                hash.<span class="hljs-built_in">erase</span>(t-&gt;key);<br>                <span class="hljs-keyword">delete</span> t;<br>            &#125;<br>            hash[key] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            <span class="hljs-built_in">insert</span>(hash[key]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="153-寻找旋转排序数组中的最小值-medium"><a href="#153-寻找旋转排序数组中的最小值-medium" class="headerlink" title="153. *寻找旋转排序数组中的最小值(medium)"></a>153. *寻找旋转排序数组中的最小值(medium)</h2>
<ul>
<li>假设数组的第一个元素是<code>nums[0]</code>.</li>
<li>数组的前半部分满足<code>nums[i] &gt;= nums[0]</code>, 后半部分满足<code>nums[i] &lt; nums[0]</code>, 以此来二分.</li>
<li>如果数组完全单调递增, 那么最终二分出来的<code>nums[i] &gt;= nums[0]</code>, 此时直接返回<code>nums[0]</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> t = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= t) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[l] &gt;= nums[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nums[l];<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="155-最小栈-medium"><a href="#155-最小栈-medium" class="headerlink" title="155. 最小栈(medium)"></a>155. 最小栈(medium)</h2>
<ul>
<li>直接开另外一个栈来维护最小值即可:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk_min;<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stk_min.<span class="hljs-built_in">empty</span>() || val &lt;= stk_min.<span class="hljs-built_in">top</span>()) stk_min.<span class="hljs-built_in">push</span>(val);<br>        stk.<span class="hljs-built_in">push</span>(val);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (stk_min.<span class="hljs-built_in">top</span>() == stk.<span class="hljs-built_in">top</span>()) stk_min.<span class="hljs-built_in">pop</span>();<br>        stk.<span class="hljs-built_in">pop</span>(); <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stk_min.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="160-相交链表-easy"><a href="#160-相交链表-easy" class="headerlink" title="160. *相交链表(easy)"></a>160. *相交链表(easy)</h2>
<ul>
<li>思路:
<ul>
<li>让两个指针同时向前走一步, 如果有一个指针走到尽头, 那么就把它放到第二个指针的头部继续走.</li>
<li>当两个指针相同时, 如果不为NULL, 那么就是相遇点, 否则就不是.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur1 = headA, cur2 = headB;<br>        <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;<br>            <span class="hljs-keyword">if</span> (cur1) cur1 = cur1-&gt;next;<br>            <span class="hljs-keyword">else</span> cur1 = headB;<br>            <br>            <span class="hljs-keyword">if</span> (cur2) cur2 = cur2-&gt;next;<br>            <span class="hljs-keyword">else</span> cur2 = headA;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur1 == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> cur1;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="189-轮转数组-medium"><a href="#189-轮转数组-medium" class="headerlink" title="189 *轮转数组(medium)"></a>189 *轮转数组(medium)</h2>
<ul>
<li>思路: 反转数组的不同部分即可, 注意轮转的次数<code>k</code>要对数组的长度取模.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        k = k % nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">begin</span>() + k);<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + k, nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="198-打家劫舍-medium"><a href="#198-打家劫舍-medium" class="headerlink" title="198. *打家劫舍 (medium)"></a>198. *打家劫舍 (medium)</h2>
<ul>
<li>如何判断一个问题是否是DP?
<ul>
<li>首先, 是求最优解.</li>
<li>其次, 可能的方案数是指数级别.</li>
</ul>
</li>
<li>状态机DP: <code>f[i][0]</code>表示第<code>i</code>个房子不打劫, <code>f[i][1]</code>表示打劫, 从后向前递推:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            f[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            f[i][<span class="hljs-number">1</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(f[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="199-二叉树的右视图-medium"><a href="#199-二叉树的右视图-medium" class="headerlink" title="199. *二叉树的右视图(medium)"></a>199. *二叉树的右视图(medium)</h2>
<ul>
<li>右视图序列就是层序遍历中每一层最后一个节点组成的序列.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (i == len - <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="200-岛屿数量-medium"><a href="#200-岛屿数量-medium" class="headerlink" title="200. *岛屿数量 (medium)"></a>200. *岛屿数量 (medium)</h2>
<ul>
<li>Flood Fill算法:
<ul>
<li>每次遇到一块陆地, 就从这个陆地为起点进行搜索, 从这个起点向四周扩散, 如果再次遇到陆地, 就递归搜索.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; g;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        g = grid;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g.<span class="hljs-built_in">size</span>(); i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; g[i].<span class="hljs-built_in">size</span>(); j ++)<br>                <span class="hljs-keyword">if</span> (g[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                    <span class="hljs-built_in">dfs</span>(i, j), ans ++;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        g[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; g.<span class="hljs-built_in">size</span>() &amp;&amp; b &gt;= <span class="hljs-number">0</span> &amp;&amp; b &lt; g[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &amp;&amp; g[a][b] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                <span class="hljs-built_in">dfs</span>(a, b);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="206-反转链表-easy"><a href="#206-反转链表-easy" class="headerlink" title="206. *反转链表(easy)"></a>206. *反转链表(easy)</h2>
<ul>
<li>递归方法: 注意先判断链表是否是空/只有一个节点.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> tail = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代方法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *p = <span class="hljs-literal">NULL</span>;<br>        ListNode *q = head;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">auto</span> r = q-&gt;next;<br>            q-&gt;next = p;<br>            p = q, q = r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="207-课程表-medium"><a href="#207-课程表-medium" class="headerlink" title="207. *课程表(medium)"></a>207. *课程表(medium)</h2>
<ul>
<li>从先修课程到后置课程连接一条有向边.</li>
<li>然后用拓扑排序, 所有入度为0的节点先入队, 然后BFS, 每次扩展一层就把入度-1, 然后再次把入度为0的点入队.</li>
<li>如果拓扑排序能把所有点遍历完全, 那么就证明符合要求.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = numCourses;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e: prerequisites) &#123;<br>            <span class="hljs-type">int</span> a = e[<span class="hljs-number">1</span>], b = e[<span class="hljs-number">0</span>];<br>            g[a].<span class="hljs-built_in">push_back</span>(b);<br>            d[b] ++;<br>        &#125;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span> (d[i] == <span class="hljs-number">0</span>)<br>                q.<span class="hljs-built_in">push</span>(i);<br><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> u: g[t])<br>                <span class="hljs-keyword">if</span> (-- d[u] == <span class="hljs-number">0</span>)<br>                    q.<span class="hljs-built_in">push</span>(u);<br>            cnt ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt == n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="208-实现Trie-前缀树"><a href="#208-实现Trie-前缀树" class="headerlink" title="208. *实现Trie(前缀树)"></a>208. *实现Trie(前缀树)</h2>
<ul>
<li>前缀树模板题.</li>
<li>前缀树存储的元素需要有固定的字符集进行编码, 假设字符集中的元素个数为n, 那么前缀树就是一个n叉树.</li>
<li>n叉树的节点有两个成员变量:
<ul>
<li>一个用来存储所有的儿子.</li>
<li>另一个用来存储这个节点是否是某个元素的结尾.</li>
</ul>
</li>
<li>查询和插入都是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-5-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-5-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-5-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-5-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-5-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-5-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-5-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-5-TEX-N-29"/></g></g></g></svg>的时间复杂度, 其中<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-6-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-6-TEX-I-1D45B"/></g></g></g></svg>是字符集元素的个数.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        Node *son[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">bool</span> is_end;<br><br>        <span class="hljs-built_in">Node</span>() &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i ++) son[i] = <span class="hljs-literal">NULL</span>;<br>            is_end = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125; *root;<br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: word) &#123;<br>            <span class="hljs-type">int</span> u = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (!p-&gt;son[u]) p-&gt;son[u] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>            p = p-&gt;son[u];<br>        &#125;<br>        p-&gt;is_end = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: word) &#123;<br>            <span class="hljs-type">int</span> u = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (!p-&gt;son[u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p-&gt;son[u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p-&gt;is_end;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: prefix) &#123;<br>            <span class="hljs-type">int</span> u = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (!p-&gt;son[u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p-&gt;son[u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="215-数组中的第K个最大元素-medium"><a href="#215-数组中的第K个最大元素-medium" class="headerlink" title="215. *数组中的第K个最大元素(medium)"></a>215. *数组中的第K个最大元素(medium)</h2>
<ul>
<li>首先注意题目要求是第k个最大, 还是第k个最小.</li>
<li>本题是快速选择算法.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k); <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> nums[l];<br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = nums[l + (r - l) / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (nums[ ++ i] &gt; x);<br>            <span class="hljs-keyword">while</span> (nums[ --j] &lt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k &lt;= sl) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(nums, l, j, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(nums, j + <span class="hljs-number">1</span>, r, k - sl);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树-easy"><a href="#226-翻转二叉树-easy" class="headerlink" title="226. *翻转二叉树(easy)"></a>226. *翻转二叉树(easy)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        root-&gt;left = right;<br>        root-&gt;right = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. *二叉搜索树中第K小的元素"></a>230. *二叉搜索树中第K小的元素</h2>
<ul>
<li>中序遍历的过程中记录遍历节点的次数即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> k, ans;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> _k)</span> </span>&#123;<br>        k = _k;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(root-&gt;left)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (-- k == <span class="hljs-number">0</span>) &#123;<br>            ans = root-&gt;val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. *回文链表"></a>234. *回文链表</h2>
<ul>
<li>首先, 找到链表的中间节点.</li>
<li>之后, 将中间节点后面的链表反转.</li>
<li>然后, 将反转部分的链表和前半部分的链表进行对比即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">auto</span> cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) &#123;<br>            cnt ++;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        cnt = cnt % <span class="hljs-number">2</span> ? cnt / <span class="hljs-number">2</span> : cnt / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br><br>        cur = head;<br>        <span class="hljs-keyword">while</span> (cnt --) cur = cur-&gt;next;<br><br>        ListNode *p = <span class="hljs-literal">NULL</span>;<br>        ListNode *q = cur-&gt;next;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">auto</span> r = q-&gt;next;<br>            q-&gt;next = p;<br>            p = q, q = r;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> l1 = head, l2 = p;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val != l2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            l1 = l1-&gt;next, l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. *二叉树的最近公共祖先"></a>236. *二叉树的最近公共祖先</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode *ans = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, p, q);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// root子树是否含有p, q, 都不含00, 有p: 01, 有q: 10, 都有11</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> state = <span class="hljs-built_in">dfs</span>(root-&gt;left, p, q);<br>        <span class="hljs-keyword">if</span> (root == p) state |= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root == q) state |= <span class="hljs-number">2</span>;<br>        state |= <span class="hljs-built_in">dfs</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">3</span> &amp;&amp; !ans) ans = root;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. *除自身以外数组的乘积"></a>238. *除自身以外数组的乘积</h2>
<ul>
<li>思路: 原地算法
<ul>
<li>首先维护一个类似前缀和的数组, <code>s[i]</code>表示从<code>nums[0]</code>乘到<code>nums[i - 1]</code>.</li>
<li>然后用一个<code>suffix</code>维护后缀积, 遍历乘一遍, 直接赋值到前缀和数组就可以.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) s[i] = s[i - <span class="hljs-number">1</span>] * nums[i - <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-type">int</span> suffix = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            s[i] *= suffix;<br>            suffix *= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="239-滑动窗口最大值-hard"><a href="#239-滑动窗口最大值-hard" class="headerlink" title="239. *滑动窗口最大值(hard)"></a>239. *滑动窗口最大值(hard)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>        <span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) hh ++;<br>            <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; nums[i] &gt; nums[q[tt]]) tt --;<br>            q[ ++ tt] = i;<br>            <span class="hljs-keyword">if</span> (i - k + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ans.<span class="hljs-built_in">push_back</span>(nums[q[hh]]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="240-搜索二维矩阵"><a href="#240-搜索二维矩阵" class="headerlink" title="240. *搜索二维矩阵"></a>240. *搜索二维矩阵</h2>
<ul>
<li>拿右上角/左下角的元素作为基准进行搜索即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[x][y] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[x][y] &gt; target) y --;<br>            <span class="hljs-keyword">else</span> x ++;<br>       &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="283-移动0-medium"><a href="#283-移动0-medium" class="headerlink" title="283. *移动0(medium)"></a>283. *移动0(medium)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (x) nums[k ++] = x;<br>       &#125;<br>       <span class="hljs-keyword">while</span> (k &lt; nums.<span class="hljs-built_in">size</span>()) nums[k ++] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="295-数据流的中位数-hard"><a href="#295-数据流的中位数-hard" class="headerlink" title="295. *数据流的中位数(hard)"></a>295. *数据流的中位数(hard)</h2>
<ul>
<li>用<code>up</code>: 小根堆和<code>down</code>: 大根堆来维护.</li>
<li>如果一个数小于等于<code>down.top()</code>那么就插到<code>down</code>中, 否则就插到<code>up</code>中.</li>
<li>然后需要动态维护<code>down</code>和<code>up</code>的大小, 保证<code>down</code>和<code>up</code>大小相等, 或者<code>down.size() - up.size() = 1</code>.</li>
<li>这样就能维护中位数的边界.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; up;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; down;<br><br>    <span class="hljs-built_in">MedianFinder</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (down.<span class="hljs-built_in">empty</span>() || num &lt;= down.<span class="hljs-built_in">top</span>()) &#123;<br>            down.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (down.<span class="hljs-built_in">size</span>() &gt; up.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) &#123;<br>                up.<span class="hljs-built_in">push</span>(down.<span class="hljs-built_in">top</span>());<br>                down.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            up.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (up.<span class="hljs-built_in">size</span>() &gt; down.<span class="hljs-built_in">size</span>()) &#123;<br>                down.<span class="hljs-built_in">push</span>(up.<span class="hljs-built_in">top</span>());<br>                up.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = up.<span class="hljs-built_in">size</span>() + down.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> down.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> (up.<span class="hljs-built_in">top</span>() + down.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="347-前k个高频元素-medium"><a href="#347-前k个高频元素-medium" class="headerlink" title="347. *前k个高频元素(medium)"></a>347. *前k个高频元素(medium)</h2>
<ul>
<li>首先统计一下数组中各个元素出现的次数.</li>
<li>然后, 用计数排序的思想, 开一个<code>n + 1</code>长度的数组, 数组下标表示出现次数, 这个数组存储出现次数为<code>i</code>的元素有<code>nums[i]</code>种.</li>
<li>然后反向遍历这个计数排序的数组即可得到答案.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums) hash[x] ++;<br><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, c]: hash) cnt[c] ++;<br><br>        <span class="hljs-type">int</span> i = n, t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (t &lt; k) t += cnt[i --];<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, c]: hash)<br>            <span class="hljs-keyword">if</span> (c &gt; i)<br>                ans.<span class="hljs-built_in">push_back</span>(x);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="394-字符串解码-medium"><a href="#394-字符串解码-medium" class="headerlink" title="394. *字符串解码(medium)"></a>394. *字符串解码(medium)</h2>
<ul>
<li>这类题是一种前缀表达式的计算问题, 通用思路是用<code>dfs</code>.
<ul>
<li><code>dfs</code>中, 用一个引用变量<code>u</code>记录处理到表达式的哪个位置.</li>
<li>如果遇到算符, 就需要递归地把运算数计算出来.</li>
<li>如果遇到运算数的一部分, 就需要把所有运算数进行拼接.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string s;<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string _s)</span> </span>&#123;<br>        s = _s;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(u);<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;u)</span> </span>&#123;<br>        string ans;<br>        <span class="hljs-keyword">while</span> (u &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[u] != <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[u])) &#123;<br>               <span class="hljs-type">int</span> k = u;<br>               <span class="hljs-keyword">while</span> (k &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[k])) k ++;<br>               <span class="hljs-type">int</span> cnt = <span class="hljs-built_in">stoi</span>(s.<span class="hljs-built_in">substr</span>(u, k - u));<br>               u = k + <span class="hljs-number">1</span>;<br>               string res = <span class="hljs-built_in">dfs</span>(u);<br>               u ++; <span class="hljs-comment">// 过滤]</span><br>               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++) ans += res; <br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[u] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[u] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || s[u] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[u] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) ans += s[u ++];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="437-路径总和-medium"><a href="#437-路径总和-medium" class="headerlink" title="437. *路径总和 (medium)"></a>437. *路径总和 (medium)</h2>
<ul>
<li>首先, 这道题类似于前缀和:
<ul>
<li>要求在前缀和数组<code>s</code>中找到<code>l, r</code>, 使得<code>s[r] - s[l - 1] = k</code>.</li>
<li>也就是当遍历到<code>s[i]</code>时, 要在之前的<code>0&lt;= j &lt; i</code>中, 找到一个<code>s[j]</code>, 使得<code>s[j] = s[i] - k</code>.</li>
<li>那么直接在之前用哈希表存储每一个<code>s[j]</code>就可以了, 当遍历到<code>s[i]</code>, 就查有没有符合题意的<code>s[j]</code>.</li>
</ul>
</li>
<li>注意: 前缀和容易超出<code>int</code>范围, 需要用<code>long long</code>存储.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    unordered_map&lt;LL, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-comment">// 0是前缀和中的0位置的元素 </span><br>        hash[<span class="hljs-number">0</span>]++;<br>        <span class="hljs-built_in">dfs</span>(root, targetSum, (LL)<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> sum, LL cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        cur += root-&gt;val;<br>        res += hash[cur - sum];<br>        hash[cur] ++;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, sum, cur), <span class="hljs-built_in">dfs</span>(root-&gt;right, sum, cur);<br>        hash[cur] --;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="438-找到字符串中所有字母异位词-medium"><a href="#438-找到字符串中所有字母异位词-medium" class="headerlink" title="438 *找到字符串中所有字母异位词(medium)"></a>438 *找到字符串中所有字母异位词(medium)</h2>
<ul>
<li>思路:
<ul>
<li>判断两个字符串是否是字母异位词的充要条件是: 两个字符串的字符出现种类, 以及次数相同.</li>
<li>直接维护一个<code>p.size()</code>的滑动窗口, 判断滑动窗口内的子串是否和<code>p</code>是字母异位词即可.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>       unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : p) hash[c] ++;<br>       <span class="hljs-type">int</span> tot = hash.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// p中有多少种字符</span><br>       <br>       <span class="hljs-comment">// 符合条件的字符种类数目</span><br>       <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>       vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>         <span class="hljs-comment">// 处理滑动窗口边界</span><br>            <span class="hljs-keyword">if</span> (i - j + <span class="hljs-number">1</span> &gt; p.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-keyword">if</span> (hash[s[j]] == <span class="hljs-number">0</span>) k --;<br>                hash[s[j ++]] ++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (--hash[s[i]] == <span class="hljs-number">0</span>) k ++;<br>            <span class="hljs-keyword">if</span> (k == tot) ans.<span class="hljs-built_in">push_back</span>(j);<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="543-二叉树的直径-easy"><a href="#543-二叉树的直径-easy" class="headerlink" title="543. *二叉树的直径(easy)"></a>543. *二叉树的直径(easy)</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>  <span class="hljs-comment">// dfs的意思是, 从root出发, 包括root, 到达底部的最长路径上节点的个数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left), right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>      <span class="hljs-comment">// 其实应该是left + right  + 1 - 1, +1表示加上root这个点, -1表示求边数</span><br>        ans = <span class="hljs-built_in">max</span>(ans, left + right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="560-和为k的子数组-medium"><a href="#560-和为k的子数组-medium" class="headerlink" title="560. *和为k的子数组 (medium)"></a>560. *和为k的子数组 (medium)</h2>
<ul>
<li>思路: 假设前缀和数组是<code>s</code>, 问题就等价于前缀和数组中是否存在<code>s[r] - s[l - 1] = k</code>, 和两数之和本质相同.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) &#123;<br>            res += hash[s[i] - k];<br>            hash[s[i]] ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="739-每日温度-medium"><a href="#739-每日温度-medium" class="headerlink" title="739. *每日温度(medium)"></a>739. *每日温度(medium)</h2>
<ul>
<li>单调栈问题可以用<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-7-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-7-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-7-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-7-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-7-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-7-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-7-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-7-TEX-N-29"/></g></g></g></svg>的时间复杂度求出一个元素左侧/右侧比他大/小, /具有单调性的最近的元素.</li>
<li>如果要找到右边第一个比他大的元素, 那么在遍历它之前, 就需要有右侧的先验知识, 因此从右向左维护单调栈.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; t)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>() &amp;&amp; t[i] &gt;= t[stk.<span class="hljs-built_in">top</span>()]) stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>())<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">else</span><br>                ans.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>() - i);<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="763-划分字母区间-medium"><a href="#763-划分字母区间-medium" class="headerlink" title="763. *划分字母区间(medium)"></a>763. *划分字母区间(medium)</h2>
<ul>
<li>这道题的本质是区间问题, 对于每一种字符, 都有一个开始和结束位置, 这个位置看成一个一个区间, 最终合并区间就是分割方案.</li>
<li>实际上只需维护一个所有区间能到达的最右范围<code>end</code>, 从前向后遍历, 如果最右范围<code>end = i</code>, 那么就说明<code>[0, i]</code>这一段已经和后面一段不可能产生交集, 因此就可以作为一个合法分割.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> last[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) last[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br><br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            end = <span class="hljs-built_in">max</span>(end, last[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (end == i) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(end - start + <span class="hljs-number">1</span>);<br>                start = end = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="994-腐烂的🍊-medium"><a href="#994-腐烂的🍊-medium" class="headerlink" title="994. *腐烂的🍊 (medium)"></a>994. *腐烂的🍊 (medium)</h2>
<ul>
<li>多源BFS问题:
<ul>
<li>直接把腐烂的橘子放入队列中宽搜即可.</li>
<li>注意一个逻辑, 在队列中统计的是BFS的层数, 最终的答案应该是层数 - 1, 而且注意, 这个层数- 1应该是建立在队列中一开始有东西的前提下, 如果一开始就没有东西, 那么直接返回0.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        queue&lt;PII&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>)<br>                    q.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>        <br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>()) res --;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (len --) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>                    <span class="hljs-type">int</span> a = t.x + dx[i], b = t.y + dy[i];<br>                    <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m || grid[a][b] != <span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">continue</span>;<br>                    grid[a][b] = <span class="hljs-number">2</span>;<br>                    q.<span class="hljs-built_in">push</span>(&#123;a, b&#125;);<br>                &#125;<br>            &#125;<br>            res ++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

      
       <hr><span style="font-style: italic;color: gray;"> 向阳而生, 喜欢聪明的人. </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©B1ueDrops
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
