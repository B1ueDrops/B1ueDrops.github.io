<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>LeetCode-1000题题解 | B1ueDrops</title>
  <meta name="keywords" content="">
  <meta name="description" content="LeetCode-1000题题解 | B1ueDrops">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="Basic Question  监督学习:   给定一个矩阵$X &#x3D; [x_1, x_2, …, x_m] \in R^{n\times m}$, 和一个结果矩阵$Y \in R^{n \times 1}$  $n$是样本的个数. $m$是feature的个数.   用这个矩阵$X$作为训练集, 得到一个拟合函数$f$, 输入新的样本$x_i \in R^{1 \times m}$, 经过$y &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="基础机器学习的一些内容">
<meta property="og:url" content="https://b1uedrops.github.io/2024/11/25/ml/index.html">
<meta property="og:site_name" content="B1ueDrops">
<meta property="og:description" content="Basic Question  监督学习:   给定一个矩阵$X &#x3D; [x_1, x_2, …, x_m] \in R^{n\times m}$, 和一个结果矩阵$Y \in R^{n \times 1}$  $n$是样本的个数. $m$是feature的个数.   用这个矩阵$X$作为训练集, 得到一个拟合函数$f$, 输入新的样本$x_i \in R^{1 \times m}$, 经过$y &#x3D;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-11-25T08:02:38.494Z">
<meta property="article:modified_time" content="2024-11-25T12:45:03.429Z">
<meta property="article:author" content="B1ueDrops">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpeg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpeg"/>
</a>
<div class="author">
    <span>B1ueDrops</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/B1ueDrops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:bluedrops@yeah.net"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2381446488&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(94)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="编程语言">
            
            编程语言
            <small>(10)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="操作系统">
            
            操作系统
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="后端技术">
            
            后端技术
            <small>(19)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="金融知识">
            
            金融知识
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            
            开发工具
            <small>(6)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="数学">
            
            数学
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(24)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="体系结构">
            
            体系结构
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="AI-HPC">
            
            AI-HPC
            <small>(12)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="English">
            
            English
            <small>(9)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="94">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All AI-HPC "
           href="/2024/11/25/ml/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基础机器学习的一些内容">基础机器学习的一些内容</span>
            <span class="post-date" title="2024-11-25 16:02:38">2024/11/25</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/11/25/pytorch_quant/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AI模型量化的理论和实现">AI模型量化的理论和实现</span>
            <span class="post-date" title="2024-11-25 15:54:55">2024/11/25</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/11/25/pytorch_arch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Pytorch的前后端架构">Pytorch的前后端架构</span>
            <span class="post-date" title="2024-11-25 15:54:48">2024/11/25</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/11/21/cuda_env/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CUDA理论和实战">CUDA理论和实战</span>
            <span class="post-date" title="2024-11-21 13:11:31">2024/11/21</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/11/09/valuable-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="其他的算法题题解">其他的算法题题解</span>
            <span class="post-date" title="2024-11-09 18:21:12">2024/11/09</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/11/09/jianzhi_offer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="《剑指Offer》题解">《剑指Offer》题解</span>
            <span class="post-date" title="2024-11-09 18:17:29">2024/11/09</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/11/07/cpu_gemm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CPU后端上的GEMM优化">CPU后端上的GEMM优化</span>
            <span class="post-date" title="2024-11-07 14:16:48">2024/11/07</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/11/07/time_complexity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="时间复杂度的一些知识">时间复杂度的一些知识</span>
            <span class="post-date" title="2024-11-07 12:12:58">2024/11/07</span>
        </a>
        
        
        <a  class="All 数学 "
           href="/2024/11/07/kalman/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡尔曼滤波数学推导">卡尔曼滤波数学推导</span>
            <span class="post-date" title="2024-11-07 12:08:35">2024/11/07</span>
        </a>
        
        
        <a  class="All 数学 "
           href="/2024/11/07/linear_algebra/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性代数">线性代数</span>
            <span class="post-date" title="2024-11-07 12:08:22">2024/11/07</span>
        </a>
        
        
        <a  class="All 数学 "
           href="/2024/11/07/quaternion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="描述旋转的几种方式">描述旋转的几种方式</span>
            <span class="post-date" title="2024-11-07 12:08:01">2024/11/07</span>
        </a>
        
        
        <a  class="All 数学 "
           href="/2024/11/07/signal_process/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="信号与系统">信号与系统</span>
            <span class="post-date" title="2024-11-07 12:07:42">2024/11/07</span>
        </a>
        
        
        <a  class="All 数学 "
           href="/2024/11/07/probability/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="概率论与数理统计">概率论与数理统计</span>
            <span class="post-date" title="2024-11-07 12:07:18">2024/11/07</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/10/31/acwing_basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AcWing算法基础课题解">AcWing算法基础课题解</span>
            <span class="post-date" title="2024-10-31 20:05:59">2024/10/31</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/10/31/acwing_improve/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AcWing算法提高课题解">AcWing算法提高课题解</span>
            <span class="post-date" title="2024-10-31 19:36:46">2024/10/31</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/10/27/leetcode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LeetCode-1000题题解">LeetCode-1000题题解</span>
            <span class="post-date" title="2024-10-27 11:06:02">2024/10/27</span>
        </a>
        
        
        <a  class="All 金融知识 "
           href="/2024/10/14/economics/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="资源与可持续发展">资源与可持续发展</span>
            <span class="post-date" title="2024-10-14 12:41:46">2024/10/14</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/09/27/jetbrains/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jetbrains系列IDE的使用方式">Jetbrains系列IDE的使用方式</span>
            <span class="post-date" title="2024-09-27 22:37:32">2024/09/27</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/22/x86_arch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="x86-CPU的体系结构基础">x86-CPU的体系结构基础</span>
            <span class="post-date" title="2024-09-22 13:23:27">2024/09/22</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/20/program_time/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="理解程序运行的时间">理解程序运行的时间</span>
            <span class="post-date" title="2024-09-20 14:22:52">2024/09/20</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/transformer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Transformer的工作原理">Transformer的工作原理</span>
            <span class="post-date" title="2024-09-17 14:16:16">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/roofline_model/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="性能分析的Roofline Model">性能分析的Roofline Model</span>
            <span class="post-date" title="2024-09-17 14:16:00">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/ai_basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AI的基本模型和实现">AI的基本模型和实现</span>
            <span class="post-date" title="2024-09-17 14:14:52">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/welford/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Welford算法计算方差">Welford算法计算方差</span>
            <span class="post-date" title="2024-09-17 14:14:12">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/data-augmentation-metric/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="理解数据增广的本质">理解数据增广的本质</span>
            <span class="post-date" title="2024-09-17 14:14:03">2024/09/17</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/09/10/design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="设计模式的实际操作">设计模式的实际操作</span>
            <span class="post-date" title="2024-09-10 18:29:51">2024/09/10</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/09/08/windows_msys2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Windows环境配置">Windows环境配置</span>
            <span class="post-date" title="2024-09-08 13:53:44">2024/09/08</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/09/06/network_application_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-应用层">计算机网络-应用层</span>
            <span class="post-date" title="2024-09-06 14:31:30">2024/09/06</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/09/06/network_tcp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-传输层">计算机网络-传输层</span>
            <span class="post-date" title="2024-09-06 14:31:18">2024/09/06</span>
        </a>
        
        
        <a  class="All 操作系统 "
           href="/2024/08/16/concurrent_sketch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="并发编程的概述">并发编程的概述</span>
            <span class="post-date" title="2024-08-16 13:48:22">2024/08/16</span>
        </a>
        
        
        <a  class="All 操作系统 "
           href="/2024/08/16/multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多进程/多线程编程模型">多进程/多线程编程模型</span>
            <span class="post-date" title="2024-08-16 13:48:12">2024/08/16</span>
        </a>
        
        
        <a  class="All 操作系统 "
           href="/2024/08/16/linux_process/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux上的进程控制">Linux上的进程控制</span>
            <span class="post-date" title="2024-08-16 13:48:03">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/network_network_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-网络层">计算机网络-网络层</span>
            <span class="post-date" title="2024-08-16 13:46:58">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/network_datalink_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-数据链路层">计算机网络-数据链路层</span>
            <span class="post-date" title="2024-08-16 13:46:50">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/tcp_stick/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何解决TCP粘包问题">如何解决TCP粘包问题</span>
            <span class="post-date" title="2024-08-16 13:46:38">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/vimium/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Chrome中vimium键位">Chrome中vimium键位</span>
            <span class="post-date" title="2024-08-16 13:46:08">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/yabai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="yabai窗口管理器键位配置">yabai窗口管理器键位配置</span>
            <span class="post-date" title="2024-08-16 13:45:41">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/lazygit/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="试用LazyGit进行版本控制">试用LazyGit进行版本控制</span>
            <span class="post-date" title="2024-08-16 13:45:31">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/tmux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tmux键位配置">tmux键位配置</span>
            <span class="post-date" title="2024-08-16 13:45:09">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/build_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创建型的设计模式">创建型的设计模式</span>
            <span class="post-date" title="2024-08-16 13:35:12">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/behaviour_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="行为型的设计模式">行为型的设计模式</span>
            <span class="post-date" title="2024-08-16 13:35:00">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/combine_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="组合型的设计模式">组合型的设计模式</span>
            <span class="post-date" title="2024-08-16 13:33:52">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/dns/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DNS-客户端连接到机房的技术">DNS-客户端连接到机房的技术</span>
            <span class="post-date" title="2024-08-16 13:33:38">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/lvs_nginx/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LVS/Nginx-服务器调度的技术">LVS/Nginx-服务器调度的技术</span>
            <span class="post-date" title="2024-08-16 13:33:27">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/service_discovery/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="服务发现架构设计">服务发现架构设计</span>
            <span class="post-date" title="2024-08-16 13:33:15">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/storage_rpc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="存储微服务的架构">存储微服务的架构</span>
            <span class="post-date" title="2024-08-16 13:33:00">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/mq/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="消息中间件技术">消息中间件技术</span>
            <span class="post-date" title="2024-08-16 13:32:10">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/concurrent_arch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="高并发架构通用设计">高并发架构通用设计</span>
            <span class="post-date" title="2024-08-16 13:31:33">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/10/data_replication_center/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机房高可用技术">机房高可用技术</span>
            <span class="post-date" title="2024-08-10 20:04:18">2024/08/10</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/07/05/parser/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="编译原理-Parser的知识合集">编译原理-Parser的知识合集</span>
            <span class="post-date" title="2024-07-05 16:29:19">2024/07/05</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/07/04/raii/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="资源管理中RAII的概念">资源管理中RAII的概念</span>
            <span class="post-date" title="2024-07-04 16:16:39">2024/07/04</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/07/04/char_encode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="字符集与字符编码的深度理解">字符集与字符编码的深度理解</span>
            <span class="post-date" title="2024-07-04 11:32:31">2024/07/04</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/07/04/ieee_754/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="体系结构中的浮点数">体系结构中的浮点数</span>
            <span class="post-date" title="2024-07-04 11:24:35">2024/07/04</span>
        </a>
        
        
        <a  class="All 金融知识 "
           href="/2024/05/22/quant_analysis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="金融量化分析模型">金融量化分析模型</span>
            <span class="post-date" title="2024-05-22 18:08:38">2024/05/22</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/17/car-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="汽车英语">汽车英语</span>
            <span class="post-date" title="2024-05-17 13:37:34">2024/05/17</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/14/regular_expression/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="正则表达式原理和实战">正则表达式原理和实战</span>
            <span class="post-date" title="2024-05-14 20:14:59">2024/05/14</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/13/restaurant_english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="饭店英语">饭店英语</span>
            <span class="post-date" title="2024-05-13 20:25:52">2024/05/13</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/12/frontend-lang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="使用Vue快速搭建网站原型">使用Vue快速搭建网站原型</span>
            <span class="post-date" title="2024-05-12 21:13:45">2024/05/12</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/12/hotel-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="酒店英语">酒店英语</span>
            <span class="post-date" title="2024-05-12 12:29:02">2024/05/12</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/10/airport-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机场英语">机场英语</span>
            <span class="post-date" title="2024-05-10 10:12:57">2024/05/10</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/09/practical-go/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Go语言原理与实战">Go语言原理与实战</span>
            <span class="post-date" title="2024-05-09 20:48:25">2024/05/09</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/05/09/database-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostgreSQL数据库教程">PostgreSQL数据库教程</span>
            <span class="post-date" title="2024-05-09 20:24:37">2024/05/09</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/05/09/cache-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cache的基础知识与设计策略">Cache的基础知识与设计策略</span>
            <span class="post-date" title="2024-05-09 20:12:19">2024/05/09</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/13/practical-rust/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust原理与实战">Rust原理与实战</span>
            <span class="post-date" title="2024-04-13 17:05:26">2024/04/13</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/07/python_many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python原理与实战">Python原理与实战</span>
            <span class="post-date" title="2024-04-07 10:46:59">2024/04/07</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/30/binary-tree/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二叉树系列">二叉树系列</span>
            <span class="post-date" title="2024-03-30 17:07:34">2024/03/30</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/24/data-struct/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构系列">数据结构系列</span>
            <span class="post-date" title="2024-03-24 14:10:22">2024/03/24</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/shell_script/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shell脚本基础与实战">Shell脚本基础与实战</span>
            <span class="post-date" title="2024-03-22 12:50:32">2024/03/22</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/modern_cpp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Modern C++基础与实战">Modern C++基础与实战</span>
            <span class="post-date" title="2024-03-22 11:31:11">2024/03/22</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/linear-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性DP">线性DP</span>
            <span class="post-date" title="2024-03-20 18:11:22">2024/03/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/tree-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="树形DP">树形DP</span>
            <span class="post-date" title="2024-03-20 18:10:56">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-method/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Methodology">英语科技论文写作模型-Methodology</span>
            <span class="post-date" title="2024-03-20 16:53:17">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-abstract/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Abstract">英语科技论文写作模型-Abstract</span>
            <span class="post-date" title="2024-03-20 16:49:54">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-conclusion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Conclusion">英语科技论文写作模型-Conclusion</span>
            <span class="post-date" title="2024-03-20 16:49:46">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-results/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Results">英语科技论文写作模型-Results</span>
            <span class="post-date" title="2024-03-20 16:49:31">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/19/sci-writing-introduction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Introduction">英语科技论文写作模型-Introduction</span>
            <span class="post-date" title="2024-03-19 10:16:07">2024/03/19</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/10/catalan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡特兰数系列">卡特兰数系列</span>
            <span class="post-date" title="2024-03-10 12:47:19">2024/03/10</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/03/knapsack/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="背包问题">背包问题</span>
            <span class="post-date" title="2024-03-03 16:22:21">2024/03/03</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/03/02/virtualmem/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="虚拟内存的基础知识和设计">虚拟内存的基础知识和设计</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/sim-plus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="高精度加减乘除">高精度加减乘除</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/prefix-sum-diff/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前缀和/差分">前缀和/差分</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/parathesis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="括号序列">括号序列</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/other-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="其他算法/模拟题">其他算法/模拟题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/mathematic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数学问题">数学问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/interval/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="区间问题">区间问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/graph/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="图论">图论</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/greedy/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="贪心算法">贪心算法</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/dfs/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深度优先搜索">深度优先搜索</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/03/02/cache-coherence/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="缓存一致性">缓存一致性</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/catch-rain/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="接雨水问题">接雨水问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/bfs/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="广度优先搜索">广度优先搜索</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/binary-search/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二分系列">二分系列</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/03/01/clean_code/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码整洁之道">代码整洁之道</span>
            <span class="post-date" title="2024-03-01 14:30:08">2024/03/01</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/03/01/software_rule/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面向对象设计的基本原则">面向对象设计的基本原则</span>
            <span class="post-date" title="2024-03-01 14:30:02">2024/03/01</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-leetcode" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">LeetCode-1000题题解</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="算法">算法</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-11-11 19:52:18'>2024-10-27 11:06</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-easy"><span class="toc-text">1. *两数之和(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-easy"><span class="toc-text">2. *两数相加 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-medium"><span class="toc-text">3. *无重复字符的最长子串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-hard"><span class="toc-text">4. 寻找两个正序数组的中位数(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-medium"><span class="toc-text">5. 最长回文子串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8-medium"><span class="toc-text">11. *盛水最多的容器(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">15. *三数之和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">16. 最接近的三数之和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-medium"><span class="toc-text">17. *电话号码的字母组合(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">18. 四数之和 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-medium"><span class="toc-text">19. *删除链表的倒数第n个节点(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-easy"><span class="toc-text">20. *有效的括号(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">21. *合并两个有序的链表 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90-medium"><span class="toc-text">22. *括号生成(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-hard"><span class="toc-text">23. *合并K个升序链表(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-medium"><span class="toc-text">24. *两两交换链表中的节点(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-hard"><span class="toc-text">25. *K个一组翻转链表(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-medium"><span class="toc-text">31. *下一个排列 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-medium"><span class="toc-text">34. *在排序数组中查找元素的第一个和最后一个位置(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-easy"><span class="toc-text">35. *搜索插入位置(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97-medium"><span class="toc-text">38. 外观数列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-medium"><span class="toc-text">39. *组合总和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0-medium"><span class="toc-text">41. *缺失的第一个正数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-hard"><span class="toc-text">42. *接雨水(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII-medium"><span class="toc-text">45. *跳跃游戏II(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97-medium"><span class="toc-text">46. *全排列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-medium"><span class="toc-text">48. *旋转图像(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-medium"><span class="toc-text">49. *字母异位词分组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N%E7%9A%87%E5%90%8E-hard"><span class="toc-text">51. *N皇后 (hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-medium"><span class="toc-text">53. *最大子数组和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-medium"><span class="toc-text">54. *螺旋矩阵(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-medium"><span class="toc-text">55. *跳跃游戏(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-medium"><span class="toc-text">56. *合并区间(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-medium"><span class="toc-text">62. *不同路径(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-medium"><span class="toc-text">64. *最小路径和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF-easy"><span class="toc-text">70. *爬楼梯 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-medium"><span class="toc-text">72. *编辑距离(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6-medium"><span class="toc-text">73. *矩阵置零(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-medium"><span class="toc-text">74. *搜索二维矩阵(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-medium"><span class="toc-text">75. *颜色分类(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-hard"><span class="toc-text">76. *最小覆盖子串(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86-medium"><span class="toc-text">78. *子集(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-medium"><span class="toc-text">79. *单词搜索(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-hard"><span class="toc-text">84. *柱状图中最大的矩形(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II-medium"><span class="toc-text">92. 反转链表 II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-easy"><span class="toc-text">94. *二叉树的中序遍历(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="toc-text">98. *验证二叉搜索树(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="toc-text">101. *对称二叉树(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">102. *二叉树的层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-easy"><span class="toc-text">104. *二叉树的最大深度(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-medium"><span class="toc-text">105. *从前序与中序遍历序列构造二叉树 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="toc-text">108. *将有序数组转换为二叉搜索树(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8-medium"><span class="toc-text">114. *二叉树展开为链表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-easy"><span class="toc-text">118. *杨辉三角(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-easy"><span class="toc-text">121. *买卖股票的最佳时机(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-hard"><span class="toc-text">124. *二叉树中的最大路径和(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97-medium"><span class="toc-text">128. *最长连续序列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-medium"><span class="toc-text">131. *分割回文串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-easy"><span class="toc-text">136. *只出现一次的数字(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-medium"><span class="toc-text">139. *单词拆分(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">138. *随机链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">141. *环形链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II-medium"><span class="toc-text">142. *环形链表II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-medium"><span class="toc-text">144. 二叉树的前序遍历(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU%E7%BC%93%E5%AD%98-medium"><span class="toc-text">146. *LRU缓存(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8-medium"><span class="toc-text">148. *排序链表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="toc-text">152. *乘积最大子数组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-medium"><span class="toc-text">153. *寻找旋转排序数组中的最小值(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88-medium"><span class="toc-text">155. 最小栈(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">160. *相交链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0-easy"><span class="toc-text">169. *多数元素(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84-medium"><span class="toc-text">189 *轮转数组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-medium"><span class="toc-text">198. *打家劫舍 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE-medium"><span class="toc-text">199. *二叉树的右视图(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-medium"><span class="toc-text">200. *岛屿数量 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">206. *反转链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8-medium"><span class="toc-text">207. *课程表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">208. *实现Trie(前缀树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-medium"><span class="toc-text">215. *数组中的第K个最大元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="toc-text">226. *翻转二叉树(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0-medium"><span class="toc-text">230. *二叉搜索树中第K小的元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">234. *回文链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-medium"><span class="toc-text">236. *二叉树的最近公共祖先(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-text">238. *除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-hard"><span class="toc-text">239. *滑动窗口最大值(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II-medium"><span class="toc-text">240. *搜索二维矩阵II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-medium"><span class="toc-text">279. *完全平方数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6-medium"><span class="toc-text">283. *移动零(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0-medium"><span class="toc-text">287. *寻找重复数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-hard"><span class="toc-text">295. *数据流的中位数(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="toc-text">300. *最长递增子序列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-medium"><span class="toc-text">322. *零钱兑换(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-medium"><span class="toc-text">347. *前k个高频元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81-medium"><span class="toc-text">394. *字符串解码(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text">416. *分割等和子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII-medium"><span class="toc-text">437. *路径总和III (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-medium"><span class="toc-text">438 *找到字符串中所有字母异位词(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-easy"><span class="toc-text">543. *二叉树的直径(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="toc-text">560. *和为k的子数组 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-medium"><span class="toc-text">739. *每日温度(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-medium"><span class="toc-text">763. *划分字母区间(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%F0%9F%8D%8A-medium"><span class="toc-text">994. *腐烂的🍊 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="toc-text">1143. *最长公共子序列(medium)</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>*是LeetCode Hot 100中的题</p>
</blockquote>
<p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-easy"><span class="toc-text">1. *两数之和(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-easy"><span class="toc-text">2. *两数相加 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-medium"><span class="toc-text">3. *无重复字符的最长子串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-hard"><span class="toc-text">4. 寻找两个正序数组的中位数(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-medium"><span class="toc-text">5. 最长回文子串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8-medium"><span class="toc-text">11. *盛水最多的容器(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">15. *三数之和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">16. 最接近的三数之和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-medium"><span class="toc-text">17. *电话号码的字母组合(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">18. 四数之和 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-medium"><span class="toc-text">19. *删除链表的倒数第n个节点(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-easy"><span class="toc-text">20. *有效的括号(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">21. *合并两个有序的链表 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90-medium"><span class="toc-text">22. *括号生成(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-hard"><span class="toc-text">23. *合并K个升序链表(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-medium"><span class="toc-text">24. *两两交换链表中的节点(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-hard"><span class="toc-text">25. *K个一组翻转链表(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-medium"><span class="toc-text">31. *下一个排列 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-medium"><span class="toc-text">34. *在排序数组中查找元素的第一个和最后一个位置(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-easy"><span class="toc-text">35. *搜索插入位置(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97-medium"><span class="toc-text">38. 外观数列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-medium"><span class="toc-text">39. *组合总和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0-medium"><span class="toc-text">41. *缺失的第一个正数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-hard"><span class="toc-text">42. *接雨水(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII-medium"><span class="toc-text">45. *跳跃游戏II(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97-medium"><span class="toc-text">46. *全排列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-medium"><span class="toc-text">48. *旋转图像(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-medium"><span class="toc-text">49. *字母异位词分组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N%E7%9A%87%E5%90%8E-hard"><span class="toc-text">51. *N皇后 (hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-medium"><span class="toc-text">53. *最大子数组和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-medium"><span class="toc-text">54. *螺旋矩阵(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-medium"><span class="toc-text">55. *跳跃游戏(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-medium"><span class="toc-text">56. *合并区间(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-medium"><span class="toc-text">62. *不同路径(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-medium"><span class="toc-text">64. *最小路径和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF-easy"><span class="toc-text">70. *爬楼梯 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-medium"><span class="toc-text">72. *编辑距离(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6-medium"><span class="toc-text">73. *矩阵置零(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-medium"><span class="toc-text">74. *搜索二维矩阵(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-medium"><span class="toc-text">75. *颜色分类(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-hard"><span class="toc-text">76. *最小覆盖子串(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86-medium"><span class="toc-text">78. *子集(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-medium"><span class="toc-text">79. *单词搜索(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-hard"><span class="toc-text">84. *柱状图中最大的矩形(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II-medium"><span class="toc-text">92. 反转链表 II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-easy"><span class="toc-text">94. *二叉树的中序遍历(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="toc-text">98. *验证二叉搜索树(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="toc-text">101. *对称二叉树(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">102. *二叉树的层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-easy"><span class="toc-text">104. *二叉树的最大深度(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-medium"><span class="toc-text">105. *从前序与中序遍历序列构造二叉树 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="toc-text">108. *将有序数组转换为二叉搜索树(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8-medium"><span class="toc-text">114. *二叉树展开为链表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-easy"><span class="toc-text">118. *杨辉三角(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-easy"><span class="toc-text">121. *买卖股票的最佳时机(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-hard"><span class="toc-text">124. *二叉树中的最大路径和(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97-medium"><span class="toc-text">128. *最长连续序列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-medium"><span class="toc-text">131. *分割回文串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-easy"><span class="toc-text">136. *只出现一次的数字(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-medium"><span class="toc-text">139. *单词拆分(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">138. *随机链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">141. *环形链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II-medium"><span class="toc-text">142. *环形链表II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-medium"><span class="toc-text">144. 二叉树的前序遍历(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU%E7%BC%93%E5%AD%98-medium"><span class="toc-text">146. *LRU缓存(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8-medium"><span class="toc-text">148. *排序链表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="toc-text">152. *乘积最大子数组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-medium"><span class="toc-text">153. *寻找旋转排序数组中的最小值(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88-medium"><span class="toc-text">155. 最小栈(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">160. *相交链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0-easy"><span class="toc-text">169. *多数元素(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84-medium"><span class="toc-text">189 *轮转数组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-medium"><span class="toc-text">198. *打家劫舍 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE-medium"><span class="toc-text">199. *二叉树的右视图(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-medium"><span class="toc-text">200. *岛屿数量 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">206. *反转链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8-medium"><span class="toc-text">207. *课程表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">208. *实现Trie(前缀树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-medium"><span class="toc-text">215. *数组中的第K个最大元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="toc-text">226. *翻转二叉树(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0-medium"><span class="toc-text">230. *二叉搜索树中第K小的元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">234. *回文链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-medium"><span class="toc-text">236. *二叉树的最近公共祖先(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-text">238. *除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-hard"><span class="toc-text">239. *滑动窗口最大值(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II-medium"><span class="toc-text">240. *搜索二维矩阵II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-medium"><span class="toc-text">279. *完全平方数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6-medium"><span class="toc-text">283. *移动零(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0-medium"><span class="toc-text">287. *寻找重复数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-hard"><span class="toc-text">295. *数据流的中位数(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="toc-text">300. *最长递增子序列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-medium"><span class="toc-text">322. *零钱兑换(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-medium"><span class="toc-text">347. *前k个高频元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81-medium"><span class="toc-text">394. *字符串解码(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text">416. *分割等和子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII-medium"><span class="toc-text">437. *路径总和III (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-medium"><span class="toc-text">438 *找到字符串中所有字母异位词(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-easy"><span class="toc-text">543. *二叉树的直径(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="toc-text">560. *和为k的子数组 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-medium"><span class="toc-text">739. *每日温度(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-medium"><span class="toc-text">763. *划分字母区间(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%F0%9F%8D%8A-medium"><span class="toc-text">994. *腐烂的🍊 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="toc-text">1143. *最长公共子序列(medium)</span></a></li></ol></div></p>
<h2 id="1-两数之和-easy">1. *两数之和(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></p>
</blockquote>
<ul>
<li>
<p>最无脑的做法: 遍历两个数的所有可能性, 判断和是否是<code>target</code>.</p>
</li>
<li>
<p>如果要优化成$O(n)$的做法, 就需要扫描一边, 扫描的过程中用之前积累的先验知识做.</p>
<ul>
<li>扫描的时候, 把之前遍历的数据存储到哈希表中, 每次扫描到一个数, 就判断<code>target - nums[i]</code>是否在哈希表中.</li>
<li>时间复杂度: $O(n)$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>       vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>       unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(target - nums[i])) <span class="hljs-keyword">return</span> &#123;hash[target - nums[i]], i&#125;;<br>            hash[nums[i]] = i;<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-两数相加-easy">2. *两数相加 (easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></p>
</blockquote>
<ul>
<li>数位从后向前枚举, 两个数位相加后, <code>t % 10</code>就是数位的值, 进位的值就是<code>t / 10</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), cur = dummy;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 || l2 || t) &#123;<br>            <span class="hljs-keyword">if</span> (l1) t += l1-&gt;val, l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span> (l2) t += l2-&gt;val, l2 = l2-&gt;next;<br>            cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t % <span class="hljs-number">10</span>);<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="3-无重复字符的最长子串-medium">3. *无重复字符的最长子串(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>
</blockquote>
<ul>
<li>双指针算法的一个pattern在于, 当我遍历时, 移动一个指针<code>i</code>时, 我可以借助题目中的某些性质, 让另一个指针<code>j</code>不必走某些位置.</li>
<li>在这个题中, 从前到后遍历字符串, 并且统计每一个字符出现的次数<code>hash[s[i]]</code>:
<ul>
<li>如果<code>hash[s[i]] &gt; 1</code>, 证明<code>[j, i]</code>范围内的子串出现了重复, 这个时候<code>j</code>需要向前移动, 直到<code>hash[s[i]] == 1</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            hash[s[i]] ++;<br>            <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; hash[s[i]] &gt; <span class="hljs-number">1</span>) hash[s[j ++]] --;<br>            ans = <span class="hljs-built_in">max</span>(ans, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="4-寻找两个正序数组的中位数-hard">4. 寻找两个正序数组的中位数(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">https://leetcode.cn/problems/median-of-two-sorted-arrays/</a></p>
</blockquote>
<p>考虑这样一个问题:</p>
<blockquote>
<p>在两个排序的数组之间, 寻找第k小数.</p>
</blockquote>
<p>如果这个问题能够解决, 那么中位数就是第<code>(n + m) / 2</code>小的数.</p>
<p>假设两个正序数组分别是$A$和$B$, 考虑$A[\frac{k}{2}]$和$B[\frac{k}{2}]$两个数:</p>
<ul>
<li>如果$A[\frac{k}{2}] &lt; B[\frac{k}{2}]$, 那么$A, B$数组中, 小于等于$A[\frac{k}{2}]$的数的个数就小于$k$, 此时两个数组中第$k$小的数肯定不会在$A$数组第$\frac{k}{2}$个元素的左边.</li>
<li>如果$A[\frac{k}{2}] &gt; B[\frac{k}{2}]$, 那么$A, B$数组中, 小于等于$B[\frac{k}{2}]$的数的个数就小于$k$, 此时两个数组中第$k$小的数肯定不会在$B$数组第$\frac{k}{2}$个元素的左边.</li>
<li>如果$A[\frac{k}{2}] = B[\frac{k}{2}]$, 那么$A, B$数组中, 小于等于$A[\frac{k}{2}]$或$B[\frac{k}{2}]$的数的个数就等于$k$, 此时$A[\frac{k}{2}]$或者$B[\frac{k}{2}]$就是第$k$小的数.</li>
</ul>
<p>根据以上分析, 定义一个函数, 函数的签名为<code>find(A, B, i, j, k)</code>, 表示给定两个数组$A, B$, 下标从$i, j$开始, 找到两个数组中第$k$小的数, 那么就可以用这个函数递归解决.</p>
<p>时间复杂度是$O(logk)$, 由于$k$最多是$m + n$, 那么时间复杂度就是$O(log(m + n))$</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>(), m = nums2.<span class="hljs-built_in">size</span>(), k = (n + m) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> ((n + m) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> left = <span class="hljs-built_in">find</span>(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k);<br>            <span class="hljs-type">int</span> right = <span class="hljs-built_in">find</span>(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> (left + right) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums1, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums2, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>(), m = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// nums1默认作为较小的数组</span><br>        <span class="hljs-keyword">if</span> (n - i &gt; m - j) <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(nums2, nums1, j, i, k);<br>        <span class="hljs-comment">// 如果nums1为空</span><br>        <span class="hljs-keyword">if</span> (i == nums1.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 如果k == 1</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[i], nums2[j]);<br><br>        <span class="hljs-type">int</span> si = <span class="hljs-built_in">min</span>((<span class="hljs-type">int</span>)(nums1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>), i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> sj = j + (k - k / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums1[si] &lt;= nums2[sj]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(nums1, nums2, si + <span class="hljs-number">1</span>, j, k - (si - i + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(nums1, nums2, i, sj + <span class="hljs-number">1</span>, k - (sj - j + <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="5-最长回文子串-medium">5. 最长回文子串(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">https://leetcode.cn/problems/longest-palindromic-substring/</a></p>
</blockquote>
<ul>
<li>要枚举一个字符串中的所有回文串:
<ul>
<li>首先, 遍历字符串中所有的字符<code>s[i]</code>.</li>
<li>然后, 回文串可以分为两种, 奇数长度和偶数长度, 奇数长度从<code>i - 1</code>和<code>i + 1</code>进行扩展, 偶数长度从<code>i</code>和<code>i + 1</code>进行扩展.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-type">int</span> l = i - <span class="hljs-number">1</span>, r = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++;<br>            <span class="hljs-keyword">if</span> (r - l - <span class="hljs-number">1</span> &gt; res.<span class="hljs-built_in">size</span>()) res = s.<span class="hljs-built_in">substr</span>(l + <span class="hljs-number">1</span>, r - l - <span class="hljs-number">1</span>);<br><br>            l = i, r = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++;<br>            <span class="hljs-keyword">if</span> (r - l - <span class="hljs-number">1</span> &gt; res.<span class="hljs-built_in">size</span>()) res = s.<span class="hljs-built_in">substr</span>(l + <span class="hljs-number">1</span>, r - l - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="11-盛水最多的容器-medium">11. *盛水最多的容器(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">https://leetcode.cn/problems/container-with-most-water/</a></p>
</blockquote>
<ul>
<li>思路: 假设两根棍子<code>i, j</code>, 它们之间的盛水量就是<code>min(height[i], height[j]) * (j - i)</code>.</li>
<li>最无脑的做法: 枚举所有可能的<code>i, j</code>.</li>
<li>如果我要让盛水量最大, 我应该移动短板, 也就是当<code>height[i] &lt;= height[j]</code>时, 我应该让<code>i++</code>才有机会让水量变大.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; h)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; ) &#123;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">min</span>(h[i], h[j]) * (j - i));<br>            <span class="hljs-keyword">if</span> (h[i] &lt;= h[j]) i ++;<br>            <span class="hljs-keyword">else</span> j --;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="15-三数之和-medium">15. *三数之和(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></p>
</blockquote>
<ul>
<li>
<p>首先将数组排序.</p>
</li>
<li>
<p>之后, 从前到后, 枚举数组中的第一个数<code>nums[i]</code>.</p>
<ul>
<li>然后, 从<code>i + 1</code>和<code>nums.size() - 1</code>分别枚举第二个数和第三个数, 然后根据三个数的加和调整指针.</li>
</ul>
</li>
<li>
<p>注意: 数组中可能有重复元素, 需要在枚举每一个指针的过程中去掉重复.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>                <span class="hljs-type">int</span> sum = nums[i] + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) j ++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) k --;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);<br>                    <span class="hljs-keyword">do</span> &#123;j ++;&#125; <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]);<br>                    <span class="hljs-keyword">do</span> &#123;k --;&#125; <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="16-最接近的三数之和-medium">16. 最接近的三数之和(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/">https://leetcode.cn/problems/3sum-closest/</a></p>
</blockquote>
<ul>
<li>和三数之和完全一致, 只需要在求和<code>sum</code>的时候维护一个离<code>target</code>最近的<code>sum</code>值即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                LL sum = (LL)nums[i] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(sum - target) &lt; <span class="hljs-built_in">abs</span>(ans - target)) ans = sum;<br>                <span class="hljs-keyword">if</span> (sum &lt; target) l ++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) r --;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">do</span> &#123;l ++;&#125; <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="hljs-number">1</span>]);<br>                    <span class="hljs-keyword">do</span> &#123;r --;&#125; <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="17-电话号码的字母组合-medium">17. *电话号码的字母组合(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a></p>
</blockquote>
<ul>
<li>搜索顺序是: 对于每一个坑位, 枚举这个坑位上能够放置的所有可能性, 放置之后, 就递归到下一个位置, 注意恢复现场.</li>
<li>注意: 如果输入是空字符串的话, 需要在搜索的时候特判一下, 不要把空的<code>path</code>放到<code>ans</code>中.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string path;<br>    vector&lt;string&gt; ans;<br>    string books[<span class="hljs-number">10</span>] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>,<br>        <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>,<br>        <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span><br>    &#125;;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;    <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;digits, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">size</span>() &amp;&amp; u == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: books[digits[u] - <span class="hljs-string">&#x27;0&#x27;</span>]) &#123;<br>            path += c;<br>            <span class="hljs-built_in">dfs</span>(digits, u + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="18-四数之和-medium">18. 四数之和 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/description/">https://leetcode.cn/problems/4sum/description/</a></p>
</blockquote>
<ul>
<li>和三数之和完全一致的做法, 只不过多了一层循环.</li>
<li>注意: 1. 数组先要排序. 2. <code>sum</code>需要用<code>long long</code>来存储.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j ++) &#123;<br>                <span class="hljs-keyword">if</span> (j != i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> l = j + <span class="hljs-number">1</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                    LL sum = (LL)nums[i] + nums[j] + nums[l] + nums[r];<br>                    <span class="hljs-keyword">if</span> (sum &lt; target) l ++;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) r --;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[l], nums[r]&#125;);<br>                        <span class="hljs-keyword">do</span> &#123; l ++; &#125; <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="hljs-number">1</span>]);<br>                        <span class="hljs-keyword">do</span> &#123; r --; &#125; <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="hljs-number">1</span>]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="19-删除链表的倒数第n个节点-medium">19. *删除链表的倒数第n个节点(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p>
</blockquote>
<ul>
<li>
<p>由于链表头节点可能被删除, 因此需要虚拟头节点.</p>
</li>
<li>
<p>准备两个快慢指针, 初始放在dummy, 快指针从dummy开始走n步, 之后慢指针和快指针同时走, 快指针走到最后一个节点的时候, 慢指针就会停到倒数第n个节点的前一个节点, 直接删除即可.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>       <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), cur = dummy;<br>       dummy-&gt;next = head;<br>       <span class="hljs-keyword">auto</span> p = dummy;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) p = p-&gt;next;<br>       <span class="hljs-keyword">auto</span> q = dummy;<br>       <span class="hljs-comment">// 注意, 这里要跳到要删除节点的前一个节点</span><br>       <span class="hljs-keyword">while</span> (p-&gt;next) p = p-&gt;next, q = q-&gt;next;<br>       q-&gt;next = q-&gt;next-&gt;next;<br>       <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="20-有效的括号-easy">20. *有效的括号(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p>
</blockquote>
<ul>
<li>遇到左括号就压栈.</li>
<li>如果遇到右括号需要注意几点:
<ul>
<li>第一, 只有栈顶的左括号和有括号成功匹配, 才弹出.</li>
<li>第二, 如果遇到右括号, 但是栈顶没有元素, 直接不匹配, 例如<code>]</code>.</li>
<li>第三, 如果遇到右括号, 但是栈顶不匹配, 那么直接就不匹配, 例如<code>(]</code>.</li>
<li>第二和第三需要特殊判断.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>       stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span>) stk.<span class="hljs-built_in">push</span>(c);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span>) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;&#123;&#x27;</span>) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;[&#x27;</span>) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="21-合并两个有序的链表-easy">21. *合并两个有序的链表 (easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p>
</blockquote>
<ul>
<li>和归并排序合并区间的过程一样.</li>
<li>首先需要枚举两个链表指针都存在的情况, 也就是<code>l1 &amp;&amp; l2</code>.</li>
<li>之后再枚举某一个链表没走完的情况, 也就是<code>while (l1) while (l2)</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), cur = dummy;<br>        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(l1-&gt;val), l1 = l1-&gt;next;<br>            <span class="hljs-keyword">else</span> cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(l2-&gt;val), l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (l1) cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(l1-&gt;val), l1 = l1-&gt;next;<br>        <span class="hljs-keyword">while</span> (l2) cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(l2-&gt;val), l2 = l2-&gt;next;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="22-括号生成-medium">22. *括号生成(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/description/">https://leetcode.cn/problems/generate-parentheses/description/</a></p>
</blockquote>
<ul>
<li>
<p>一个括号序列是合法的充要条件是:</p>
<ul>
<li>序列中, 左右括号数量相等.</li>
<li>任意前缀, 左括号数量大于等于有括号数量.</li>
</ul>
</li>
<li>
<p>给定了n对括号, 那么就有2n个坑位可以放置<code>(</code>和<code>)</code>, 那么搜索的顺序就是这样:</p>
</li>
<li>
<p>只要之前左括号数量小于<code>n</code>, 那么当前位置就可以放左括号.</p>
<ul>
<li>只要左括号数量大于右括号数量, 那么当前位置就可以放右括号.</li>
<li>总而言之</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    string path;<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> _n)</span> </span>&#123;<br>        n = _n;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lc == n &amp;&amp; rc == n) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lc &lt; n) &#123;<br>            path += <span class="hljs-string">&#x27;(&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(lc + <span class="hljs-number">1</span>, rc);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rc &lt; n &amp;&amp; lc &gt; rc) &#123;<br>            path += <span class="hljs-string">&#x27;)&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(lc, rc + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="23-合并K个升序链表-hard">23. *合并K个升序链表(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a></p>
</blockquote>
<ul>
<li>链表的k路归并问题, 可以采用堆排序解决.
<ul>
<li>将每一个链表头节点插入堆.</li>
<li>然后从堆中找到最小元素.</li>
<li>之后再将最小元素的下一个头节点插入堆.</li>
</ul>
</li>
<li>注意: 一开始将链表头节点插入堆时, 链表头可能为空, 需要注意判断.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(ListNode *a, ListNode *b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">auto</span> cur = dummy;<br>        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; heap;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> l: lists)<br>            <span class="hljs-keyword">if</span> (l) heap.<span class="hljs-built_in">push</span>(l);<br>            <br>        <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();<br>            cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t-&gt;val);<br>            <span class="hljs-keyword">if</span> (t-&gt;next) heap.<span class="hljs-built_in">push</span>(t-&gt;next);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="24-两两交换链表中的节点-medium">24. *两两交换链表中的节点(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p>
</blockquote>
<ul>
<li>首先, 链表头节点可能没有, 所以需要虚拟头节点.</li>
<li>其次, 如果要两两交换链表中的节点, 需要在链表中, 把每两个节点看作一个整体, 假设这个整体的第一个节点是<code>r</code>, 最后一个节点是<code>q</code>.
<ul>
<li><code>r</code>的前一个节点是<code>p</code>.</li>
<li>那么首先需要调整整体的指针, <code>p-&gt;next = q, r-&gt;next = q-&gt;next</code>.</li>
<li>然后再调整整体内部的指针: <code>q-&gt;next = r</code>.</li>
<li>然后更新<code>p</code>, 指向下一个整体的前一个节点: <code>p = r</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>       <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>       dummy-&gt;next = head;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next; ) &#123;<br>            <span class="hljs-keyword">auto</span> q = p;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> &amp;&amp; q; i ++) q = q-&gt;next;<br>            <span class="hljs-keyword">auto</span> u = p-&gt;next;<br>            <span class="hljs-keyword">auto</span> a = p-&gt;next, b = p-&gt;next-&gt;next;<br>            p-&gt;next = q;<br>            a-&gt;next = q-&gt;next;<br>            <span class="hljs-keyword">while</span> (a != q) &#123;<br>                <span class="hljs-keyword">auto</span> c = b-&gt;next;<br>                b-&gt;next = a;<br>                a = b, b = c;<br>            &#125;<br>            p = u;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="25-K个一组翻转链表-hard">25. *K个一组翻转链表(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">https://leetcode.cn/problems/reverse-nodes-in-k-group/</a></p>
</blockquote>
<ul>
<li>首先, 头节点会被改变, 因此要加上虚拟头节点.</li>
<li>其次, 先找到这k个节点组成的一个集团, 以及这个集团的前一个节点<code>p</code>, 和最后的节点<code>q</code>.</li>
<li>之后, 先动边界节点, 然后修改集团内部的节点.</li>
<li>最后, 注意指针<code>p</code>的移动.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;) &#123;<br>            <span class="hljs-keyword">auto</span> q = p;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; q; i ++) q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (!q) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">auto</span> u = p-&gt;next;<br>            <span class="hljs-keyword">auto</span> a = p-&gt;next, b = p-&gt;next-&gt;next;<br>            p-&gt;next = q;<br>            a-&gt;next = q-&gt;next;<br>            <span class="hljs-keyword">while</span> (a != q) &#123;<br>                <span class="hljs-keyword">auto</span> c = b-&gt;next;<br>                b-&gt;next = a;<br>                a = b, b = c;<br>            &#125;<br>            p = u;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="31-下一个排列-medium">31. *下一个排列 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">https://leetcode.cn/problems/next-permutation/</a></p>
</blockquote>
<ul>
<li>从后向前遍历, 找到第一个逆序点<code>k</code>, 也就是<code>nums[k - 1] &lt; nums[k]</code>.
<ul>
<li><code>[k, nums.size() - 1]</code>这一段是反向升序的.</li>
<li>那么在<code>[k, nums.size() - 1]</code>这一段, 找到最小的, 但是大于<code>nums[k - 1]</code>的数, 交换到<code>nums[k - 1]</code>的位置上.</li>
<li>然后将<code>[k, nums.size() - 1]</code>这一段逆序 (也就是变成升序).</li>
</ul>
</li>
<li>直觉上讲, 这种操作相当于让序列的第一个转折点变大, 那么字典序就是变大, 让后面的序列变成正序, 后面的字典序最小, 也就是下一个字典序的位置.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k - <span class="hljs-number">1</span>] &gt;= nums[k]) k --;<br>        <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> t = k;<br>            <span class="hljs-keyword">while</span> (t &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[t] &gt; nums[k - <span class="hljs-number">1</span>]) t ++;<br>            <span class="hljs-built_in">swap</span>(nums[k - <span class="hljs-number">1</span>], nums[t - <span class="hljs-number">1</span>]);<br>            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + k, nums.<span class="hljs-built_in">end</span>());<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="34-在排序数组中查找元素的第一个和最后一个位置-medium">34. *在排序数组中查找元素的第一个和最后一个位置(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
</blockquote>
<ul>
<li>
<p>整数二分的问题, 能够通过一个数组中的元素是否满足某个性质, 把数组分成两个部分.</p>
</li>
<li>
<p>这两个部分有两个边界:</p>
<ul>
<li>
<p>如果要求左边界: <code>int mid = l + (r - l) / 2 + 1</code></p>
<ul>
<li>满足左侧性质: <code>l = mid</code></li>
<li>满足右侧性质: <code>r = mid - 1</code></li>
</ul>
</li>
<li>
<p>如果要求右边界: <code>int mid = l + (r - l) / 2</code></p>
<ul>
<li>满足左侧性质: <code>l = mid + 1</code></li>
<li>满足右侧性质: <code>r = mid</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意实现时需要特判数组是空的情况.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[l] != target) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> left = l;<br>        l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[l] != target) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> right = l;<br>        <span class="hljs-keyword">return</span> &#123;left, right&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="35-搜索插入位置-easy">35. *搜索插入位置(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">https://leetcode.cn/problems/search-insert-position/</a></p>
</blockquote>
<ul>
<li>假设二分的性质是: <code>nums[i] &lt; x</code>, 和<code>nums[i] &gt;= x</code>, 那么插入的位置就是右边界.</li>
<li>注意: 如果插入的位置是数组的末尾, 那么答案应该是<code>n</code>, 但是二分不会得到这个答案, 需要特判.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">return</span> n;<br>        <br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125; <br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="38-外观数列-medium">38. 外观数列(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-and-say/description/">https://leetcode.cn/problems/count-and-say/description/</a></p>
</blockquote>
<ul>
<li>本质上, 这个题就是在统计字符串中, 每一个连续相同字符的序列的长度, 直接用双指针统计即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        string s = <span class="hljs-built_in">countAndSay</span>(n - <span class="hljs-number">1</span>);<br><br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[j] == s[i]) j ++;<br>            <span class="hljs-type">int</span> cnt = j - i;<br>            res += cnt + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            res += s[i];<br>            i = j - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="39-组合总和-medium">39. *组合总和(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p>
</blockquote>
<ul>
<li>搜索的顺序是: 对于<code>candidates</code>数组中的每一个数, 枚举这个数被选择的次数.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">dfs</span>(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == nums.<span class="hljs-built_in">size</span>() || sum == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>)<br>                ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; nums[u] * i &lt;= sum; i ++) &#123;<br>            <span class="hljs-built_in">dfs</span>(nums, sum - nums[u] * i, u + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">push_back</span>(nums[u]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; nums[u] * i &lt;= sum; i ++)<br>            path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="41-缺失的第一个正数-medium">41. *缺失的第一个正数(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/">https://leetcode.cn/problems/first-missing-positive/</a></p>
</blockquote>
<ul>
<li>
<p>如果让数组中所有的正整数元素满足<code>nums[i] == i</code>, 那么从前到后遍历正整数, 第一个不满足<code>nums[i] != i</code>的就是缺失的第一个整数.</p>
<ul>
<li>如果所有的正整数都满足, 那么缺失的第一个正整数就是<code>n + 1</code>.</li>
</ul>
</li>
<li>
<p>对于这段代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (nums[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; n &amp;&amp; nums[i] != nums[nums[i]])<br>	<span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]]);<br></code></pre></td></tr></table></figure>
<ul>
<li>每一次交换, 就相当于把<code>nums[i]</code>这个值, 放到了以<code>nums[i]</code>为下标的位置, 每一次都可以排好一个值.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span> (nums[i] != INT_MIN) nums[i] --;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">while</span> (nums[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; n &amp;&amp; nums[nums[i]] != nums[i])<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]]);<br>                <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span> (nums[i] != i)<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="42-接雨水-hard">42. *接雨水(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p>
</blockquote>
<ul>
<li>一个格子<code>h[i]</code>对整体雨水的贡献量是: <code>min(l[i], r[i]) - h[i]</code>.
<ul>
<li><code>l[i], r[i]</code>分别表示格子<code>i</code>左右两侧(包括<code>h[i]</code>), 的最大的格子高度.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; h)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = h.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(n)</span>, <span class="hljs-title">r</span><span class="hljs-params">(n)</span></span>;<br>        <br>        <span class="hljs-type">int</span> maxv = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            maxv = <span class="hljs-built_in">max</span>(maxv, h[i]);<br>            l[i] = maxv;<br>        &#125;<br>        maxv = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            maxv = <span class="hljs-built_in">max</span>(maxv, h[i]);<br>            r[i] = maxv;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            res += <span class="hljs-built_in">min</span>(l[i], r[i]) - h[i];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="45-跳跃游戏II-medium">45. *跳跃游戏II(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/</a></p>
</blockquote>
<ul>
<li>假设<code>f[i]</code>表示到达位置<code>i</code>所需要的最小跳跃次数.</li>
<li>那么<code>f[i] = f[j] + 1</code>, 其中<code>j</code>是最小的, 能够一步跳到<code>i</code>的位置.</li>
<li><code>i, j</code>的维护逻辑类似于双指针算法.</li>
<li>注意, 这里<code>i</code>要从1开始, 因为<code>f[0] = 0</code>是一种特殊情况, 不能参与到循环中, 一旦进入循环就会被更新.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; j + nums[j] &lt; i) j ++;<br>            f[i] = f[j] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="46-全排列-medium">46. *全排列(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a></p>
</blockquote>
<ul>
<li>本题是无重复元素的数组求全排列.</li>
<li>搜索顺序是: 对于每一个全排列上的坑位, 枚举这个坑位填哪一个数, 如果一个数被填了就需要记录, 防止重复填.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">bool</span>&gt; st;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        st.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>()); path.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (st[i]) <span class="hljs-keyword">continue</span>;<br>            path[u] = nums[i]; st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(nums, u + <span class="hljs-number">1</span>);<br>            st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="48-旋转图像-medium">48. *旋转图像(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">https://leetcode.cn/problems/rotate-image/</a></p>
</blockquote>
<ul>
<li>顺时针90度: 主对角线对称(左上-右下), 竖直轴线对称.</li>
<li>逆时针90度: 主对角线对称(左上-右下), 水平轴线对称.</li>
<li>顺时针/逆时针180度: 主对角线对称 + 副对角线对称.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>       <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, k = m - <span class="hljs-number">1</span>; j &lt; k; j ++, k --)<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[i][k]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="49-字母异位词分组-medium">49. *字母异位词分组(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">https://leetcode.cn/problems/group-anagrams/</a></p>
</blockquote>
<ul>
<li>这个题的题意是: 给定一个字符串的数组, 如果将这个数组中的元素分为若干个group, 每一个group中的所有字符串经过排序后都能得到同样的结果.</li>
<li>那么直接用哈希表, key作为排序后的结果, value就是所有符合题意的字符串即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;str: strs) &#123;<br>            <span class="hljs-keyword">auto</span> nstr = str;<br>            <span class="hljs-built_in">sort</span>(nstr.<span class="hljs-built_in">begin</span>(), nstr.<span class="hljs-built_in">end</span>());<br>            hash[nstr].<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, s]: hash) ans.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="51-N皇后-hard">51. *N皇后 (hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">https://leetcode.cn/problems/n-queens/</a></p>
</blockquote>
<ul>
<li>用<code>col</code>, <code>dg</code>, <code>udg</code>分别记录每一列, 对角线/反对角线上是否有<code>Q</code>.</li>
<li>遍历时先遍历每一行<code>u</code>, 然后遍历每一列<code>i</code>, 如果一个位置<code>(u, i)</code>在列, 对角线, 反对角线上都没有棋子, 那么就可以放下棋子, 然后递归到下一个位置.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; col, dg, udg;<br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> _n) &#123;<br>        n = _n;<br>        col = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        dg = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        udg = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        path = <span class="hljs-built_in">vector</span>&lt;string&gt;(n, <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27;.&#x27;</span>));<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == n) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (col[i] || dg[u + i] || udg[n + i - u]) <span class="hljs-keyword">continue</span>;<br>            col[i] = dg[u + i] = udg[n + i - u] = <span class="hljs-literal">true</span>;<br>            path[u][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            path[u][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            col[i] = dg[u + i] = udg[n + i - u] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="53-最大子数组和-medium">53. *最大子数组和(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p>
</blockquote>
<ul>
<li>假设<code>f[i]</code>表示以<code>i</code>结尾的所有子数组中, 和的最大值.</li>
<li>那么状态转移就是: <code>f[i] = max(nums[i], f[i - 1] + nums[i])</code>.</li>
<li>最后的答案就是求所有<code>f[i]</code>的最大值.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> f = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            f = <span class="hljs-built_in">max</span>(f + nums[i], nums[i]);<br>            ans = <span class="hljs-built_in">max</span>(ans, f);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="54-螺旋矩阵-medium">54. *螺旋矩阵(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">https://leetcode.cn/problems/spiral-matrix/</a></p>
</blockquote>
<ul>
<li>遍历时, 一旦遇到下标越界/边界已经搜索过的情况, 就把<code>dx, dy</code>数组的方向改变一下即可.</li>
<li>注意: x的正方向是下, y的正方向是右.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">st</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n * m; k ++) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(matrix[x][y]);<br>            st[x][y] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> a = x + dx[d], b = y + dy[d];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m || st[a][b])<br>                d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            x += dx[d], y += dy[d];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="55-跳跃游戏-medium">55. *跳跃游戏(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/</a></p>
</blockquote>
<ul>
<li>对于数组中的每一个数<code>nums[i]</code>, 它能够跳到的最大的位置就是<code>i + nums[i]</code>.</li>
<li>那么, 当遍历到<code>i</code>时, 如果之前能够跳到的最大位置<code>j &lt; i</code>, 那么就无法到达这个位置, 因此, 就无法到达终点.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> f = <span class="hljs-number">0</span> + nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (f &lt; i) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            f = <span class="hljs-built_in">max</span>(f, i + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="56-合并区间-medium">56. *合并区间(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">https://leetcode.cn/problems/merge-intervals/</a></p>
</blockquote>
<ul>
<li>
<p>首先, 区间按照左端点排序.</p>
</li>
<li>
<p>然后, 用<code>[st, ed]</code>维护当前右端点最大的区间, 然后依次枚举当前区间<code>[l, r]</code>:</p>
<ul>
<li>如果<code>l &lt;= ed</code>, 有交集, 那么直接更新<code>ed = max(ed, r)</code>.</li>
<li>如果<code>l &gt; ed</code>, 没交集, 那么需要先把<code>[st, ed]</code>放在答案中, 然后更新区间<code>st = l, ed = r</code>.</li>
</ul>
</li>
<li>
<p>注意: 枚举完之后, 最后一个区间<code>[st, ed]</code>也要放到答案中.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> st = <span class="hljs-number">-1</span>, ed = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;range: intervals) &#123;<br>            <span class="hljs-type">int</span> l = range[<span class="hljs-number">0</span>], r = range[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (l &lt;= ed)<br>                ed = <span class="hljs-built_in">max</span>(ed, r);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (ed != <span class="hljs-number">-1</span>) ans.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>                st = l, ed = r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ed != <span class="hljs-number">-1</span>) ans.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="62-不同路径-medium">62. *不同路径(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p>
</blockquote>
<ul>
<li>设<code>f[i][j]</code>表示从起点走到<code>(i, j)</code>的路径数量.</li>
<li>首先初始化起点, 路径数量是1: <code>f[0][0] = 1</code>.</li>
<li>之后更新状态: <code>f[i][j] += f[i - 1][j]</code>, 以及<code>f[i][j] += f[i][j - 1]</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (!i &amp;&amp; !j) f[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (i) f[i][j] += f[i - <span class="hljs-number">1</span>][j];<br>                    <span class="hljs-keyword">if</span> (j) f[i][j] += f[i][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="64-最小路径和-medium">64. *最小路径和(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">https://leetcode.cn/problems/minimum-path-sum/</a></p>
</blockquote>
<ul>
<li>设<code>f[i][j]</code>表示从起点走到<code>(i, j)</code>的最小路径和.</li>
<li>首先初始化所有位置的<code>f[i][j]</code>为<code>INF</code>, 然后将起点<code>f[0][0] = grid[0][0];</code></li>
<li>之后更新状态: <code>f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j];</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0x3f3f3f3f</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (!i &amp;&amp; !j) f[i][j] = grid[i][j];<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (i) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j] + grid[i][j]);<br>                    <span class="hljs-keyword">if</span> (j) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][j - <span class="hljs-number">1</span>] + grid[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="70-爬楼梯-easy">70. *爬楼梯 (easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p>
</blockquote>
<ul>
<li>斐波那契数列的第0项是1, 第1项也是1.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>        LL a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (n --) &#123;<br>            LL c = a + b;<br>            a = b, b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="72-编辑距离-medium">72. *编辑距离(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/">https://leetcode.cn/problems/edit-distance/description/</a></p>
</blockquote>
<ul>
<li>假设<code>f[i][j]</code>表示从<code>word1[1:i]</code>转换为<code>word2[1:j]</code>的最小编辑次数, 针对<code>word1[i]</code>的操作, 状态转移分为三种情况:
<ul>
<li>增加<code>word1[i]</code>: 那么就要求<code>word[1:i]</code>和<code>word2[1:j-1]</code>匹配.</li>
<li>删除<code>word1[i]</code>: 要求<code>word[1:i-1]</code>和<code>word2[1:j]</code>匹配</li>
<li>替换<code>word1[i]</code>: 要求<code>word[1:i-1]</code>和<code>word2[1:j-1]</code>匹配, 并且<code>word1[i] == word2[j]</code>.
<ul>
<li>如果<code>word1[i] == word2[j]</code>, 那么就可以直接从<code>f[i - 1][j - 1]</code>转移.</li>
</ul>
</li>
</ul>
</li>
<li>注意初始化<code>f[i][0]</code>和<code>f[0][i]</code>为<code>i</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word1.<span class="hljs-built_in">size</span>(), m = word2.<span class="hljs-built_in">size</span>();<br>        word1 = <span class="hljs-string">&#x27; &#x27;</span> + word1;<br>        word2 = <span class="hljs-string">&#x27; &#x27;</span> + word2;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) f[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i ++) f[<span class="hljs-number">0</span>][i] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>                f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, f[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (word1[i] == word2[j])<br>                    f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">else</span><br>                    f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="73-矩阵置零-medium">73. *矩阵置零(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/set-matrix-zeroes/">https://leetcode.cn/problems/set-matrix-zeroes/</a></p>
</blockquote>
<ul>
<li>原地算法:
<ul>
<li>首先记录一下第0行和第0列是否需要清0.</li>
<li>然后从第1行/第1列开始对矩阵进行判断, 如果第i行包含0元素, 就在<code>matrix[i][0]</code>处标记为0.
<ul>
<li>原来的<code>matrix[i][0]</code>可能是0, 也可能不是0, 这个时候如果标记为0, 那么原来的值就不知道, 那么后面就无法判断第0行和第0列是否需要清0, 所以需要预先处理一下第0行和第0列.</li>
</ul>
</li>
<li>然后根据标记的<code>matrix[i][0]</code>和<code>matrix[0][i]</code>进行清理.</li>
<li>之后清理第0行和第0列.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> row = <span class="hljs-literal">false</span>, col = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span> (!matrix[i][<span class="hljs-number">0</span>])<br>                col = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>            <span class="hljs-keyword">if</span> (!matrix[<span class="hljs-number">0</span>][i])<br>                row = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (!matrix[i][j]) &#123;<br>                    matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                    matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>        <span class="hljs-comment">// 注意这里要从1开始遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span> (!matrix[i][<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j ++)<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i ++)<br>            <span class="hljs-keyword">if</span> (!matrix[<span class="hljs-number">0</span>][i]) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j ++)<br>                    matrix[j][i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        <span class="hljs-keyword">if</span> (row) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>                matrix[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (col) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="74-搜索二维矩阵-medium">74. *搜索二维矩阵(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix/">https://leetcode.cn/problems/search-a-2d-matrix/</a></p>
</blockquote>
<ul>
<li>二维矩阵和一维数组没有什么区别, 一位数组的下标<code>idx</code>分别除以/模矩阵列数就是在矩阵中的坐标<code>(idx / m, idx % m)</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n * m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (matrix[mid / m][mid % m] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix[l / m][l % m] == target;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="75-颜色分类-medium">75. *颜色分类(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">https://leetcode.cn/problems/sort-colors/</a></p>
</blockquote>
<ul>
<li>
<p>核心思想是扫描数组的时候, 维护三个区域, 一个区域全是0, 一个区域全是1, 另一个区域全是2.</p>
</li>
<li>
<p>维护三个指针<code>i, j, k</code>, <code>j</code>扫描数组:</p>
<ul>
<li>如果<code>nums[j] == 0</code>, 那么<code>0</code>就放置到<code>i</code>处, 然后让<code>i</code>指针移动.</li>
<li>如果<code>nums[j] == 1</code>, 那么直接<code>j ++</code>.</li>
<li>如果<code>nums[j] == 2</code>, 那么直接交换到<code>k</code>指针处, 然后<code>k --</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt;= k) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] == <span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(nums[i ++], nums[j ++]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[j] == <span class="hljs-number">1</span>) j ++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[j] == <span class="hljs-number">2</span>) <span class="hljs-built_in">swap</span>(nums[j], nums[k --]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="76-最小覆盖子串-hard">76. *最小覆盖子串(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">https://leetcode.cn/problems/minimum-window-substring/</a></p>
</blockquote>
<ul>
<li>思路: 当指针<code>i</code>向前移动时, 向后移动指针<code>j</code>, 直到子串完全覆盖<code>t</code>中的所有字符.</li>
<li>然后向左移动指针, 找到长度最小的, 也可以完全覆盖<code>t</code>中字符的最小子串.
<ul>
<li><code>hash[s[i]]</code>表示<code>t</code>中字符在<code>s</code>中出现的次数, 如果<code>hash[s[j]] + 1 &gt; 0</code>, 那么表示如果<code>j</code>再向前移动, 就无法覆盖<code>t</code>中所有字符了.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: t) hash[c] ++;<br>        <span class="hljs-type">int</span> tot = hash.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, len = n;<br>        string ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(s[i]) &amp;&amp; --hash[s[i]] == <span class="hljs-number">0</span>) k ++;<br>            <span class="hljs-keyword">if</span> (k == tot) &#123;<br>                <span class="hljs-keyword">while</span> (j &lt; i) &#123;<br>                    <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(s[j]) &amp;&amp; hash[s[j]] + <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(s[j])) hash[s[j]] ++;<br>                    j ++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i - j + <span class="hljs-number">1</span> &lt;= len) &#123;<br>                    len = i - j + <span class="hljs-number">1</span>;<br>                    ans = s.<span class="hljs-built_in">substr</span>(j, i - j + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="78-子集-medium">78. *子集(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">https://leetcode.cn/problems/subsets/</a></p>
</blockquote>
<ul>
<li>递归写法:
<ul>
<li>枚举数组中的每个数选/不选即可.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(nums, u + <span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">push_back</span>(nums[u]);<br>        <span class="hljs-built_in">dfs</span>(nums, u + <span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>迭代写法: 用二进制枚举子集</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; path;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>                <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>)<br>                    path.<span class="hljs-built_in">push_back</span>(nums[j]);<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="79-单词搜索-medium">79. *单词搜索(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">https://leetcode.cn/problems/word-search/</a></p>
</blockquote>
<ul>
<li>遍历网格中的每一个格子, 从每一个格子开始进行搜索.
<ul>
<li>对于每一个格子, 如果它与当前单词字符相等, 就把格子设置为<code>.</code> (标记为已搜索过). 然后扩展到其他合法格子.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>       <span class="hljs-type">int</span> n = board.<span class="hljs-built_in">size</span>(), m = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, <span class="hljs-number">0</span>, i, j))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board, string word, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (board[x][y] != word[u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (u == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">char</span> t = board[x][y];<br>        board[x][y] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        <span class="hljs-type">int</span> n = board.<span class="hljs-built_in">size</span>(), m = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m || board[a][b] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, u + <span class="hljs-number">1</span>, a, b)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        board[x][y] = t;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="84-柱状图中最大的矩形-hard">84. *柱状图中最大的矩形(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">https://leetcode.cn/problems/largest-rectangle-in-histogram/</a></p>
</blockquote>
<ul>
<li>对于每个柱子<code>h[i]</code>, 找到它左边, 右边第一个比它小的位置下标<code>l, r</code>.</li>
<li>那么这个矩形的面积就是<code>(r - l + 1) * h[i]</code>, 枚举这个值就可以.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; h)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; left, right;<br><br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>() &amp;&amp; h[i] &lt;= h[stk.<span class="hljs-built_in">top</span>()]) stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) left.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">else</span> left.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>() + <span class="hljs-number">1</span>);<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        stk = <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>() &amp;&amp; h[i] &lt;= h[stk.<span class="hljs-built_in">top</span>()]) stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) right.<span class="hljs-built_in">push_back</span>(h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> right.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>);<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(right.<span class="hljs-built_in">begin</span>(), right.<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h.<span class="hljs-built_in">size</span>(); i ++)<br>            ans = <span class="hljs-built_in">max</span>(ans, h[i] * (right[i] - left[i] + <span class="hljs-number">1</span>));<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="92-反转链表-II-medium">92. 反转链表 II (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/</a></p>
</blockquote>
<ul>
<li>首先, 找到第<code>left-1</code>个节点, 和<code>right</code>节点, 操作<code>[left, right]</code>这一组节点边界的指针.</li>
<li>之后, 按照反转链表迭代的写法, 反转<code>[left, right]</code>内部的节点.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>); dummy-&gt;next = head;<br>        <span class="hljs-keyword">auto</span> p = dummy, q = dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i ++) p = p-&gt;next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right; i ++) q = q-&gt;next;<br>        <br>        <span class="hljs-keyword">auto</span> u = p-&gt;next, v = p-&gt;next-&gt;next;<br>        p-&gt;next-&gt;next = q-&gt;next;<br>        p-&gt;next = q;<br>        <span class="hljs-keyword">while</span> (u != q) &#123;<br><br>            <span class="hljs-keyword">auto</span> r = v-&gt;next;<br>            v-&gt;next = u;<br>            u = v, v = r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="94-二叉树的中序遍历-easy">94. *二叉树的中序遍历(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p>
</blockquote>
<ul>
<li>
<p>递归写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>迭代写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>      <span class="hljs-comment">// 这里root和stk.size()是两个判断条件.</span><br>      <span class="hljs-comment">// root用来判断上一个处理节点是否有右节点, 如果有就递归到右节点</span><br>      <span class="hljs-comment">// stk.size()用来判断上一个节点如果没有右节点, 就从栈中弹出上一个节点处理</span><br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="98-验证二叉搜索树-medium">98. *验证二叉搜索树(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p>
</blockquote>
<ul>
<li>dfs函数返回一个节点所在子树的元素最小值和最大值.</li>
<li>递归向上比较左子树最大值, 右子树最小值和当前节点值的关系即可验证.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> ans = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minv = root-&gt;val, maxv = root-&gt;val;<br>        <span class="hljs-keyword">if</span> (root-&gt;left) &#123;<br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>            <span class="hljs-keyword">if</span> (t[<span class="hljs-number">1</span>] &gt;= root-&gt;val) ans = <span class="hljs-literal">false</span>;<br>            minv = <span class="hljs-built_in">min</span>(minv, t[<span class="hljs-number">0</span>]);<br>            maxv = <span class="hljs-built_in">max</span>(maxv, t[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;right) &#123;<br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>            <span class="hljs-keyword">if</span> (t[<span class="hljs-number">0</span>] &lt;= root-&gt;val) ans = <span class="hljs-literal">false</span>;<br>            minv = <span class="hljs-built_in">min</span>(minv, t[<span class="hljs-number">0</span>]);<br>            maxv = <span class="hljs-built_in">max</span>(maxv, t[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;minv, maxv&#125;;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="101-对称二叉树-easy">101. *对称二叉树(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p>
</blockquote>
<ul>
<li>
<p>递归判断一个节点的左节点和右节点是否相等即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, root-&gt;right); <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> !p &amp;&amp; !q;<br>        <span class="hljs-keyword">if</span> (p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="hljs-built_in">dfs</span>(p-&gt;right, q-&gt;left);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="102-二叉树的层序遍历">102. *二叉树的层序遍历</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p>
</blockquote>
<ul>
<li>注意: 层序遍历的话, 一定要首先特判根节点是否为<code>NULL</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>          <span class="hljs-comment">// 这里的q.size()就是一层的长度</span><br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-keyword">while</span> (len --) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度-easy">104. *二叉树的最大深度(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="105-从前序与中序遍历序列构造二叉树-medium">105. *从前序与中序遍历序列构造二叉树 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) hash[inorder[i]] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;preorder, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inorder, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (pl &gt; pr) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>       <span class="hljs-type">int</span> r = preorder[pl];<br>       <span class="hljs-type">int</span> k = hash[r];<br>       <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(r);<br>      <span class="hljs-comment">// 注意这里是(k - 1) - il + 1</span><br>       root-&gt;left = <span class="hljs-built_in">dfs</span>(preorder, inorder, pl + <span class="hljs-number">1</span>, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il + <span class="hljs-number">1</span> - <span class="hljs-number">1</span>, il, k - <span class="hljs-number">1</span>);<br>       root-&gt;right = <span class="hljs-built_in">dfs</span>(preorder, inorder, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il + <span class="hljs-number">1</span>, pr, k + <span class="hljs-number">1</span>, ir);<br>       <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="108-将有序数组转换为二叉搜索树-medium">108. *将有序数组转换为二叉搜索树(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p>
</blockquote>
<ul>
<li>从中点开始创造节点, 然后左子树和右子树从中点前后范围递归构建.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(nums, l, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(nums, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="114-二叉树展开为链表-medium">114. *二叉树展开为链表(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/</a></p>
</blockquote>
<ul>
<li>从直观上来看, 需要把一个节点的左子树, 归并到这个节点和右节点之间.</li>
<li>左子树有两个关键的节点:
<ul>
<li>左子树根节点, 当前节点的右指针要指向左子树根节点.</li>
<li>当前节点中序遍历的前驱, 前驱的右节点需要指向右子树根节点.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur = root;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                <span class="hljs-keyword">auto</span> prev = cur-&gt;left;<br>                <span class="hljs-keyword">while</span> (prev-&gt;right) prev = prev-&gt;right;<br>                prev-&gt;right = cur-&gt;right;<br>                cur-&gt;right = cur-&gt;left;<br>                cur-&gt;left = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="118-杨辉三角-easy">118. *杨辉三角(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pascals-triangle/">https://leetcode.cn/problems/pascals-triangle/</a></p>
</blockquote>
<ul>
<li>注意: 杨辉三角每一行的第一个数和最后一个数都是1.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; f;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i ++) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">level</span><span class="hljs-params">(i + <span class="hljs-number">1</span>)</span></span>;<br>            level[<span class="hljs-number">0</span>] = level[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)<br>                level[j] = f[i - <span class="hljs-number">1</span>][j] + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            f.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="121-买卖股票的最佳时机-easy">121. *买卖股票的最佳时机(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p>
</blockquote>
<ul>
<li>
<p>直接倒序遍历的过程中, 统计股票价格最大值即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> v = <span class="hljs-number">-1</span>, n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">if</span> (v == <span class="hljs-number">-1</span>) v = prices[i];<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, v - prices[i]);<br>                v = <span class="hljs-built_in">max</span>(v, prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="124-二叉树中的最大路径和-hard">124. *二叉树中的最大路径和(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">https://leetcode.cn/problems/binary-tree-maximum-path-sum/</a></p>
</blockquote>
<ul>
<li><code>dfs</code>函数是从当前节点出发, 伸到子树中所有节点的单向路径的最大权值之和.</li>
<li>那么对于一条路径, 他有三种情况:
<ul>
<li>从左节点向下延伸.</li>
<li>从右节点向下延伸.</li>
<li>从左右节点同时向下延伸.</li>
</ul>
</li>
<li>只需要对这三种情况取一个max即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">dfs</span>(root-&gt;left), r = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> maxv = root-&gt;val;<br>        maxv = <span class="hljs-built_in">max</span>(maxv, root-&gt;val + l);<br>        maxv = <span class="hljs-built_in">max</span>(maxv, root-&gt;val + r);<br>        <span class="hljs-type">int</span> c = maxv;<br>        maxv = <span class="hljs-built_in">max</span>(maxv, l + r + root-&gt;val);<br>        ans = <span class="hljs-built_in">max</span>(ans, maxv);<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="128-最长连续序列-medium">128. *最长连续序列(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">https://leetcode.cn/problems/longest-consecutive-sequence/</a></p>
</blockquote>
<ul>
<li>首先, 将数组中所有数字插入哈希表.</li>
<li>然后, 枚举数组中的每一个数字<code>x</code>, 将这个数字作为起点 (起点的意思就是<code>!hash.count(x - 1)</code>), 然后枚举<code>x + 1, x + 2, ...</code>, 如果一直在哈希表中, 那么序列就可以延伸, 直到有一个元素不在哈希表.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) hash.<span class="hljs-built_in">insert</span>(x);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(x - <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> y = x + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (hash.<span class="hljs-built_in">count</span>(y)) y ++;<br>            ans = <span class="hljs-built_in">max</span>(ans, y - x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="131-分割回文串-medium">131. *分割回文串(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">https://leetcode.cn/problems/palindrome-partitioning/</a></p>
</blockquote>
<ul>
<li>首先, 如果一个字符串是<code>aaaaa..</code>, 那么枚举分割方案的时间复杂度是$O(2^n)$, 所以这个问题是一个爆搜问题.</li>
<li>其次, 枚举<strong>分割方案</strong>的方法是, 枚举一个起点<code>u</code>, 然后从<code>u</code>向后 (包括<code>u</code>), 枚举终点<code>i</code>, 枚举终点后, 递归到下一个起点<code>i + 1</code>.</li>
<li>可以用一个<code>f[i][j]</code>预处理<code>s[i, j]</code>是否是回文串, 递推式是:
<ul>
<li><code>f[i][j] = f[i + 1][j - 1] &amp;&amp; s[i] == s[j]</code>.</li>
<li>注意由于要满足拓扑序, <code>i</code>要从后向前, <code>j</code>要从前向后.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; f;<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        f = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --)<br>                <span class="hljs-keyword">if</span> (i == j) f[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt; j - <span class="hljs-number">1</span>) f[i][j] = (s[i] == s[j]);<br>                <span class="hljs-keyword">else</span> f[i][j] = f[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (s[i] == s[j]);<br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;    <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = u; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (!f[u][i]) <span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(u, i - u + <span class="hljs-number">1</span>));<br>            <span class="hljs-built_in">dfs</span>(s, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="136-只出现一次的数字-easy">136. *只出现一次的数字(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p>
</blockquote>
<ul>
<li>直接对数组中所有元素进行异或就可以.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums) ans = ans ^ x;<br>       <span class="hljs-keyword">return</span> ans; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="139-单词拆分-medium">139. *单词拆分(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">https://leetcode.cn/problems/word-break/</a></p>
</blockquote>
<ul>
<li>设<code>f[i]</code>表示以<code>s[i]</code>结尾, 是否存在划分方式.</li>
<li>那么假设<code>k &lt; i</code>, 并且<code>s[k:i]</code>是在字典中出现的, 那么<code>f[i] = f[k - 1]</code>.
<ul>
<li>如果要判断<code>s[k:i]</code>是否在字典中出现过, 可以用字符串哈希, 做到$O(1)$的时间复杂度.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">131</span>;<br>        <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>        unordered_set&lt;ULL&gt; hash;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;word: wordDict) &#123;<br>            ULL h = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : word) h = h * P + c;<br>            hash.<span class="hljs-built_in">insert</span>(h);<br>        &#125;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        s = <span class="hljs-string">&#x27; &#x27;</span> + s;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (!f[i]) <span class="hljs-keyword">continue</span>;<br>            ULL h = <span class="hljs-number">0</span>;<br>          <span class="hljs-comment">// 枚举f[i]能更新到哪个位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j ++) &#123;<br>                h = h * P + s[j];<br>                <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(h)) f[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="138-随机链表的复制">138. *随机链表的复制</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/">https://leetcode.cn/problems/copy-list-with-random-pointer/</a></p>
</blockquote>
<ul>
<li>首先, 对于旧链表中的每一个节点, 在后面插入一个新的节点, 那么我就可以通过旧链表的位置相对关系, 推导出新链表的位置相对关系.</li>
<li>之后, 如果要复制<code>random</code>边, 只需要让旧链表中的节点<code>p</code>, 让<code>p-&gt;next-&gt;random = p-&gt;random-&gt;next</code>.
<ul>
<li>其中<code>p-&gt;next</code>是新链表中的对应节点, <code>p-&gt;random-&gt;next</code>就是<code>p-&gt;random</code>在新链表中的相对位置.</li>
</ul>
</li>
<li>之后, 再把新链表节点从原链表拆出来就可以.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next) &#123;<br>            <span class="hljs-keyword">auto</span> q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(p-&gt;val);<br>            q-&gt;next = p-&gt;next;<br>            p-&gt;next = q;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;random) p-&gt;next-&gt;random = p-&gt;random-&gt;next;<br>            <span class="hljs-keyword">else</span> p-&gt;next-&gt;random = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>), cur = dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next) &#123;<br>            cur = cur-&gt;next = p-&gt;next;<br>            p-&gt;next = p-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="141-环形链表-easy">141. *环形链表(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">https://leetcode.cn/problems/linked-list-cycle/</a></p>
</blockquote>
<ul>
<li>用快慢指针, 快指针一次两个, 慢指针一次一个, 最终相遇, 就证明有环.</li>
<li>注意, 如果链表只有一个节点, 那么当两个指针相等的时候可能都是<code>NULL</code>, 这个要特判一下.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = head, q = head;<br>        <span class="hljs-keyword">while</span> (p &amp;&amp; q) &#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (q) q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (q &amp;&amp; p == q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="142-环形链表II-medium">142. *环形链表II (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p>
</blockquote>
<ul>
<li>继上一题, 如果要找环形链表的环入口:
<ul>
<li>当快慢指针第一次相遇时, 让慢指针退后到起始点.</li>
<li>然后快指针和慢指针同时向后移动一次, 最终相遇点就是环的入口.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = head, q = head;<br>        <span class="hljs-keyword">while</span> (p &amp;&amp; q) &#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (q) q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (q &amp;&amp; p == q) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!q) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        p = head;<br>        <span class="hljs-keyword">while</span> (p != q) p = p-&gt;next, q = q-&gt;next;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="144-二叉树的前序遍历-medium">144. 二叉树的前序遍历(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p>
</blockquote>
<ul>
<li>递归写法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>迭代写法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="146-LRU缓存-medium">146. *LRU缓存(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a></p>
</blockquote>
<ul>
<li>LRU缓存需要用一个双向链表和一个哈希表实现.
<ul>
<li>双向链表: 存储实际的<code>key</code>和<code>value</code>.</li>
<li>哈希表: 用于快速通过<code>key</code>获取双向链表节点的位置.</li>
</ul>
</li>
<li>构造函数逻辑:
<ul>
<li>主要初始化双向链表的哨兵节点.</li>
</ul>
</li>
<li><code>get</code>函数逻辑:
<ul>
<li>首先通过<code>key</code>, 在哈希表中找到节点 (如果节点不存在就直接返回<code>NULL</code>).</li>
<li>然后把这个节点从双向链表中删除, 放到头节点.</li>
</ul>
</li>
<li><code>put</code>函数逻辑:
<ul>
<li>如果哈希表原来存在, 那么就修改, 从双链表中删除, 放到头节点.</li>
<li>如果没有:
<ul>
<li>如果容量满了, 那么就要删除双向链表的尾部节点, 并且从哈希表中清除记录.</li>
<li>从哈希表中创建节点, 然后放到双链表最左侧.</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key, value;<br>        Node *left, *right;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">value</span>(_value), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>    &#125; *L, *R;<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; hash;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node *u)</span> </span>&#123;<br>        u-&gt;right-&gt;left = u-&gt;left;<br>        u-&gt;left-&gt;right = u-&gt;right;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Node *u)</span> </span>&#123;<br>        u-&gt;left = L;<br>        u-&gt;right = L-&gt;right;<br>        L-&gt;right-&gt;left = u;<br>        L-&gt;right = u;<br>    &#125;<br><br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        n = capacity;<br>        L = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);<br>        R = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);<br>        L-&gt;right = R, R-&gt;left = L;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!hash.<span class="hljs-built_in">count</span>(key)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">auto</span> t = hash[key];<br>        <span class="hljs-built_in">remove</span>(t); <span class="hljs-built_in">insert</span>(t);<br>        <span class="hljs-keyword">return</span> t-&gt;value;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> t = hash[key];<br>            t-&gt;value = value;<br>            <span class="hljs-built_in">remove</span>(t); <span class="hljs-built_in">insert</span>(t);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">size</span>() == n) &#123;<br>                <span class="hljs-keyword">auto</span> p = R-&gt;left;<br>                hash.<span class="hljs-built_in">erase</span>(p-&gt;key);<br>                <span class="hljs-built_in">remove</span>(p);<br>                <span class="hljs-keyword">delete</span> p;<br>            &#125;<br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            hash[key] = t;<br>            <span class="hljs-built_in">insert</span>(t);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="148-排序链表-medium">148. *排序链表(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></p>
</blockquote>
<ul>
<li>如果要求空间复杂度是常数, 那么只能用非递归的归并排序.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>       <span class="hljs-comment">// 统计链表节点数目</span><br>       <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p ; p = p-&gt;next) n ++;<br><br>       <span class="hljs-comment">// 第一层枚举两个归并区间中每个区间的长度</span><br>       <span class="hljs-comment">// 一共做n-1层, 最终合并到n个元素</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i *= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), cur = dummy;<br>            <span class="hljs-comment">// 第二层以枚举由所有的两个归并区间</span><br>         		<span class="hljs-comment">// 注意这里一定是j &lt;= n, 因为j = n证明区间里面只有一个元素, 也要单独做一层.</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j += i * <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-comment">// head存储归并区间开头</span><br>                <span class="hljs-keyword">auto</span> p = head, q = p;<br>                <span class="hljs-comment">// 把q放到下一个归并区间开头, 归并区间长度很可能不足i</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; i &amp;&amp; q; k ++) q = q-&gt;next;<br>                <span class="hljs-comment">// o存储下一个归并区间的开头, 方便更新head</span><br>                <span class="hljs-keyword">auto</span> o = q;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; i &amp;&amp; o; k ++) o = o-&gt;next;<br>                <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (l &lt; i &amp;&amp; r &lt; i &amp;&amp; p &amp;&amp; q)<br>                    <span class="hljs-keyword">if</span> (p-&gt;val &lt;= q-&gt;val) cur = cur-&gt;next = p, p = p-&gt;next, l ++;<br>                    <span class="hljs-keyword">else</span> cur = cur-&gt;next = q, q = q-&gt;next, r ++;<br>                <span class="hljs-keyword">while</span> (l &lt; i &amp;&amp; p) cur = cur-&gt;next = p, p = p-&gt;next, l ++;<br>                <span class="hljs-keyword">while</span> (r &lt; i &amp;&amp; q) cur = cur-&gt;next = q, q = q-&gt;next, r ++;<br>                head = o;<br>            &#125;<br>            <span class="hljs-comment">// 做完一层, 最后的节点next是NULL</span><br>            cur-&gt;next = <span class="hljs-literal">NULL</span>;<br>            head = dummy-&gt;next;<br>       &#125;<br>       <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="152-乘积最大子数组-medium">152. *乘积最大子数组(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/">https://leetcode.cn/problems/maximum-product-subarray/</a></p>
</blockquote>
<ul>
<li>设<code>f[i]</code>, <code>g[i]</code>分别表示以<code>i</code>结尾的, 连续子数组乘积的最大值和最小值.
<ul>
<li>存储最小值的原因是因为乘法具有负负得正的特性.</li>
</ul>
</li>
<li>那么<code>f[i] = max(nums[i], f[i - 1] * nums[i], g[i - 1] * nums[i])</code>.</li>
<li>并且<code>g[i] = min(nums[i], f[i - 1] * nums[i], g[i - 1] * nums[i])</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>], f = nums[<span class="hljs-number">0</span>], g = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-type">int</span> fp = f, gp = g;<br>            f = <span class="hljs-built_in">max</span>(nums[i], <span class="hljs-built_in">max</span>(nums[i] * fp, nums[i] * gp));<br>            g = <span class="hljs-built_in">min</span>(nums[i], <span class="hljs-built_in">min</span>(nums[i] * fp, nums[i] * gp));<br>            ans = <span class="hljs-built_in">max</span>(ans, f);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="153-寻找旋转排序数组中的最小值-medium">153. *寻找旋转排序数组中的最小值(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/</a></p>
</blockquote>
<ul>
<li>假设数组的第一个元素是<code>nums[0]</code>.</li>
<li>数组的前半部分满足<code>nums[i] &gt;= nums[0]</code>, 后半部分满足<code>nums[i] &lt; nums[0]</code>, 以此来二分.</li>
<li>如果数组完全单调递增, 那么最终二分出来的<code>nums[i] &gt;= nums[0]</code>, 此时直接返回<code>nums[0]</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= nums[<span class="hljs-number">0</span>]) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[l] &gt;= nums[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nums[l];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="155-最小栈-medium">155. 最小栈(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/">https://leetcode.cn/problems/min-stack/</a></p>
</blockquote>
<ul>
<li>直接单独开一个栈, 专门用来存储最小值.</li>
<li>push时, 如果这个最小栈是空的, 或者要插入的值value小于等于(注意, 一定是小于等于)最小栈栈顶, 那么就要向最小栈中插入.</li>
<li>pop时, 如果最小栈的栈顶等于当前栈要pop出去的元素, 那么最小栈就pop.</li>
<li>对于<code>stack</code>来说, 要调用<code>top()</code>一定要保证栈不是空的!!</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk_min;<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        stk.<span class="hljs-built_in">push</span>(val);<br>        <span class="hljs-keyword">if</span> (stk_min.<span class="hljs-built_in">empty</span>() || val &lt;= stk_min.<span class="hljs-built_in">top</span>()) stk_min.<span class="hljs-built_in">push</span>(val);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (stk_min.<span class="hljs-built_in">top</span>() == stk.<span class="hljs-built_in">top</span>()) stk_min.<span class="hljs-built_in">pop</span>();<br>       stk.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">top</span>(); <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> stk_min.<span class="hljs-built_in">top</span>(); <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="160-相交链表-easy">160. *相交链表(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></p>
</blockquote>
<ul>
<li>让两个指针同时向前走一步, 如果有一个指针走到尽头, 那么就把它放到第二个指针的头部继续走.</li>
<li>当两个指针相同时, 如果不为NULL, 那么就是相遇点, 否则就不是.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = headA, q = headB;<br>        <span class="hljs-keyword">while</span> (p != q) &#123;<br>            <span class="hljs-keyword">if</span> (p) p = p-&gt;next;<br>            <span class="hljs-keyword">else</span> p = headB;<br>            <span class="hljs-keyword">if</span> (q) q = q-&gt;next;<br>            <span class="hljs-keyword">else</span> q = headA;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="169-多数元素-easy">169. *多数元素(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/">https://leetcode.cn/problems/majority-element/</a></p>
</blockquote>
<ul>
<li>摩尔投票算法: 使用$O(n)$时间复杂度, $O(1)$的空间复杂度, 找到一个数组中的众数.
<ul>
<li>从前到后遍历数组中的元素<code>x</code>, 并且维护一个当前候选人<code>r</code>和投票数<code>c</code>.</li>
<li>如果某个元素<code>x</code>等于<code>r</code>, 那么投票数<code>c ++</code>.</li>
<li>如果不等于<code>r</code>, 那么投票数<code>c --</code>.</li>
<li>如果投票数减到0, 那么<code>r</code>就要换人.</li>
<li>最终的<code>r</code>就是赢家.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (!c) r = x;<br>            <span class="hljs-keyword">if</span> (x == r) c ++;<br>            <span class="hljs-keyword">else</span> c --;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="189-轮转数组-medium">189 *轮转数组(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/">https://leetcode.cn/problems/rotate-array/</a></p>
</blockquote>
<ul>
<li>
<p>这种题一般是把一个数组/序列的一部分移动到最前面的位置, 通用做法是:</p>
<ul>
<li>先反转整个数组, 再分别反转数组的前面/后面的位置.</li>
</ul>
</li>
<li>
<p>注意: <code>k</code>可能是一个很大的异常值, 需要模上数组长度.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        k = k % nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">begin</span>() + k);<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + k, nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="198-打家劫舍-medium">198. *打家劫舍 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p>
</blockquote>
<ul>
<li>状态机DP: <code>f[i][0]</code>表示第<code>i</code>个房子不打劫, <code>f[i][1]</code>表示打劫, 从后向前递推即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            f[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            f[i][<span class="hljs-number">1</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(f[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="199-二叉树的右视图-medium">199. *二叉树的右视图(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">https://leetcode.cn/problems/binary-tree-right-side-view/</a></p>
</blockquote>
<ul>
<li>右视图序列就是层序遍历中每一层最后一个节点组成的序列.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (i == len - <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="200-岛屿数量-medium">200. *岛屿数量 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></p>
</blockquote>
<ul>
<li>Flood Fill算法:
<ul>
<li>每次遇到一块陆地, 就从这个陆地为起点进行搜索, 从这个起点向四周扩散, 如果再次遇到陆地, 就递归搜索.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                    <span class="hljs-built_in">dfs</span>(grid, i, j), ans ++;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        grid[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m || grid[a][b] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">dfs</span>(grid, a, b);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="206-反转链表-easy">206. *反转链表(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>
</blockquote>
<ul>
<li>递归方法: 注意先判断链表是否是空/只有一个节点.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> tail = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代方法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *p = <span class="hljs-literal">NULL</span>;<br>        ListNode *q = head;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">auto</span> r = q-&gt;next;<br>            q-&gt;next = p;<br>            p = q, q = r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="207-课程表-medium">207. *课程表(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">https://leetcode.cn/problems/course-schedule/</a></p>
</blockquote>
<ul>
<li>从先修课程到后置课程连接一条有向边, 组成一个有向图.</li>
<li>然后用拓扑排序, 所有入度为0的节点先入队, 然后BFS, 每次扩展一层就把入度-1, 然后再次把入度为0的点入队.</li>
<li>如果一个图有环, 那么当遍历到环的入口节点之后, 入口节点入度-1后还是1, 永远无法变成0, 那么这种节点就永远无法进入队列, 因此只要进入/弹出队列的节点数目小于<code>n</code>, 就证明有环.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = numCourses;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n)</span></span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e: prerequisites) &#123;<br>            <span class="hljs-type">int</span> a = e[<span class="hljs-number">1</span>], b = e[<span class="hljs-number">0</span>];<br>            g[a].<span class="hljs-built_in">push_back</span>(b); d[b] ++;<br>        &#125;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span> (!d[i]) q.<span class="hljs-built_in">push</span>(i);<br>        <br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> u: g[t])<br>                <span class="hljs-keyword">if</span> (-- d[u] == <span class="hljs-number">0</span>)<br>                    q.<span class="hljs-built_in">push</span>(u);<br>            cnt ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt == n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="208-实现Trie-前缀树">208. *实现Trie(前缀树)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">https://leetcode.cn/problems/implement-trie-prefix-tree/</a></p>
</blockquote>
<ul>
<li>前缀树模板题.</li>
<li>前缀树存储的元素需要有固定的字符集进行编码, 假设字符集中的元素个数为n, 那么前缀树就是一个n叉树.</li>
<li>n叉树的节点有两个成员变量:
<ul>
<li>一个用来存储所有的儿子.</li>
<li>另一个用来存储这个节点是否是某个元素的结尾.</li>
</ul>
</li>
<li>查询和插入都是$O(n)$的时间复杂度, 其中$n$是字符集元素的个数.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        Node *son[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">bool</span> is_end;<br><br>        <span class="hljs-built_in">Node</span>() &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i ++) son[i] = <span class="hljs-literal">NULL</span>;<br>            is_end = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125; *root;<br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: word) &#123;<br>            <span class="hljs-type">int</span> u = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (!p-&gt;son[u]) p-&gt;son[u] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>            p = p-&gt;son[u];<br>        &#125;<br>        p-&gt;is_end = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: word) &#123;<br>            <span class="hljs-type">int</span> u = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (!p-&gt;son[u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p-&gt;son[u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p-&gt;is_end;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: prefix) &#123;<br>            <span class="hljs-type">int</span> u = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (!p-&gt;son[u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p-&gt;son[u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="215-数组中的第K个最大元素-medium">215. *数组中的第K个最大元素(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p>
</blockquote>
<ul>
<li>首先注意题目要求是第k个最大, 还是第k个最小.</li>
<li>本题是快速选择算法.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k); <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> nums[l];<br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = nums[l + (r - l) / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (nums[ ++ i] &gt; x);<br>            <span class="hljs-keyword">while</span> (nums[ --j] &lt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k &lt;= sl) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(nums, l, j, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(nums, j + <span class="hljs-number">1</span>, r, k - sl);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树-easy">226. *翻转二叉树(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></p>
</blockquote>
<ul>
<li>首先递归翻转左子树和右子树, 然后将左子树和右子树进行交换即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        root-&gt;left = right;<br>        root-&gt;right = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="230-二叉搜索树中第K小的元素-medium">230. *二叉搜索树中第K小的元素(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">https://leetcode.cn/problems/kth-smallest-element-in-a-bst/</a></p>
</blockquote>
<ul>
<li>中序遍历的过程中, 每次遍历一个节点, 就将计数器+1, 计数到<code>k</code>的时候, 就找到了第k小的元素.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> k, ans;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> _k)</span> </span>&#123;<br>        k = _k;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(root-&gt;left)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (-- k == <span class="hljs-number">0</span>) &#123;<br>            ans = root-&gt;val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="234-回文链表-easy">234. *回文链表(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></p>
</blockquote>
<ul>
<li>首先, 找到链表的中间节点.</li>
<li>之后, 将中间节点后面的链表反转.</li>
<li>然后, 将反转部分的链表和前半部分的链表进行对比即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">auto</span> cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) &#123;<br>            cnt ++;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        cnt = cnt % <span class="hljs-number">2</span> ? cnt / <span class="hljs-number">2</span> : cnt / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br><br>        cur = head;<br>        <span class="hljs-keyword">while</span> (cnt --) cur = cur-&gt;next;<br><br>        ListNode *p = <span class="hljs-literal">NULL</span>;<br>        ListNode *q = cur-&gt;next;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">auto</span> r = q-&gt;next;<br>            q-&gt;next = p;<br>            p = q, q = r;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> l1 = head, l2 = p;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val != l2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            l1 = l1-&gt;next, l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="236-二叉树的最近公共祖先-medium">236. *二叉树的最近公共祖先(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
</blockquote>
<ul>
<li>两个节点的最近公共祖先就是同时包含两个节点的, 并且深度最深的节点.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode *ans = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, p, q);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// root子树是否含有p, q, 都不含00, 有p: 01, 有q: 10, 都有11</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> state = <span class="hljs-built_in">dfs</span>(root-&gt;left, p, q);<br>        <span class="hljs-keyword">if</span> (root == p) state |= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root == q) state |= <span class="hljs-number">2</span>;<br>        state |= <span class="hljs-built_in">dfs</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">3</span> &amp;&amp; !ans) ans = root;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="238-除自身以外数组的乘积">238. *除自身以外数组的乘积</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/">https://leetcode.cn/problems/product-of-array-except-self/</a></p>
</blockquote>
<ul>
<li>思路: 原地算法
<ul>
<li>首先维护一个类似前缀和的数组, <code>s[i]</code>表示从<code>nums[0]</code>乘到<code>nums[i - 1]</code>.</li>
<li>然后用一个<code>suffix</code>维护后缀积, 遍历乘一遍, 直接赋值到前缀和数组就可以.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) s[i] = s[i - <span class="hljs-number">1</span>] * nums[i - <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-type">int</span> suffix = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            s[i] *= suffix;<br>            suffix *= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="239-滑动窗口最大值-hard">239. *滑动窗口最大值(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>        <span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) hh ++;<br>            <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; nums[i] &gt; nums[q[tt]]) tt --;<br>            q[ ++ tt] = i;<br>            <span class="hljs-keyword">if</span> (i - k + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ans.<span class="hljs-built_in">push_back</span>(nums[q[hh]]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="240-搜索二维矩阵II-medium">240. *搜索二维矩阵II (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">https://leetcode.cn/problems/search-a-2d-matrix-ii/</a></p>
</blockquote>
<ul>
<li>拿右上角/左下角的元素作为基准进行搜索即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[x][y] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[x][y] &gt; target) y --;<br>            <span class="hljs-keyword">else</span> x ++;<br>       &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="279-完全平方数-medium">279. *完全平方数(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">https://leetcode.cn/problems/perfect-squares/</a></p>
</blockquote>
<ul>
<li>设<code>f[i]</code>表示能够拼凑出<code>i</code>的方案中, 完全平方数个数的最小值.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">sqrt</span>(x);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(x + <span class="hljs-number">1</span>, <span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= x; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j * j &lt;= i; j ++) &#123;<br>                f[i] = <span class="hljs-built_in">min</span>(f[i], f[i - j * j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[x];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="283-移动零-medium">283. *移动零(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">https://leetcode.cn/problems/move-zeroes/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (x) nums[k ++] = x;<br>       &#125;<br>       <span class="hljs-keyword">while</span> (k &lt; nums.<span class="hljs-built_in">size</span>()) nums[k ++] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="287-寻找重复数-medium">287. *寻找重复数(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">https://leetcode.cn/problems/find-the-duplicate-number/</a></p>
</blockquote>
<ul>
<li>这个题等价于环型链表找环入口问题.</li>
<li>对于一个<code>i</code>, 从<code>i</code>向<code>nums[i]</code>连一条边.</li>
<li>如果有重复数, 一定存在环:
<ul>
<li>首先, 环入口入度为2, 因为<code>nums[i]</code>会出现两次, 但是下标不同.</li>
<li>其次, 环入口出度为1, 因为<code>nums[i]</code>在下标范围.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> p = nums[<span class="hljs-number">0</span>], q = nums[nums[<span class="hljs-number">0</span>]];<br>        <span class="hljs-keyword">while</span> (p != q) &#123;<br>            p = nums[p];<br>            q = nums[nums[q]];<br>        &#125;<br>        p = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (p != q) &#123;<br>            p = nums[p];<br>            q = nums[q];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="295-数据流的中位数-hard">295. *数据流的中位数(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/">https://leetcode.cn/problems/find-median-from-data-stream/</a></p>
</blockquote>
<ul>
<li>用<code>up</code>: 小根堆和<code>down</code>: 大根堆来维护.</li>
<li>如果一个数小于等于<code>down.top()</code>那么就插到<code>down</code>中, 否则就插到<code>up</code>中.</li>
<li>然后需要动态维护<code>down</code>和<code>up</code>的大小, 保证<code>down</code>和<code>up</code>大小相等, 或者<code>down.size() - up.size() = 1</code>.</li>
<li>这样就能维护中位数的边界.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; up;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; down;<br><br>    <span class="hljs-built_in">MedianFinder</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (down.<span class="hljs-built_in">empty</span>() || num &lt;= down.<span class="hljs-built_in">top</span>()) &#123;<br>            down.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (down.<span class="hljs-built_in">size</span>() &gt; up.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) &#123;<br>                up.<span class="hljs-built_in">push</span>(down.<span class="hljs-built_in">top</span>());<br>                down.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            up.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (up.<span class="hljs-built_in">size</span>() &gt; down.<span class="hljs-built_in">size</span>()) &#123;<br>                down.<span class="hljs-built_in">push</span>(up.<span class="hljs-built_in">top</span>());<br>                up.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = up.<span class="hljs-built_in">size</span>() + down.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> down.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> (up.<span class="hljs-built_in">top</span>() + down.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="300-最长递增子序列-medium">300. *最长递增子序列(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></p>
</blockquote>
<ul>
<li>最长上升子序列模型.</li>
<li>注意一点, <code>q</code>数组的长度要初始化成<code>n + 1</code>, 因为最长上升子序列的长度最小值就是1, 没有0, 避免出现下标问题 (因为长度值要作为下标).</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (q[mid] &lt; nums[i]) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            len = <span class="hljs-built_in">max</span>(len, r + <span class="hljs-number">1</span>);<br>            q[r + <span class="hljs-number">1</span>] = nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="322-零钱兑换-medium">322. *零钱兑换(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></p>
</blockquote>
<ul>
<li>设<code>f[i][j]</code>表示从前<code>i</code>个硬币中选, 正好能凑成<code>amount</code>的方案中, 最少的硬币数量.</li>
<li>然后用完全背包问题即可解决.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = coins.<span class="hljs-built_in">size</span>(), m = amount;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= m; j ++) &#123;<br>                f[j] = <span class="hljs-built_in">min</span>(f[j], f[j - coins[i]] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = f[amount] == <span class="hljs-number">0x3f3f3f3f</span> ? <span class="hljs-number">-1</span> : f[amount];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="347-前k个高频元素-medium">347. *前k个高频元素(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p>
</blockquote>
<ul>
<li>首先统计一下数组中各个元素出现的次数.</li>
<li>然后, 用计数排序的思想, 开一个<code>n + 1</code>长度的数组, 数组下标表示出现次数, 这个数组存储出现次数为<code>i</code>的元素有<code>nums[i]</code>种.</li>
<li>然后反向遍历这个计数排序的数组即可得到答案.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums) hash[x] ++;<br><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, c]: hash) cnt[c] ++;<br><br>        <span class="hljs-type">int</span> i = n, t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (t &lt; k) t += cnt[i --];<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, c]: hash)<br>            <span class="hljs-keyword">if</span> (c &gt; i)<br>                ans.<span class="hljs-built_in">push_back</span>(x);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="394-字符串解码-medium">394. *字符串解码(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">https://leetcode.cn/problems/decode-string/</a></p>
</blockquote>
<ul>
<li>这类题是一种前缀表达式的计算问题, 通用思路是用<code>dfs</code>.
<ul>
<li><code>dfs</code>中, 用一个引用变量<code>u</code>记录处理到表达式的哪个位置.</li>
<li>如果遇到算符, 就需要递归地把运算数计算出来.</li>
<li>如果遇到运算数的一部分, 就需要把所有运算数进行拼接.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string s;<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string _s)</span> </span>&#123;<br>        s = _s;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(u);<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;u)</span> </span>&#123;<br>        string ans;<br>        <span class="hljs-keyword">while</span> (u &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[u] != <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[u])) &#123;<br>               <span class="hljs-type">int</span> k = u;<br>               <span class="hljs-keyword">while</span> (k &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[k])) k ++;<br>               <span class="hljs-type">int</span> cnt = <span class="hljs-built_in">stoi</span>(s.<span class="hljs-built_in">substr</span>(u, k - u));<br>               u = k + <span class="hljs-number">1</span>;<br>               string res = <span class="hljs-built_in">dfs</span>(u);<br>               u ++; <span class="hljs-comment">// 过滤]</span><br>               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++) ans += res; <br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[u] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[u] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || s[u] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[u] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) ans += s[u ++];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="416-分割等和子集">416. *分割等和子集</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p>
</blockquote>
<ul>
<li>这个题本质上是一个背包问题:
<ul>
<li>每一个物品的体积就是<code>a[i]</code>.</li>
<li>总体积是数组和<code>sum / 2</code>.</li>
<li>最终的结果是是否可以满足选的物品体积之和等于<code>sum / 2</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) sum += x;<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        sum /= <span class="hljs-number">2</span>;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(sum + <span class="hljs-number">1</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = sum; j &gt;= x; j --) &#123;<br>                f[j] |= f[j - x];<br>            &#125;<br>        <span class="hljs-keyword">return</span> f[sum];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="437-路径总和III-medium">437. *路径总和III (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">https://leetcode.cn/problems/path-sum-iii/</a></p>
</blockquote>
<ul>
<li>首先, 这道题类似于前缀和:
<ul>
<li>要求在前缀和数组<code>s</code>中找到<code>l, r</code>, 使得<code>s[r] - s[l - 1] = k</code>.</li>
<li>也就是当遍历到<code>s[i]</code>时, 要在之前的<code>0&lt;= j &lt; i</code>中, 找到一个<code>s[j]</code>, 使得<code>s[j] = s[i] - k</code>.</li>
<li>那么直接在之前用哈希表存储每一个<code>s[j]</code>就可以了, 当遍历到<code>s[i]</code>, 就查有没有符合题意的<code>s[j]</code>.</li>
</ul>
</li>
<li>注意: 前缀和容易超出<code>int</code>范围, 需要用<code>long long</code>存储.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    unordered_map&lt;LL, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-comment">// 0是前缀和中的0位置的元素 </span><br>        hash[<span class="hljs-number">0</span>]++;<br>        <span class="hljs-built_in">dfs</span>(root, targetSum, (LL)<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> sum, LL cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        cur += root-&gt;val;<br>        res += hash[cur - sum];<br>        hash[cur] ++;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, sum, cur), <span class="hljs-built_in">dfs</span>(root-&gt;right, sum, cur);<br>        hash[cur] --;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="438-找到字符串中所有字母异位词-medium">438 *找到字符串中所有字母异位词(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">https://leetcode.cn/problems/find-all-anagrams-in-a-string/</a></p>
</blockquote>
<ul>
<li>思路:
<ul>
<li>判断两个字符串是否是字母异位词的充要条件是: 两个字符串的字符出现种类, 以及次数相同.</li>
<li>直接维护一个<code>p.size()</code>的滑动窗口, 判断滑动窗口内的子串是否和<code>p</code>是字母异位词即可.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>       unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : p) hash[c] ++;<br>       <span class="hljs-type">int</span> tot = hash.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// p中有多少种字符</span><br>       <br>       <span class="hljs-comment">// 符合条件的字符种类数目</span><br>       <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>       vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>         <span class="hljs-comment">// 处理滑动窗口边界</span><br>            <span class="hljs-keyword">if</span> (i - j + <span class="hljs-number">1</span> &gt; p.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-keyword">if</span> (hash[s[j]] == <span class="hljs-number">0</span>) k --;<br>                hash[s[j ++]] ++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (--hash[s[i]] == <span class="hljs-number">0</span>) k ++;<br>            <span class="hljs-keyword">if</span> (k == tot) ans.<span class="hljs-built_in">push_back</span>(j);<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="543-二叉树的直径-easy">543. *二叉树的直径(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">https://leetcode.cn/problems/diameter-of-binary-tree/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>  <span class="hljs-comment">// dfs的意思是, 从root出发, 包括root, 到达底部的最长路径上节点的个数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left), right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>      <span class="hljs-comment">// 其实应该是left + right  + 1 - 1, +1表示加上root这个点, -1表示求边数</span><br>        ans = <span class="hljs-built_in">max</span>(ans, left + right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="560-和为k的子数组-medium">560. *和为k的子数组 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">https://leetcode.cn/problems/subarray-sum-equals-k/</a></p>
</blockquote>
<ul>
<li>思路: 假设前缀和数组是<code>s</code>, 问题就等价于前缀和数组中是否存在<code>s[r] - s[l - 1] = k</code>, 和两数之和本质相同.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) &#123;<br>            res += hash[s[i] - k];<br>            hash[s[i]] ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="739-每日温度-medium">739. *每日温度(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></p>
</blockquote>
<ul>
<li>单调栈问题可以用$O(n)$的时间复杂度求出一个元素左侧/右侧比他大/小, /具有单调性的最近的元素.</li>
<li>如果要找到右边第一个比他大的元素, 那么在遍历它之前, 就需要有右侧的先验知识, 因此从右向左维护单调栈.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; t)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>() &amp;&amp; t[i] &gt;= t[stk.<span class="hljs-built_in">top</span>()]) stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>())<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">else</span><br>                ans.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>() - i);<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="763-划分字母区间-medium">763. *划分字母区间(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">https://leetcode.cn/problems/partition-labels/</a></p>
</blockquote>
<ul>
<li>这道题的本质是区间问题, 对于每一种字符, 都有一个开始和结束位置, 这个位置看成一个一个区间, 最终合并区间就是分割方案.</li>
<li>实际上只需维护一个所有区间能到达的最右范围<code>end</code>, 从前向后遍历, 如果最右范围<code>end = i</code>, 那么就说明<code>[0, i]</code>这一段已经和后面一段不可能产生交集, 因此就可以作为一个合法分割.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> last[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) last[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br><br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            end = <span class="hljs-built_in">max</span>(end, last[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (end == i) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(end - start + <span class="hljs-number">1</span>);<br>                start = end = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="994-腐烂的🍊-medium">994. *腐烂的🍊 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotting-oranges/">https://leetcode.cn/problems/rotting-oranges/</a></p>
</blockquote>
<ul>
<li>多源BFS问题:
<ul>
<li>直接把腐烂的橘子放入队列中宽搜即可.</li>
<li>注意一个逻辑, 在队列中统计的是BFS的层数, 最终的答案应该是层数 - 1, 而且注意, 这个层数- 1应该是建立在队列中一开始有东西的前提下, 如果一开始就没有东西, 那么直接返回0.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        queue&lt;PII&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>)<br>                    q.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>        <br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>()) res --;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (len --) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>                    <span class="hljs-type">int</span> a = t.x + dx[i], b = t.y + dy[i];<br>                    <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m || grid[a][b] != <span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">continue</span>;<br>                    grid[a][b] = <span class="hljs-number">2</span>;<br>                    q.<span class="hljs-built_in">push</span>(&#123;a, b&#125;);<br>                &#125;<br>            &#125;<br>            res ++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="1143-最长公共子序列-medium">1143. *最长公共子序列(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">https://leetcode.cn/problems/longest-common-subsequence/description/</a></p>
</blockquote>
<ul>
<li>设<code>f[i][j]</code>表示<code>a[1:i]</code>, <code>b[1:j]</code>中所有公共子序列中长度的最大值.</li>
<li>那么<code>f[i][j]</code>可以由两种状态转移:
<ul>
<li><code>a[i] == b[j]</code>, 那么<code>f[i][j] = f[i - 1][j - 1] + 1</code>.</li>
<li><code>a[i] != b[j]</code>, 那么<code>f[i][j] = max(f[i - 1][j], f[i][j - 1])</code>.
<ul>
<li>这种情况就是子序列中选<code>a[i]</code>还是选<code>b[j]</code>, 这两部分可能有重叠, 但是对于最大值来讲无妨.</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = text1.<span class="hljs-built_in">size</span>(), m = text2.<span class="hljs-built_in">size</span>();<br>        text1 = <span class="hljs-string">&#x27; &#x27;</span> + text1;<br>        text2 = <span class="hljs-string">&#x27; &#x27;</span> + text2;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1[i] == text2[j])<br>                    f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

      
       <hr><span style="font-style: italic;color: gray;"> 向阳而生, 喜欢聪明的人. </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©B1ueDrops
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
