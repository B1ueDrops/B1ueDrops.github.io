<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>LeetCode-1000题题解 | B1ueDrops</title>
  <meta name="keywords" content="">
  <meta name="description" content="LeetCode-1000题题解 | B1ueDrops">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="向阳而生, 喜欢聪明的人.">
<meta property="og:type" content="website">
<meta property="og:title" content="B1ueDrops">
<meta property="og:url" content="https://b1uedrops.github.io/about.html">
<meta property="og:site_name" content="B1ueDrops">
<meta property="og:description" content="向阳而生, 喜欢聪明的人.">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-02-09T08:49:59.399Z">
<meta property="article:modified_time" content="2024-02-09T08:49:59.394Z">
<meta property="article:author" content="B1ueDrops">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpeg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpeg"/>
</a>
<div class="author">
    <span>B1ueDrops</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/B1ueDrops"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:bluedrops@yeah.net"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=2381446488&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(95)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="编程语言">
            
            编程语言
            <small>(10)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="操作系统">
            
            操作系统
            <small>(3)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="后端技术">
            
            后端技术
            <small>(19)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="金融知识">
            
            金融知识
            <small>(2)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="开发工具">
            
            开发工具
            <small>(7)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="数学">
            
            数学
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="算法">
            
            算法
            <small>(24)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="体系结构">
            
            体系结构
            <small>(4)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="AI-HPC">
            
            AI-HPC
            <small>(12)</small>
        </div>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="English">
            
            English
            <small>(9)</small>
        </div>
        
    </li>

            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  site_url"
               
               href="/about">About</a>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="95">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All 开发工具 "
           href="/2024/11/27/dev_env/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="快速配置完备开发环境(本地/服务器)">快速配置完备开发环境(本地/服务器)</span>
            <span class="post-date" title="2024-11-27 20:25:06">2024/11/27</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/11/27/jetbrains/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Jetbrains系列IDE的使用方式">Jetbrains系列IDE的使用方式</span>
            <span class="post-date" title="2024-11-27 20:25:01">2024/11/27</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/11/25/ml/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="基础机器学习的一些内容">基础机器学习的一些内容</span>
            <span class="post-date" title="2024-11-25 16:02:38">2024/11/25</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/11/25/pytorch_quant/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AI模型量化的理论和实现">AI模型量化的理论和实现</span>
            <span class="post-date" title="2024-11-25 15:54:55">2024/11/25</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/11/25/pytorch_arch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Pytorch的前后端架构">Pytorch的前后端架构</span>
            <span class="post-date" title="2024-11-25 15:54:48">2024/11/25</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/11/21/cuda_env/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CUDA理论和实战">CUDA理论和实战</span>
            <span class="post-date" title="2024-11-21 13:11:31">2024/11/21</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/11/09/valuable-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="其他的算法题题解">其他的算法题题解</span>
            <span class="post-date" title="2024-11-09 18:21:12">2024/11/09</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/11/09/jianzhi_offer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="《剑指Offer》题解">《剑指Offer》题解</span>
            <span class="post-date" title="2024-11-09 18:17:29">2024/11/09</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/11/07/cpu_gemm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CPU后端上的GEMM优化">CPU后端上的GEMM优化</span>
            <span class="post-date" title="2024-11-07 14:16:48">2024/11/07</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/11/07/time_complexity/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="时间复杂度的一些知识">时间复杂度的一些知识</span>
            <span class="post-date" title="2024-11-07 12:12:58">2024/11/07</span>
        </a>
        
        
        <a  class="All 数学 "
           href="/2024/11/07/kalman/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡尔曼滤波数学推导">卡尔曼滤波数学推导</span>
            <span class="post-date" title="2024-11-07 12:08:35">2024/11/07</span>
        </a>
        
        
        <a  class="All 数学 "
           href="/2024/11/07/linear_algebra/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性代数">线性代数</span>
            <span class="post-date" title="2024-11-07 12:08:22">2024/11/07</span>
        </a>
        
        
        <a  class="All 数学 "
           href="/2024/11/07/quaternion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="描述旋转的几种方式">描述旋转的几种方式</span>
            <span class="post-date" title="2024-11-07 12:08:01">2024/11/07</span>
        </a>
        
        
        <a  class="All 数学 "
           href="/2024/11/07/signal_process/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="信号与系统">信号与系统</span>
            <span class="post-date" title="2024-11-07 12:07:42">2024/11/07</span>
        </a>
        
        
        <a  class="All 数学 "
           href="/2024/11/07/probability/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="概率论与数理统计">概率论与数理统计</span>
            <span class="post-date" title="2024-11-07 12:07:18">2024/11/07</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/10/31/acwing_basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AcWing算法基础课题解">AcWing算法基础课题解</span>
            <span class="post-date" title="2024-10-31 20:05:59">2024/10/31</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/10/31/acwing_improve/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AcWing算法提高课题解">AcWing算法提高课题解</span>
            <span class="post-date" title="2024-10-31 19:36:46">2024/10/31</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/10/27/leetcode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LeetCode-1000题题解">LeetCode-1000题题解</span>
            <span class="post-date" title="2024-10-27 11:06:02">2024/10/27</span>
        </a>
        
        
        <a  class="All 金融知识 "
           href="/2024/10/14/economics/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="资源与可持续发展">资源与可持续发展</span>
            <span class="post-date" title="2024-10-14 12:41:46">2024/10/14</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/22/x86_arch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="x86-CPU的体系结构基础">x86-CPU的体系结构基础</span>
            <span class="post-date" title="2024-09-22 13:23:27">2024/09/22</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/20/program_time/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="理解程序运行的时间">理解程序运行的时间</span>
            <span class="post-date" title="2024-09-20 14:22:52">2024/09/20</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/transformer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Transformer的工作原理">Transformer的工作原理</span>
            <span class="post-date" title="2024-09-17 14:16:16">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/roofline_model/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="性能分析的Roofline Model">性能分析的Roofline Model</span>
            <span class="post-date" title="2024-09-17 14:16:00">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/ai_basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="AI的基本模型和实现">AI的基本模型和实现</span>
            <span class="post-date" title="2024-09-17 14:14:52">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/welford/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Welford算法计算方差">Welford算法计算方差</span>
            <span class="post-date" title="2024-09-17 14:14:12">2024/09/17</span>
        </a>
        
        
        <a  class="All AI-HPC "
           href="/2024/09/17/data-augmentation-metric/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="理解数据增广的本质">理解数据增广的本质</span>
            <span class="post-date" title="2024-09-17 14:14:03">2024/09/17</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/09/10/design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="设计模式的实际操作">设计模式的实际操作</span>
            <span class="post-date" title="2024-09-10 18:29:51">2024/09/10</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/09/08/windows_msys2/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Windows环境配置">Windows环境配置</span>
            <span class="post-date" title="2024-09-08 13:53:44">2024/09/08</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/09/06/network_application_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-应用层">计算机网络-应用层</span>
            <span class="post-date" title="2024-09-06 14:31:30">2024/09/06</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/09/06/network_tcp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-传输层">计算机网络-传输层</span>
            <span class="post-date" title="2024-09-06 14:31:18">2024/09/06</span>
        </a>
        
        
        <a  class="All 操作系统 "
           href="/2024/08/16/concurrent_sketch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="并发编程的概述">并发编程的概述</span>
            <span class="post-date" title="2024-08-16 13:48:22">2024/08/16</span>
        </a>
        
        
        <a  class="All 操作系统 "
           href="/2024/08/16/multithread/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="多进程/多线程编程模型">多进程/多线程编程模型</span>
            <span class="post-date" title="2024-08-16 13:48:12">2024/08/16</span>
        </a>
        
        
        <a  class="All 操作系统 "
           href="/2024/08/16/linux_process/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux上的进程控制">Linux上的进程控制</span>
            <span class="post-date" title="2024-08-16 13:48:03">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/network_network_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-网络层">计算机网络-网络层</span>
            <span class="post-date" title="2024-08-16 13:46:58">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/network_datalink_layer/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络-数据链路层">计算机网络-数据链路层</span>
            <span class="post-date" title="2024-08-16 13:46:50">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/tcp_stick/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="如何解决TCP粘包问题">如何解决TCP粘包问题</span>
            <span class="post-date" title="2024-08-16 13:46:38">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/vimium/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Chrome中vimium键位">Chrome中vimium键位</span>
            <span class="post-date" title="2024-08-16 13:46:08">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/yabai/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="yabai窗口管理器键位配置">yabai窗口管理器键位配置</span>
            <span class="post-date" title="2024-08-16 13:45:41">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/lazygit/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="试用LazyGit进行版本控制">试用LazyGit进行版本控制</span>
            <span class="post-date" title="2024-08-16 13:45:31">2024/08/16</span>
        </a>
        
        
        <a  class="All 开发工具 "
           href="/2024/08/16/tmux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="tmux键位配置">tmux键位配置</span>
            <span class="post-date" title="2024-08-16 13:45:09">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/build_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="创建型的设计模式">创建型的设计模式</span>
            <span class="post-date" title="2024-08-16 13:35:12">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/behaviour_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="行为型的设计模式">行为型的设计模式</span>
            <span class="post-date" title="2024-08-16 13:35:00">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/combine_design_pattern/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="组合型的设计模式">组合型的设计模式</span>
            <span class="post-date" title="2024-08-16 13:33:52">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/dns/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="DNS-客户端连接到机房的技术">DNS-客户端连接到机房的技术</span>
            <span class="post-date" title="2024-08-16 13:33:38">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/lvs_nginx/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="LVS/Nginx-服务器调度的技术">LVS/Nginx-服务器调度的技术</span>
            <span class="post-date" title="2024-08-16 13:33:27">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/service_discovery/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="服务发现架构设计">服务发现架构设计</span>
            <span class="post-date" title="2024-08-16 13:33:15">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/storage_rpc/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="存储微服务的架构">存储微服务的架构</span>
            <span class="post-date" title="2024-08-16 13:33:00">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/mq/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="消息中间件技术">消息中间件技术</span>
            <span class="post-date" title="2024-08-16 13:32:10">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/16/concurrent_arch/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="高并发架构通用设计">高并发架构通用设计</span>
            <span class="post-date" title="2024-08-16 13:31:33">2024/08/16</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/08/10/data_replication_center/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机房高可用技术">机房高可用技术</span>
            <span class="post-date" title="2024-08-10 20:04:18">2024/08/10</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/07/05/parser/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="编译原理-Parser的知识合集">编译原理-Parser的知识合集</span>
            <span class="post-date" title="2024-07-05 16:29:19">2024/07/05</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/07/04/raii/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="资源管理中RAII的概念">资源管理中RAII的概念</span>
            <span class="post-date" title="2024-07-04 16:16:39">2024/07/04</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/07/04/char_encode/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="字符集与字符编码的深度理解">字符集与字符编码的深度理解</span>
            <span class="post-date" title="2024-07-04 11:32:31">2024/07/04</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/07/04/ieee_754/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="体系结构中的浮点数">体系结构中的浮点数</span>
            <span class="post-date" title="2024-07-04 11:24:35">2024/07/04</span>
        </a>
        
        
        <a  class="All 金融知识 "
           href="/2024/05/22/quant_analysis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="金融量化分析模型">金融量化分析模型</span>
            <span class="post-date" title="2024-05-22 18:08:38">2024/05/22</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/17/car-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="汽车英语">汽车英语</span>
            <span class="post-date" title="2024-05-17 13:37:34">2024/05/17</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/14/regular_expression/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="正则表达式原理和实战">正则表达式原理和实战</span>
            <span class="post-date" title="2024-05-14 20:14:59">2024/05/14</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/13/restaurant_english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="饭店英语">饭店英语</span>
            <span class="post-date" title="2024-05-13 20:25:52">2024/05/13</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/12/frontend-lang/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="使用Vue快速搭建网站原型">使用Vue快速搭建网站原型</span>
            <span class="post-date" title="2024-05-12 21:13:45">2024/05/12</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/12/hotel-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="酒店英语">酒店英语</span>
            <span class="post-date" title="2024-05-12 12:29:02">2024/05/12</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/05/10/airport-english/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="机场英语">机场英语</span>
            <span class="post-date" title="2024-05-10 10:12:57">2024/05/10</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/05/09/practical-go/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Go语言原理与实战">Go语言原理与实战</span>
            <span class="post-date" title="2024-05-09 20:48:25">2024/05/09</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/05/09/database-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="PostgreSQL数据库教程">PostgreSQL数据库教程</span>
            <span class="post-date" title="2024-05-09 20:24:37">2024/05/09</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/05/09/cache-basic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Cache的基础知识与设计策略">Cache的基础知识与设计策略</span>
            <span class="post-date" title="2024-05-09 20:12:19">2024/05/09</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/13/practical-rust/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Rust原理与实战">Rust原理与实战</span>
            <span class="post-date" title="2024-04-13 17:05:26">2024/04/13</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/04/07/python_many/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Python原理与实战">Python原理与实战</span>
            <span class="post-date" title="2024-04-07 10:46:59">2024/04/07</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/30/binary-tree/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二叉树系列">二叉树系列</span>
            <span class="post-date" title="2024-03-30 17:07:34">2024/03/30</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/24/data-struct/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数据结构系列">数据结构系列</span>
            <span class="post-date" title="2024-03-24 14:10:22">2024/03/24</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/shell_script/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Shell脚本基础与实战">Shell脚本基础与实战</span>
            <span class="post-date" title="2024-03-22 12:50:32">2024/03/22</span>
        </a>
        
        
        <a  class="All 编程语言 "
           href="/2024/03/22/modern_cpp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Modern C++基础与实战">Modern C++基础与实战</span>
            <span class="post-date" title="2024-03-22 11:31:11">2024/03/22</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/linear-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="线性DP">线性DP</span>
            <span class="post-date" title="2024-03-20 18:11:22">2024/03/20</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/20/tree-dp/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="树形DP">树形DP</span>
            <span class="post-date" title="2024-03-20 18:10:56">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-method/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Methodology">英语科技论文写作模型-Methodology</span>
            <span class="post-date" title="2024-03-20 16:53:17">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-abstract/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Abstract">英语科技论文写作模型-Abstract</span>
            <span class="post-date" title="2024-03-20 16:49:54">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-conclusion/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Conclusion">英语科技论文写作模型-Conclusion</span>
            <span class="post-date" title="2024-03-20 16:49:46">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/20/sci-writing-results/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Results">英语科技论文写作模型-Results</span>
            <span class="post-date" title="2024-03-20 16:49:31">2024/03/20</span>
        </a>
        
        
        <a  class="All English "
           href="/2024/03/19/sci-writing-introduction/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="英语科技论文写作模型-Introduction">英语科技论文写作模型-Introduction</span>
            <span class="post-date" title="2024-03-19 10:16:07">2024/03/19</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/10/catalan/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="卡特兰数系列">卡特兰数系列</span>
            <span class="post-date" title="2024-03-10 12:47:19">2024/03/10</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/03/knapsack/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="背包问题">背包问题</span>
            <span class="post-date" title="2024-03-03 16:22:21">2024/03/03</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/03/02/virtualmem/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="虚拟内存的基础知识和设计">虚拟内存的基础知识和设计</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/sim-plus/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="高精度加减乘除">高精度加减乘除</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/prefix-sum-diff/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="前缀和/差分">前缀和/差分</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/other-algorithm/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="其他算法/模拟题">其他算法/模拟题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/parathesis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="括号序列">括号序列</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/mathematic/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="数学问题">数学问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/interval/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="区间问题">区间问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/graph/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="图论">图论</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/greedy/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="贪心算法">贪心算法</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/dfs/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深度优先搜索">深度优先搜索</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 体系结构 "
           href="/2024/03/02/cache-coherence/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="缓存一致性">缓存一致性</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/catch-rain/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="接雨水问题">接雨水问题</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/bfs/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="广度优先搜索">广度优先搜索</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 算法 "
           href="/2024/03/02/binary-search/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="二分系列">二分系列</span>
            <span class="post-date" title="2024-03-02 19:59:34">2024/03/02</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/03/01/clean_code/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="代码整洁之道">代码整洁之道</span>
            <span class="post-date" title="2024-03-01 14:30:08">2024/03/01</span>
        </a>
        
        
        <a  class="All 后端技术 "
           href="/2024/03/01/software_rule/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="面向对象设计的基本原则">面向对象设计的基本原则</span>
            <span class="post-date" title="2024-03-01 14:30:02">2024/03/01</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-leetcode" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">LeetCode-1000题题解</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="算法">算法</a>
            
        </span>
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-11-11 19:52:18'>2024-10-27 11:06</time>
        
    </div>
    <div class="article-meta">
        
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-easy"><span class="toc-text">1. *两数之和(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-easy"><span class="toc-text">2. *两数相加 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-medium"><span class="toc-text">3. *无重复字符的最长子串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-hard"><span class="toc-text">4. 寻找两个正序数组的中位数(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-medium"><span class="toc-text">5. 最长回文子串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8-medium"><span class="toc-text">11. *盛水最多的容器(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">15. *三数之和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">16. 最接近的三数之和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-medium"><span class="toc-text">17. *电话号码的字母组合(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">18. 四数之和 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-medium"><span class="toc-text">19. *删除链表的倒数第n个节点(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-easy"><span class="toc-text">20. *有效的括号(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">21. *合并两个有序的链表 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90-medium"><span class="toc-text">22. *括号生成(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-hard"><span class="toc-text">23. *合并K个升序链表(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-medium"><span class="toc-text">24. *两两交换链表中的节点(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-hard"><span class="toc-text">25. *K个一组翻转链表(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-medium"><span class="toc-text">31. *下一个排列 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-medium"><span class="toc-text">34. *在排序数组中查找元素的第一个和最后一个位置(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-easy"><span class="toc-text">35. *搜索插入位置(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97-medium"><span class="toc-text">38. 外观数列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-medium"><span class="toc-text">39. *组合总和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0-medium"><span class="toc-text">41. *缺失的第一个正数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-hard"><span class="toc-text">42. *接雨水(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII-medium"><span class="toc-text">45. *跳跃游戏II(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97-medium"><span class="toc-text">46. *全排列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-medium"><span class="toc-text">48. *旋转图像(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-medium"><span class="toc-text">49. *字母异位词分组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N%E7%9A%87%E5%90%8E-hard"><span class="toc-text">51. *N皇后 (hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-medium"><span class="toc-text">53. *最大子数组和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-medium"><span class="toc-text">54. *螺旋矩阵(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-medium"><span class="toc-text">55. *跳跃游戏(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-medium"><span class="toc-text">56. *合并区间(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-medium"><span class="toc-text">62. *不同路径(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-medium"><span class="toc-text">64. *最小路径和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF-easy"><span class="toc-text">70. *爬楼梯 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-medium"><span class="toc-text">72. *编辑距离(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6-medium"><span class="toc-text">73. *矩阵置零(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-medium"><span class="toc-text">74. *搜索二维矩阵(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-medium"><span class="toc-text">75. *颜色分类(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-hard"><span class="toc-text">76. *最小覆盖子串(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86-medium"><span class="toc-text">78. *子集(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-medium"><span class="toc-text">79. *单词搜索(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-hard"><span class="toc-text">84. *柱状图中最大的矩形(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II-medium"><span class="toc-text">92. 反转链表 II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-easy"><span class="toc-text">94. *二叉树的中序遍历(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="toc-text">98. *验证二叉搜索树(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="toc-text">101. *对称二叉树(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">102. *二叉树的层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-easy"><span class="toc-text">104. *二叉树的最大深度(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-medium"><span class="toc-text">105. *从前序与中序遍历序列构造二叉树 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="toc-text">108. *将有序数组转换为二叉搜索树(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8-medium"><span class="toc-text">114. *二叉树展开为链表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-easy"><span class="toc-text">118. *杨辉三角(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-easy"><span class="toc-text">121. *买卖股票的最佳时机(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-hard"><span class="toc-text">124. *二叉树中的最大路径和(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97-medium"><span class="toc-text">128. *最长连续序列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-medium"><span class="toc-text">131. *分割回文串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-easy"><span class="toc-text">136. *只出现一次的数字(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-medium"><span class="toc-text">139. *单词拆分(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">138. *随机链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">141. *环形链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II-medium"><span class="toc-text">142. *环形链表II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-medium"><span class="toc-text">144. 二叉树的前序遍历(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU%E7%BC%93%E5%AD%98-medium"><span class="toc-text">146. *LRU缓存(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8-medium"><span class="toc-text">148. *排序链表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="toc-text">152. *乘积最大子数组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-medium"><span class="toc-text">153. *寻找旋转排序数组中的最小值(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88-medium"><span class="toc-text">155. 最小栈(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">160. *相交链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0-easy"><span class="toc-text">169. *多数元素(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84-medium"><span class="toc-text">189 *轮转数组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-medium"><span class="toc-text">198. *打家劫舍 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE-medium"><span class="toc-text">199. *二叉树的右视图(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-medium"><span class="toc-text">200. *岛屿数量 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">206. *反转链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8-medium"><span class="toc-text">207. *课程表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">208. *实现Trie(前缀树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-medium"><span class="toc-text">215. *数组中的第K个最大元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="toc-text">226. *翻转二叉树(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0-medium"><span class="toc-text">230. *二叉搜索树中第K小的元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">234. *回文链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-medium"><span class="toc-text">236. *二叉树的最近公共祖先(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-text">238. *除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-hard"><span class="toc-text">239. *滑动窗口最大值(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II-medium"><span class="toc-text">240. *搜索二维矩阵II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-medium"><span class="toc-text">279. *完全平方数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6-medium"><span class="toc-text">283. *移动零(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0-medium"><span class="toc-text">287. *寻找重复数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-hard"><span class="toc-text">295. *数据流的中位数(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="toc-text">300. *最长递增子序列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-medium"><span class="toc-text">322. *零钱兑换(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-medium"><span class="toc-text">347. *前k个高频元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81-medium"><span class="toc-text">394. *字符串解码(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text">416. *分割等和子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII-medium"><span class="toc-text">437. *路径总和III (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-medium"><span class="toc-text">438 *找到字符串中所有字母异位词(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-easy"><span class="toc-text">543. *二叉树的直径(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="toc-text">560. *和为k的子数组 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-medium"><span class="toc-text">739. *每日温度(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-medium"><span class="toc-text">763. *划分字母区间(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%F0%9F%8D%8A-medium"><span class="toc-text">994. *腐烂的🍊 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="toc-text">1143. *最长公共子序列(medium)</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>*是LeetCode Hot 100中的题</p>
</blockquote>
<p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-easy"><span class="toc-text">1. *两数之和(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-easy"><span class="toc-text">2. *两数相加 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-medium"><span class="toc-text">3. *无重复字符的最长子串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-hard"><span class="toc-text">4. 寻找两个正序数组的中位数(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-medium"><span class="toc-text">5. 最长回文子串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8-medium"><span class="toc-text">11. *盛水最多的容器(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">15. *三数之和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">16. 最接近的三数之和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-medium"><span class="toc-text">17. *电话号码的字母组合(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="toc-text">18. 四数之和 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E8%8A%82%E7%82%B9-medium"><span class="toc-text">19. *删除链表的倒数第n个节点(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-easy"><span class="toc-text">20. *有效的括号(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">21. *合并两个有序的链表 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90-medium"><span class="toc-text">22. *括号生成(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-hard"><span class="toc-text">23. *合并K个升序链表(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-medium"><span class="toc-text">24. *两两交换链表中的节点(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-hard"><span class="toc-text">25. *K个一组翻转链表(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-medium"><span class="toc-text">31. *下一个排列 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-medium"><span class="toc-text">34. *在排序数组中查找元素的第一个和最后一个位置(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-easy"><span class="toc-text">35. *搜索插入位置(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97-medium"><span class="toc-text">38. 外观数列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-medium"><span class="toc-text">39. *组合总和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0-medium"><span class="toc-text">41. *缺失的第一个正数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-hard"><span class="toc-text">42. *接雨水(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII-medium"><span class="toc-text">45. *跳跃游戏II(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97-medium"><span class="toc-text">46. *全排列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F-medium"><span class="toc-text">48. *旋转图像(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-medium"><span class="toc-text">49. *字母异位词分组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-N%E7%9A%87%E5%90%8E-hard"><span class="toc-text">51. *N皇后 (hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-medium"><span class="toc-text">53. *最大子数组和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-medium"><span class="toc-text">54. *螺旋矩阵(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-medium"><span class="toc-text">55. *跳跃游戏(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-medium"><span class="toc-text">56. *合并区间(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-medium"><span class="toc-text">62. *不同路径(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-medium"><span class="toc-text">64. *最小路径和(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF-easy"><span class="toc-text">70. *爬楼梯 (easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-medium"><span class="toc-text">72. *编辑距离(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6-medium"><span class="toc-text">73. *矩阵置零(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-medium"><span class="toc-text">74. *搜索二维矩阵(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-medium"><span class="toc-text">75. *颜色分类(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-hard"><span class="toc-text">76. *最小覆盖子串(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#78-%E5%AD%90%E9%9B%86-medium"><span class="toc-text">78. *子集(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-medium"><span class="toc-text">79. *单词搜索(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-hard"><span class="toc-text">84. *柱状图中最大的矩形(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-II-medium"><span class="toc-text">92. 反转链表 II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-easy"><span class="toc-text">94. *二叉树的中序遍历(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="toc-text">98. *验证二叉搜索树(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="toc-text">101. *对称二叉树(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">102. *二叉树的层序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-easy"><span class="toc-text">104. *二叉树的最大深度(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-medium"><span class="toc-text">105. *从前序与中序遍历序列构造二叉树 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="toc-text">108. *将有序数组转换为二叉搜索树(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8-medium"><span class="toc-text">114. *二叉树展开为链表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-easy"><span class="toc-text">118. *杨辉三角(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-easy"><span class="toc-text">121. *买卖股票的最佳时机(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C-hard"><span class="toc-text">124. *二叉树中的最大路径和(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97-medium"><span class="toc-text">128. *最长连续序列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-medium"><span class="toc-text">131. *分割回文串(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-easy"><span class="toc-text">136. *只出现一次的数字(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-medium"><span class="toc-text">139. *单词拆分(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#138-%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-text">138. *随机链表的复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">141. *环形链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II-medium"><span class="toc-text">142. *环形链表II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-medium"><span class="toc-text">144. 二叉树的前序遍历(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#146-LRU%E7%BC%93%E5%AD%98-medium"><span class="toc-text">146. *LRU缓存(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8-medium"><span class="toc-text">148. *排序链表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="toc-text">152. *乘积最大子数组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-medium"><span class="toc-text">153. *寻找旋转排序数组中的最小值(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#155-%E6%9C%80%E5%B0%8F%E6%A0%88-medium"><span class="toc-text">155. 最小栈(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">160. *相交链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0-easy"><span class="toc-text">169. *多数元素(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84-medium"><span class="toc-text">189 *轮转数组(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-medium"><span class="toc-text">198. *打家劫舍 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE-medium"><span class="toc-text">199. *二叉树的右视图(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-medium"><span class="toc-text">200. *岛屿数量 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">206. *反转链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#207-%E8%AF%BE%E7%A8%8B%E8%A1%A8-medium"><span class="toc-text">207. *课程表(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">208. *实现Trie(前缀树)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-medium"><span class="toc-text">215. *数组中的第K个最大元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="toc-text">226. *翻转二叉树(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0-medium"><span class="toc-text">230. *二叉搜索树中第K小的元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8-easy"><span class="toc-text">234. *回文链表(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-medium"><span class="toc-text">236. *二叉树的最近公共祖先(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF"><span class="toc-text">238. *除自身以外数组的乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-hard"><span class="toc-text">239. *滑动窗口最大值(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#240-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II-medium"><span class="toc-text">240. *搜索二维矩阵II (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-medium"><span class="toc-text">279. *完全平方数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6-medium"><span class="toc-text">283. *移动零(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0-medium"><span class="toc-text">287. *寻找重复数(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#295-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-hard"><span class="toc-text">295. *数据流的中位数(hard)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="toc-text">300. *最长递增子序列(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-medium"><span class="toc-text">322. *零钱兑换(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-medium"><span class="toc-text">347. *前k个高频元素(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81-medium"><span class="toc-text">394. *字符串解码(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-text">416. *分割等和子集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII-medium"><span class="toc-text">437. *路径总和III (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#438-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-medium"><span class="toc-text">438 *找到字符串中所有字母异位词(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84-easy"><span class="toc-text">543. *二叉树的直径(easy)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="toc-text">560. *和为k的子数组 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-medium"><span class="toc-text">739. *每日温度(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-medium"><span class="toc-text">763. *划分字母区间(medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#994-%E8%85%90%E7%83%82%E7%9A%84%F0%9F%8D%8A-medium"><span class="toc-text">994. *腐烂的🍊 (medium)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="toc-text">1143. *最长公共子序列(medium)</span></a></li></ol></div></p>
<h2 id="1-两数之和-easy"><a href="#1-两数之和-easy" class="headerlink" title="1. *两数之和(easy)"></a>1. *两数之和(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></p>
</blockquote>
<ul>
<li>
<p>最无脑的做法: 遍历两个数的所有可能性, 判断和是否是<code>target</code>.</p>
</li>
<li>
<p>如果要优化成<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-1-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-1-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-1-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-1-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-1-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-1-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-1-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-1-TEX-N-29"/></g></g></g></svg>的做法, 就需要扫描一边, 扫描的过程中用之前积累的先验知识做.</p>
<ul>
<li>扫描的时候, 把之前遍历的数据存储到哈希表中, 每次扫描到一个数, 就判断<code>target - nums[i]</code>是否在哈希表中.</li>
<li>时间复杂度: <svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-2-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-2-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-2-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-2-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-2-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-2-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-2-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-2-TEX-N-29"/></g></g></g></svg></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>       vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>       unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(target - nums[i])) <span class="hljs-keyword">return</span> &#123;hash[target - nums[i]], i&#125;;<br>            hash[nums[i]] = i;<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-两数相加-easy"><a href="#2-两数相加-easy" class="headerlink" title="2. *两数相加 (easy)"></a>2. *两数相加 (easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-two-numbers/">https://leetcode.cn/problems/add-two-numbers/</a></p>
</blockquote>
<ul>
<li>数位从后向前枚举, 两个数位相加后, <code>t % 10</code>就是数位的值, 进位的值就是<code>t / 10</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), cur = dummy;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l1 || l2 || t) &#123;<br>            <span class="hljs-keyword">if</span> (l1) t += l1-&gt;val, l1 = l1-&gt;next;<br>            <span class="hljs-keyword">if</span> (l2) t += l2-&gt;val, l2 = l2-&gt;next;<br>            cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t % <span class="hljs-number">10</span>);<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="3-无重复字符的最长子串-medium"><a href="#3-无重复字符的最长子串-medium" class="headerlink" title="3. *无重复字符的最长子串(medium)"></a>3. *无重复字符的最长子串(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">https://leetcode.cn/problems/longest-substring-without-repeating-characters/</a></p>
</blockquote>
<ul>
<li>双指针算法的一个pattern在于, 当我遍历时, 移动一个指针<code>i</code>时, 我可以借助题目中的某些性质, 让另一个指针<code>j</code>不必走某些位置.</li>
<li>在这个题中, 从前到后遍历字符串, 并且统计每一个字符出现的次数<code>hash[s[i]]</code>:
<ul>
<li>如果<code>hash[s[i]] &gt; 1</code>, 证明<code>[j, i]</code>范围内的子串出现了重复, 这个时候<code>j</code>需要向前移动, 直到<code>hash[s[i]] == 1</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            hash[s[i]] ++;<br>            <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; hash[s[i]] &gt; <span class="hljs-number">1</span>) hash[s[j ++]] --;<br>            ans = <span class="hljs-built_in">max</span>(ans, i - j + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="4-寻找两个正序数组的中位数-hard"><a href="#4-寻找两个正序数组的中位数-hard" class="headerlink" title="4. 寻找两个正序数组的中位数(hard)"></a>4. 寻找两个正序数组的中位数(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">https://leetcode.cn/problems/median-of-two-sorted-arrays/</a></p>
</blockquote>
<p>考虑这样一个问题:</p>
<blockquote>
<p>在两个排序的数组之间, 寻找第k小数.</p>
</blockquote>
<p>如果这个问题能够解决, 那么中位数就是第<code>(n + m) / 2</code>小的数.</p>
<p>假设两个正序数组分别是<svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.697ex" height="1.62ex" role="img" focusable="false" viewbox="0 -716 750 716" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-3-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-3-TEX-I-1D434"/></g></g></g></svg>和<svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.717ex" height="1.545ex" role="img" focusable="false" viewbox="0 -683 759 683" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-4-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D435" xlink:href="#MJX-4-TEX-I-1D435"/></g></g></g></svg>, 考虑<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="4.784ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 2114.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-5-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path id="MJX-5-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-5-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-5-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-5-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-5-TEX-I-1D434"/></g><g data-mml-node="mo" transform="translate(750,0)"><use data-c="5B" xlink:href="#MJX-5-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(1028,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-5-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-5-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1836.4,0)"><use data-c="5D" xlink:href="#MJX-5-TEX-N-5D"/></g></g></g></svg>和<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="4.804ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 2123.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-6-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/><path id="MJX-6-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-6-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-6-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-6-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D435" xlink:href="#MJX-6-TEX-I-1D435"/></g><g data-mml-node="mo" transform="translate(759,0)"><use data-c="5B" xlink:href="#MJX-6-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(1037,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-6-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-6-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1845.4,0)"><use data-c="5D" xlink:href="#MJX-6-TEX-N-5D"/></g></g></g></svg>两个数:</p>
<ul>
<li>如果<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="12.605ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 5571.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-7-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path id="MJX-7-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-7-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-7-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-7-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/><path id="MJX-7-TEX-N-3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/><path id="MJX-7-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-7-TEX-I-1D434"/></g><g data-mml-node="mo" transform="translate(750,0)"><use data-c="5B" xlink:href="#MJX-7-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(1028,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-7-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-7-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1836.4,0)"><use data-c="5D" xlink:href="#MJX-7-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(2392.2,0)"><use data-c="3C" xlink:href="#MJX-7-TEX-N-3C"/></g><g data-mml-node="mi" transform="translate(3448,0)"><use data-c="1D435" xlink:href="#MJX-7-TEX-I-1D435"/></g><g data-mml-node="mo" transform="translate(4207,0)"><use data-c="5B" xlink:href="#MJX-7-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(4485,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-7-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-7-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(5293.4,0)"><use data-c="5D" xlink:href="#MJX-7-TEX-N-5D"/></g></g></g></svg>, 那么<svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="4.42ex" height="2.059ex" role="img" focusable="false" viewbox="0 -716 1953.7 910" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-8-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path id="MJX-8-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-8-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-8-TEX-I-1D434"/></g><g data-mml-node="mo" transform="translate(750,0)"><use data-c="2C" xlink:href="#MJX-8-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(1194.7,0)"><use data-c="1D435" xlink:href="#MJX-8-TEX-I-1D435"/></g></g></g></svg>数组中, 小于等于<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="4.784ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 2114.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-9-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path id="MJX-9-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-9-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-9-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-9-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-9-TEX-I-1D434"/></g><g data-mml-node="mo" transform="translate(750,0)"><use data-c="5B" xlink:href="#MJX-9-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(1028,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-9-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-9-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1836.4,0)"><use data-c="5D" xlink:href="#MJX-9-TEX-N-5D"/></g></g></g></svg>的数的个数就小于<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-10-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-10-TEX-I-1D458"/></g></g></g></svg>, 此时两个数组中第<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-11-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-11-TEX-I-1D458"/></g></g></g></svg>小的数肯定不会在<svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.697ex" height="1.62ex" role="img" focusable="false" viewbox="0 -716 750 716" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-12-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-12-TEX-I-1D434"/></g></g></g></svg>数组第<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="1.829ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 808.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-13-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-13-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-13-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-13-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g></g></g></svg>个元素的左边.</li>
<li>如果<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="12.605ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 5571.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-14-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path id="MJX-14-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-14-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-14-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-14-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/><path id="MJX-14-TEX-N-3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/><path id="MJX-14-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-14-TEX-I-1D434"/></g><g data-mml-node="mo" transform="translate(750,0)"><use data-c="5B" xlink:href="#MJX-14-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(1028,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-14-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-14-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1836.4,0)"><use data-c="5D" xlink:href="#MJX-14-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(2392.2,0)"><use data-c="3E" xlink:href="#MJX-14-TEX-N-3E"/></g><g data-mml-node="mi" transform="translate(3448,0)"><use data-c="1D435" xlink:href="#MJX-14-TEX-I-1D435"/></g><g data-mml-node="mo" transform="translate(4207,0)"><use data-c="5B" xlink:href="#MJX-14-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(4485,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-14-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-14-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(5293.4,0)"><use data-c="5D" xlink:href="#MJX-14-TEX-N-5D"/></g></g></g></svg>, 那么<svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="4.42ex" height="2.059ex" role="img" focusable="false" viewbox="0 -716 1953.7 910" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-15-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path id="MJX-15-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-15-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-15-TEX-I-1D434"/></g><g data-mml-node="mo" transform="translate(750,0)"><use data-c="2C" xlink:href="#MJX-15-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(1194.7,0)"><use data-c="1D435" xlink:href="#MJX-15-TEX-I-1D435"/></g></g></g></svg>数组中, 小于等于<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="4.804ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 2123.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-16-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/><path id="MJX-16-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-16-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-16-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-16-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D435" xlink:href="#MJX-16-TEX-I-1D435"/></g><g data-mml-node="mo" transform="translate(759,0)"><use data-c="5B" xlink:href="#MJX-16-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(1037,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-16-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-16-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1845.4,0)"><use data-c="5D" xlink:href="#MJX-16-TEX-N-5D"/></g></g></g></svg>的数的个数就小于<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-17-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-17-TEX-I-1D458"/></g></g></g></svg>, 此时两个数组中第<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-18-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-18-TEX-I-1D458"/></g></g></g></svg>小的数肯定不会在<svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.717ex" height="1.545ex" role="img" focusable="false" viewbox="0 -683 759 683" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-19-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D435" xlink:href="#MJX-19-TEX-I-1D435"/></g></g></g></svg>数组第<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="1.829ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 808.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-20-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-20-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-20-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-20-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g></g></g></svg>个元素的左边.</li>
<li>如果<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="12.605ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 5571.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-21-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path id="MJX-21-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-21-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-21-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-21-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/><path id="MJX-21-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path id="MJX-21-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-21-TEX-I-1D434"/></g><g data-mml-node="mo" transform="translate(750,0)"><use data-c="5B" xlink:href="#MJX-21-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(1028,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-21-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-21-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1836.4,0)"><use data-c="5D" xlink:href="#MJX-21-TEX-N-5D"/></g><g data-mml-node="mo" transform="translate(2392.2,0)"><use data-c="3D" xlink:href="#MJX-21-TEX-N-3D"/></g><g data-mml-node="mi" transform="translate(3448,0)"><use data-c="1D435" xlink:href="#MJX-21-TEX-I-1D435"/></g><g data-mml-node="mo" transform="translate(4207,0)"><use data-c="5B" xlink:href="#MJX-21-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(4485,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-21-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-21-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(5293.4,0)"><use data-c="5D" xlink:href="#MJX-21-TEX-N-5D"/></g></g></g></svg>, 那么<svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="4.42ex" height="2.059ex" role="img" focusable="false" viewbox="0 -716 1953.7 910" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-22-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path id="MJX-22-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-22-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-22-TEX-I-1D434"/></g><g data-mml-node="mo" transform="translate(750,0)"><use data-c="2C" xlink:href="#MJX-22-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(1194.7,0)"><use data-c="1D435" xlink:href="#MJX-22-TEX-I-1D435"/></g></g></g></svg>数组中, 小于等于<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="4.784ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 2114.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-23-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path id="MJX-23-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-23-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-23-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-23-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-23-TEX-I-1D434"/></g><g data-mml-node="mo" transform="translate(750,0)"><use data-c="5B" xlink:href="#MJX-23-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(1028,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-23-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-23-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1836.4,0)"><use data-c="5D" xlink:href="#MJX-23-TEX-N-5D"/></g></g></g></svg>或<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="4.804ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 2123.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-24-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/><path id="MJX-24-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-24-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-24-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-24-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D435" xlink:href="#MJX-24-TEX-I-1D435"/></g><g data-mml-node="mo" transform="translate(759,0)"><use data-c="5B" xlink:href="#MJX-24-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(1037,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-24-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-24-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1845.4,0)"><use data-c="5D" xlink:href="#MJX-24-TEX-N-5D"/></g></g></g></svg>的数的个数就等于<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-25-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-25-TEX-I-1D458"/></g></g></g></svg>, 此时<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="4.784ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 2114.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-26-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path id="MJX-26-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-26-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-26-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-26-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-26-TEX-I-1D434"/></g><g data-mml-node="mo" transform="translate(750,0)"><use data-c="5B" xlink:href="#MJX-26-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(1028,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-26-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-26-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1836.4,0)"><use data-c="5D" xlink:href="#MJX-26-TEX-N-5D"/></g></g></g></svg>或者<svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="4.804ex" height="2.782ex" role="img" focusable="false" viewbox="0 -884.7 2123.4 1229.7" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-27-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/><path id="MJX-27-TEX-N-5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/><path id="MJX-27-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-27-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-27-TEX-N-5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D435" xlink:href="#MJX-27-TEX-I-1D435"/></g><g data-mml-node="mo" transform="translate(759,0)"><use data-c="5B" xlink:href="#MJX-27-TEX-N-5B"/></g><g data-mml-node="mfrac" transform="translate(1037,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-27-TEX-I-1D458"/></g><g data-mml-node="mn" transform="translate(227.4,-345) scale(0.707)"><use data-c="32" xlink:href="#MJX-27-TEX-N-32"/></g><rect width="568.4" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(1845.4,0)"><use data-c="5D" xlink:href="#MJX-27-TEX-N-5D"/></g></g></g></svg>就是第<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-28-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-28-TEX-I-1D458"/></g></g></g></svg>小的数.</li>
</ul>
<p>根据以上分析, 定义一个函数, 函数的签名为<code>find(A, B, i, j, k)</code>, 表示给定两个数组<svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="4.42ex" height="2.059ex" role="img" focusable="false" viewbox="0 -716 1953.7 910" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-29-TEX-I-1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path id="MJX-29-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-29-TEX-I-1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D434" xlink:href="#MJX-29-TEX-I-1D434"/></g><g data-mml-node="mo" transform="translate(750,0)"><use data-c="2C" xlink:href="#MJX-29-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(1194.7,0)"><use data-c="1D435" xlink:href="#MJX-29-TEX-I-1D435"/></g></g></g></svg>, 下标从<svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="2.719ex" height="1.957ex" role="img" focusable="false" viewbox="0 -661 1201.7 865" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-30-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/><path id="MJX-30-TEX-N-2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/><path id="MJX-30-TEX-I-1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-30-TEX-I-1D456"/></g><g data-mml-node="mo" transform="translate(345,0)"><use data-c="2C" xlink:href="#MJX-30-TEX-N-2C"/></g><g data-mml-node="mi" transform="translate(789.7,0)"><use data-c="1D457" xlink:href="#MJX-30-TEX-I-1D457"/></g></g></g></svg>开始, 找到两个数组中第<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-31-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-31-TEX-I-1D458"/></g></g></g></svg>小的数, 那么就可以用这个函数递归解决.</p>
<p>时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.516ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3322 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-32-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-32-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-32-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/><path id="MJX-32-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/><path id="MJX-32-TEX-I-1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/><path id="MJX-32-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/><path id="MJX-32-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-32-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-32-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D459" xlink:href="#MJX-32-TEX-I-1D459"/></g><g data-mml-node="mi" transform="translate(1450,0)"><use data-c="1D45C" xlink:href="#MJX-32-TEX-I-1D45C"/></g><g data-mml-node="mi" transform="translate(1935,0)"><use data-c="1D454" xlink:href="#MJX-32-TEX-I-1D454"/></g><g data-mml-node="mi" transform="translate(2412,0)"><use data-c="1D458" xlink:href="#MJX-32-TEX-I-1D458"/></g><g data-mml-node="mo" transform="translate(2933,0)"><use data-c="29" xlink:href="#MJX-32-TEX-N-29"/></g></g></g></svg>, 由于<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-33-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D458" xlink:href="#MJX-33-TEX-I-1D458"/></g></g></g></svg>最多是<svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.11ex" height="1.505ex" role="img" focusable="false" viewbox="0 -583 2700.4 665" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-34-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-34-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-34-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45A" xlink:href="#MJX-34-TEX-I-1D45A"/></g><g data-mml-node="mo" transform="translate(1100.2,0)"><use data-c="2B" xlink:href="#MJX-34-TEX-N-2B"/></g><g data-mml-node="mi" transform="translate(2100.4,0)"><use data-c="1D45B" xlink:href="#MJX-34-TEX-I-1D45B"/></g></g></g></svg>, 那么时间复杂度就是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="14.207ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 6279.4 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-35-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-35-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-35-TEX-I-1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/><path id="MJX-35-TEX-I-1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/><path id="MJX-35-TEX-I-1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/><path id="MJX-35-TEX-I-1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path id="MJX-35-TEX-N-2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/><path id="MJX-35-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-35-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-35-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-35-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D459" xlink:href="#MJX-35-TEX-I-1D459"/></g><g data-mml-node="mi" transform="translate(1450,0)"><use data-c="1D45C" xlink:href="#MJX-35-TEX-I-1D45C"/></g><g data-mml-node="mi" transform="translate(1935,0)"><use data-c="1D454" xlink:href="#MJX-35-TEX-I-1D454"/></g><g data-mml-node="mo" transform="translate(2412,0)"><use data-c="28" xlink:href="#MJX-35-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(2801,0)"><use data-c="1D45A" xlink:href="#MJX-35-TEX-I-1D45A"/></g><g data-mml-node="mo" transform="translate(3901.2,0)"><use data-c="2B" xlink:href="#MJX-35-TEX-N-2B"/></g><g data-mml-node="mi" transform="translate(4901.4,0)"><use data-c="1D45B" xlink:href="#MJX-35-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(5501.4,0)"><use data-c="29" xlink:href="#MJX-35-TEX-N-29"/></g><g data-mml-node="mo" transform="translate(5890.4,0)"><use data-c="29" xlink:href="#MJX-35-TEX-N-29"/></g></g></g></svg></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>(), m = nums2.<span class="hljs-built_in">size</span>(), k = (n + m) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> ((n + m) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> left = <span class="hljs-built_in">find</span>(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k);<br>            <span class="hljs-type">int</span> right = <span class="hljs-built_in">find</span>(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> (left + right) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(nums1, nums2, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums1, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums2, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums1.<span class="hljs-built_in">size</span>(), m = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// nums1默认作为较小的数组</span><br>        <span class="hljs-keyword">if</span> (n - i &gt; m - j) <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(nums2, nums1, j, i, k);<br>        <span class="hljs-comment">// 如果nums1为空</span><br>        <span class="hljs-keyword">if</span> (i == nums1.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// 如果k == 1</span><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[i], nums2[j]);<br><br>        <span class="hljs-type">int</span> si = <span class="hljs-built_in">min</span>((<span class="hljs-type">int</span>)(nums1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>), i + k / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> sj = j + (k - k / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (nums1[si] &lt;= nums2[sj]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(nums1, nums2, si + <span class="hljs-number">1</span>, j, k - (si - i + <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(nums1, nums2, i, sj + <span class="hljs-number">1</span>, k - (sj - j + <span class="hljs-number">1</span>));<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="5-最长回文子串-medium"><a href="#5-最长回文子串-medium" class="headerlink" title="5. 最长回文子串(medium)"></a>5. 最长回文子串(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-palindromic-substring/">https://leetcode.cn/problems/longest-palindromic-substring/</a></p>
</blockquote>
<ul>
<li>要枚举一个字符串中的所有回文串:
<ul>
<li>首先, 遍历字符串中所有的字符<code>s[i]</code>.</li>
<li>然后, 回文串可以分为两种, 奇数长度和偶数长度, 奇数长度从<code>i - 1</code>和<code>i + 1</code>进行扩展, 偶数长度从<code>i</code>和<code>i + 1</code>进行扩展.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-type">int</span> l = i - <span class="hljs-number">1</span>, r = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++;<br>            <span class="hljs-keyword">if</span> (r - l - <span class="hljs-number">1</span> &gt; res.<span class="hljs-built_in">size</span>()) res = s.<span class="hljs-built_in">substr</span>(l + <span class="hljs-number">1</span>, r - l - <span class="hljs-number">1</span>);<br><br>            l = i, r = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; r &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++;<br>            <span class="hljs-keyword">if</span> (r - l - <span class="hljs-number">1</span> &gt; res.<span class="hljs-built_in">size</span>()) res = s.<span class="hljs-built_in">substr</span>(l + <span class="hljs-number">1</span>, r - l - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="11-盛水最多的容器-medium"><a href="#11-盛水最多的容器-medium" class="headerlink" title="11. *盛水最多的容器(medium)"></a>11. *盛水最多的容器(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/container-with-most-water/">https://leetcode.cn/problems/container-with-most-water/</a></p>
</blockquote>
<ul>
<li>思路: 假设两根棍子<code>i, j</code>, 它们之间的盛水量就是<code>min(height[i], height[j]) * (j - i)</code>.</li>
<li>最无脑的做法: 枚举所有可能的<code>i, j</code>.</li>
<li>如果我要让盛水量最大, 我应该移动短板, 也就是当<code>height[i] &lt;= height[j]</code>时, 我应该让<code>i++</code>才有机会让水量变大.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; h)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &lt; j; ) &#123;<br>            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">min</span>(h[i], h[j]) * (j - i));<br>            <span class="hljs-keyword">if</span> (h[i] &lt;= h[j]) i ++;<br>            <span class="hljs-keyword">else</span> j --;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="15-三数之和-medium"><a href="#15-三数之和-medium" class="headerlink" title="15. *三数之和(medium)"></a>15. *三数之和(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">https://leetcode.cn/problems/3sum/</a></p>
</blockquote>
<ul>
<li>
<p>首先将数组排序.</p>
</li>
<li>
<p>之后, 从前到后, 枚举数组中的第一个数<code>nums[i]</code>.</p>
<ul>
<li>然后, 从<code>i + 1</code>和<code>nums.size() - 1</code>分别枚举第二个数和第三个数, 然后根据三个数的加和调整指针.</li>
</ul>
</li>
<li>
<p>注意: 数组中可能有重复元素, 需要在枚举每一个指针的过程中去掉重复.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; k) &#123;<br>                <span class="hljs-type">int</span> sum = nums[i] + nums[j] + nums[k];<br>                <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) j ++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) k --;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[k]&#125;);<br>                    <span class="hljs-keyword">do</span> &#123;j ++;&#125; <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]);<br>                    <span class="hljs-keyword">do</span> &#123;k --;&#125; <span class="hljs-keyword">while</span> (j &lt; k &amp;&amp; nums[k] == nums[k + <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="16-最接近的三数之和-medium"><a href="#16-最接近的三数之和-medium" class="headerlink" title="16. 最接近的三数之和(medium)"></a>16. 最接近的三数之和(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum-closest/">https://leetcode.cn/problems/3sum-closest/</a></p>
</blockquote>
<ul>
<li>和三数之和完全一致, 只需要在求和<code>sum</code>的时候维护一个离<code>target</code>最近的<code>sum</code>值即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                LL sum = (LL)nums[i] + nums[l] + nums[r];<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(sum - target) &lt; <span class="hljs-built_in">abs</span>(ans - target)) ans = sum;<br>                <span class="hljs-keyword">if</span> (sum &lt; target) l ++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) r --;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">do</span> &#123;l ++;&#125; <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="hljs-number">1</span>]);<br>                    <span class="hljs-keyword">do</span> &#123;r --;&#125; <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="17-电话号码的字母组合-medium"><a href="#17-电话号码的字母组合-medium" class="headerlink" title="17. *电话号码的字母组合(medium)"></a>17. *电话号码的字母组合(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">https://leetcode.cn/problems/letter-combinations-of-a-phone-number/</a></p>
</blockquote>
<ul>
<li>搜索顺序是: 对于每一个坑位, 枚举这个坑位上能够放置的所有可能性, 放置之后, 就递归到下一个位置, 注意恢复现场.</li>
<li>注意: 如果输入是空字符串的话, 需要在搜索的时候特判一下, 不要把空的<code>path</code>放到<code>ans</code>中.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string path;<br>    vector&lt;string&gt; ans;<br>    string books[<span class="hljs-number">10</span>] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>,<br>        <span class="hljs-string">&quot;ghi&quot;</span>, <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>,<br>        <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span><br>    &#125;;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(digits, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;    <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;digits, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (digits.<span class="hljs-built_in">size</span>() &amp;&amp; u == digits.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: books[digits[u] - <span class="hljs-string">&#x27;0&#x27;</span>]) &#123;<br>            path += c;<br>            <span class="hljs-built_in">dfs</span>(digits, u + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="18-四数之和-medium"><a href="#18-四数之和-medium" class="headerlink" title="18. 四数之和 (medium)"></a>18. 四数之和 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/description/">https://leetcode.cn/problems/4sum/description/</a></p>
</blockquote>
<ul>
<li>和三数之和完全一致的做法, 只不过多了一层循环.</li>
<li>注意: 1. 数组先要排序. 2. <code>sum</code>需要用<code>long long</code>来存储.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fourSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (i &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); j ++) &#123;<br>                <span class="hljs-keyword">if</span> (j != i + <span class="hljs-number">1</span> &amp;&amp; nums[j] == nums[j - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> l = j + <span class="hljs-number">1</span>, r = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                    LL sum = (LL)nums[i] + nums[j] + nums[l] + nums[r];<br>                    <span class="hljs-keyword">if</span> (sum &lt; target) l ++;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; target) r --;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        ans.<span class="hljs-built_in">push_back</span>(&#123;nums[i], nums[j], nums[l], nums[r]&#125;);<br>                        <span class="hljs-keyword">do</span> &#123; l ++; &#125; <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="hljs-number">1</span>]);<br>                        <span class="hljs-keyword">do</span> &#123; r --; &#125; <span class="hljs-keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="hljs-number">1</span>]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="19-删除链表的倒数第n个节点-medium"><a href="#19-删除链表的倒数第n个节点-medium" class="headerlink" title="19. *删除链表的倒数第n个节点(medium)"></a>19. *删除链表的倒数第n个节点(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">https://leetcode.cn/problems/remove-nth-node-from-end-of-list/</a></p>
</blockquote>
<ul>
<li>
<p>由于链表头节点可能被删除, 因此需要虚拟头节点.</p>
</li>
<li>
<p>准备两个快慢指针, 初始放在dummy, 快指针从dummy开始走n步, 之后慢指针和快指针同时走, 快指针走到最后一个节点的时候, 慢指针就会停到倒数第n个节点的前一个节点, 直接删除即可.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>       <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), cur = dummy;<br>       dummy-&gt;next = head;<br>       <span class="hljs-keyword">auto</span> p = dummy;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) p = p-&gt;next;<br>       <span class="hljs-keyword">auto</span> q = dummy;<br>       <span class="hljs-comment">// 注意, 这里要跳到要删除节点的前一个节点</span><br>       <span class="hljs-keyword">while</span> (p-&gt;next) p = p-&gt;next, q = q-&gt;next;<br>       q-&gt;next = q-&gt;next-&gt;next;<br>       <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="20-有效的括号-easy"><a href="#20-有效的括号-easy" class="headerlink" title="20. *有效的括号(easy)"></a>20. *有效的括号(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">https://leetcode.cn/problems/valid-parentheses/</a></p>
</blockquote>
<ul>
<li>遇到左括号就压栈.</li>
<li>如果遇到右括号需要注意几点:
<ul>
<li>第一, 只有栈顶的左括号和有括号成功匹配, 才弹出.</li>
<li>第二, 如果遇到右括号, 但是栈顶没有元素, 直接不匹配, 例如<code>]</code>.</li>
<li>第三, 如果遇到右括号, 但是栈顶不匹配, 那么直接就不匹配, 例如<code>(]</code>.</li>
<li>第二和第三需要特殊判断.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>       stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span> || c == <span class="hljs-string">&#x27;&#123;&#x27;</span> || c == <span class="hljs-string">&#x27;[&#x27;</span>) stk.<span class="hljs-built_in">push</span>(c);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span>) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;&#123;&#x27;</span>) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; stk.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;[&#x27;</span>) stk.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="21-合并两个有序的链表-easy"><a href="#21-合并两个有序的链表-easy" class="headerlink" title="21. *合并两个有序的链表 (easy)"></a>21. *合并两个有序的链表 (easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p>
</blockquote>
<ul>
<li>和归并排序合并区间的过程一样.</li>
<li>首先需要枚举两个链表指针都存在的情况, 也就是<code>l1 &amp;&amp; l2</code>.</li>
<li>之后再枚举某一个链表没走完的情况, 也就是<code>while (l1) while (l2)</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), cur = dummy;<br>        <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(l1-&gt;val), l1 = l1-&gt;next;<br>            <span class="hljs-keyword">else</span> cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(l2-&gt;val), l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (l1) cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(l1-&gt;val), l1 = l1-&gt;next;<br>        <span class="hljs-keyword">while</span> (l2) cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(l2-&gt;val), l2 = l2-&gt;next;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="22-括号生成-medium"><a href="#22-括号生成-medium" class="headerlink" title="22. *括号生成(medium)"></a>22. *括号生成(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/generate-parentheses/description/">https://leetcode.cn/problems/generate-parentheses/description/</a></p>
</blockquote>
<ul>
<li>
<p>一个括号序列是合法的充要条件是:</p>
<ul>
<li>序列中, 左右括号数量相等.</li>
<li>任意前缀, 左括号数量大于等于有括号数量.</li>
</ul>
</li>
<li>
<p>给定了n对括号, 那么就有2n个坑位可以放置<code>(</code>和<code>)</code>, 那么搜索的顺序就是这样:</p>
</li>
<li>
<p>只要之前左括号数量小于<code>n</code>, 那么当前位置就可以放左括号.</p>
<ul>
<li>只要左括号数量大于右括号数量, 那么当前位置就可以放右括号.</li>
<li>总而言之</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    string path;<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> _n)</span> </span>&#123;<br>        n = _n;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> lc, <span class="hljs-type">int</span> rc)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lc == n &amp;&amp; rc == n) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lc &lt; n) &#123;<br>            path += <span class="hljs-string">&#x27;(&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(lc + <span class="hljs-number">1</span>, rc);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rc &lt; n &amp;&amp; lc &gt; rc) &#123;<br>            path += <span class="hljs-string">&#x27;)&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(lc, rc + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="23-合并K个升序链表-hard"><a href="#23-合并K个升序链表-hard" class="headerlink" title="23. *合并K个升序链表(hard)"></a>23. *合并K个升序链表(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-k-sorted-lists/">https://leetcode.cn/problems/merge-k-sorted-lists/</a></p>
</blockquote>
<ul>
<li>链表的k路归并问题, 可以采用堆排序解决.
<ul>
<li>将每一个链表头节点插入堆.</li>
<li>然后从堆中找到最小元素.</li>
<li>之后再将最小元素的下一个头节点插入堆.</li>
</ul>
</li>
<li>注意: 一开始将链表头节点插入堆时, 链表头可能为空, 需要注意判断.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span> <span class="hljs-params">(ListNode *a, ListNode *b)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> a-&gt;val &gt; b-&gt;val;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">auto</span> cur = dummy;<br>        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; heap;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> l: lists)<br>            <span class="hljs-keyword">if</span> (l) heap.<span class="hljs-built_in">push</span>(l);<br>            <br>        <span class="hljs-keyword">while</span> (heap.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>(); heap.<span class="hljs-built_in">pop</span>();<br>            cur = cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(t-&gt;val);<br>            <span class="hljs-keyword">if</span> (t-&gt;next) heap.<span class="hljs-built_in">push</span>(t-&gt;next);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="24-两两交换链表中的节点-medium"><a href="#24-两两交换链表中的节点-medium" class="headerlink" title="24. *两两交换链表中的节点(medium)"></a>24. *两两交换链表中的节点(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">https://leetcode.cn/problems/swap-nodes-in-pairs/</a></p>
</blockquote>
<ul>
<li>首先, 链表头节点可能没有, 所以需要虚拟头节点.</li>
<li>其次, 如果要两两交换链表中的节点, 需要在链表中, 把每两个节点看作一个整体, 假设这个整体的第一个节点是<code>r</code>, 最后一个节点是<code>q</code>.
<ul>
<li><code>r</code>的前一个节点是<code>p</code>.</li>
<li>那么首先需要调整整体的指针, <code>p-&gt;next = q, r-&gt;next = q-&gt;next</code>.</li>
<li>然后再调整整体内部的指针: <code>q-&gt;next = r</code>.</li>
<li>然后更新<code>p</code>, 指向下一个整体的前一个节点: <code>p = r</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>       <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>       dummy-&gt;next = head;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next; ) &#123;<br>            <span class="hljs-keyword">auto</span> q = p;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> &amp;&amp; q; i ++) q = q-&gt;next;<br>            <span class="hljs-keyword">auto</span> u = p-&gt;next;<br>            <span class="hljs-keyword">auto</span> a = p-&gt;next, b = p-&gt;next-&gt;next;<br>            p-&gt;next = q;<br>            a-&gt;next = q-&gt;next;<br>            <span class="hljs-keyword">while</span> (a != q) &#123;<br>                <span class="hljs-keyword">auto</span> c = b-&gt;next;<br>                b-&gt;next = a;<br>                a = b, b = c;<br>            &#125;<br>            p = u;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="25-K个一组翻转链表-hard"><a href="#25-K个一组翻转链表-hard" class="headerlink" title="25. *K个一组翻转链表(hard)"></a>25. *K个一组翻转链表(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">https://leetcode.cn/problems/reverse-nodes-in-k-group/</a></p>
</blockquote>
<ul>
<li>首先, 头节点会被改变, 因此要加上虚拟头节点.</li>
<li>其次, 先找到这k个节点组成的一个集团, 以及这个集团的前一个节点<code>p</code>, 和最后的节点<code>q</code>.</li>
<li>之后, 先动边界节点, 然后修改集团内部的节点.</li>
<li>最后, 注意指针<code>p</code>的移动.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        dummy-&gt;next = head;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;) &#123;<br>            <span class="hljs-keyword">auto</span> q = p;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k &amp;&amp; q; i ++) q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (!q) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">auto</span> u = p-&gt;next;<br>            <span class="hljs-keyword">auto</span> a = p-&gt;next, b = p-&gt;next-&gt;next;<br>            p-&gt;next = q;<br>            a-&gt;next = q-&gt;next;<br>            <span class="hljs-keyword">while</span> (a != q) &#123;<br>                <span class="hljs-keyword">auto</span> c = b-&gt;next;<br>                b-&gt;next = a;<br>                a = b, b = c;<br>            &#125;<br>            p = u;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="31-下一个排列-medium"><a href="#31-下一个排列-medium" class="headerlink" title="31. *下一个排列 (medium)"></a>31. *下一个排列 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/next-permutation/">https://leetcode.cn/problems/next-permutation/</a></p>
</blockquote>
<ul>
<li>从后向前遍历, 找到第一个逆序点<code>k</code>, 也就是<code>nums[k - 1] &lt; nums[k]</code>.
<ul>
<li><code>[k, nums.size() - 1]</code>这一段是反向升序的.</li>
<li>那么在<code>[k, nums.size() - 1]</code>这一段, 找到最小的, 但是大于<code>nums[k - 1]</code>的数, 交换到<code>nums[k - 1]</code>的位置上.</li>
<li>然后将<code>[k, nums.size() - 1]</code>这一段逆序 (也就是变成升序).</li>
</ul>
</li>
<li>直觉上讲, 这种操作相当于让序列的第一个转折点变大, 那么字典序就是变大, 让后面的序列变成正序, 后面的字典序最小, 也就是下一个字典序的位置.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; nums[k - <span class="hljs-number">1</span>] &gt;= nums[k]) k --;<br>        <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> t = k;<br>            <span class="hljs-keyword">while</span> (t &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; nums[t] &gt; nums[k - <span class="hljs-number">1</span>]) t ++;<br>            <span class="hljs-built_in">swap</span>(nums[k - <span class="hljs-number">1</span>], nums[t - <span class="hljs-number">1</span>]);<br>            <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + k, nums.<span class="hljs-built_in">end</span>());<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="34-在排序数组中查找元素的第一个和最后一个位置-medium"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-medium" class="headerlink" title="34. *在排序数组中查找元素的第一个和最后一个位置(medium)"></a>34. *在排序数组中查找元素的第一个和最后一个位置(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
</blockquote>
<ul>
<li>
<p>整数二分的问题, 能够通过一个数组中的元素是否满足某个性质, 把数组分成两个部分.</p>
</li>
<li>
<p>这两个部分有两个边界:</p>
<ul>
<li>
<p>如果要求左边界: <code>int mid = l + (r - l) / 2 + 1</code></p>
<ul>
<li>满足左侧性质: <code>l = mid</code></li>
<li>满足右侧性质: <code>r = mid - 1</code></li>
</ul>
</li>
<li>
<p>如果要求右边界: <code>int mid = l + (r - l) / 2</code></p>
<ul>
<li>满足左侧性质: <code>l = mid + 1</code></li>
<li>满足右侧性质: <code>r = mid</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>注意实现时需要特判数组是空的情况.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[l] != target) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> left = l;<br>        l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt;= target) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[l] != target) <span class="hljs-keyword">return</span> &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> right = l;<br>        <span class="hljs-keyword">return</span> &#123;left, right&#125;;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="35-搜索插入位置-easy"><a href="#35-搜索插入位置-easy" class="headerlink" title="35. *搜索插入位置(easy)"></a>35. *搜索插入位置(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/">https://leetcode.cn/problems/search-insert-position/</a></p>
</blockquote>
<ul>
<li>假设二分的性质是: <code>nums[i] &lt; x</code>, 和<code>nums[i] &gt;= x</code>, 那么插入的位置就是右边界.</li>
<li>注意: 如果插入的位置是数组的末尾, 那么答案应该是<code>n</code>, 但是二分不会得到这个答案, 需要特判.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (nums[n - <span class="hljs-number">1</span>] &lt; target) <span class="hljs-keyword">return</span> n;<br>        <br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125; <br>        <span class="hljs-keyword">return</span> l;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="38-外观数列-medium"><a href="#38-外观数列-medium" class="headerlink" title="38. 外观数列(medium)"></a>38. 外观数列(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-and-say/description/">https://leetcode.cn/problems/count-and-say/description/</a></p>
</blockquote>
<ul>
<li>本质上, 这个题就是在统计字符串中, 每一个连续相同字符的序列的长度, 直接用双指针统计即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">countAndSay</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        string s = <span class="hljs-built_in">countAndSay</span>(n - <span class="hljs-number">1</span>);<br><br>        string res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[j] == s[i]) j ++;<br>            <span class="hljs-type">int</span> cnt = j - i;<br>            res += cnt + <span class="hljs-string">&#x27;0&#x27;</span>;<br>            res += s[i];<br>            i = j - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="39-组合总和-medium"><a href="#39-组合总和-medium" class="headerlink" title="39. *组合总和(medium)"></a>39. *组合总和(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/combination-sum/">https://leetcode.cn/problems/combination-sum/</a></p>
</blockquote>
<ul>
<li>搜索的顺序是: 对于<code>candidates</code>数组中的每一个数, 枚举这个数被选择的次数.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">dfs</span>(candidates, target, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == nums.<span class="hljs-built_in">size</span>() || sum == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>)<br>                ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; nums[u] * i &lt;= sum; i ++) &#123;<br>            <span class="hljs-built_in">dfs</span>(nums, sum - nums[u] * i, u + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">push_back</span>(nums[u]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; nums[u] * i &lt;= sum; i ++)<br>            path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="41-缺失的第一个正数-medium"><a href="#41-缺失的第一个正数-medium" class="headerlink" title="41. *缺失的第一个正数(medium)"></a>41. *缺失的第一个正数(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/first-missing-positive/">https://leetcode.cn/problems/first-missing-positive/</a></p>
</blockquote>
<ul>
<li>
<p>如果让数组中所有的正整数元素满足<code>nums[i] == i</code>, 那么从前到后遍历正整数, 第一个不满足<code>nums[i] != i</code>的就是缺失的第一个整数.</p>
<ul>
<li>如果所有的正整数都满足, 那么缺失的第一个正整数就是<code>n + 1</code>.</li>
</ul>
</li>
<li>
<p>对于这段代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (nums[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; n &amp;&amp; nums[i] != nums[nums[i]])<br>	<span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]]);<br></code></pre></td></tr></table></figure>
<ul>
<li>每一次交换, 就相当于把<code>nums[i]</code>这个值, 放到了以<code>nums[i]</code>为下标的位置, 每一次都可以排好一个值.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span> (nums[i] != INT_MIN) nums[i] --;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">while</span> (nums[i] &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &lt; n &amp;&amp; nums[nums[i]] != nums[i])<br>                <span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]]);<br>                <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span> (nums[i] != i)<br>                <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="42-接雨水-hard"><a href="#42-接雨水-hard" class="headerlink" title="42. *接雨水(hard)"></a>42. *接雨水(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trapping-rain-water/">https://leetcode.cn/problems/trapping-rain-water/</a></p>
</blockquote>
<ul>
<li>一个格子<code>h[i]</code>对整体雨水的贡献量是: <code>min(l[i], r[i]) - h[i]</code>.
<ul>
<li><code>l[i], r[i]</code>分别表示格子<code>i</code>左右两侧(包括<code>h[i]</code>), 的最大的格子高度.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; h)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = h.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(n)</span>, <span class="hljs-title">r</span><span class="hljs-params">(n)</span></span>;<br>        <br>        <span class="hljs-type">int</span> maxv = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            maxv = <span class="hljs-built_in">max</span>(maxv, h[i]);<br>            l[i] = maxv;<br>        &#125;<br>        maxv = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            maxv = <span class="hljs-built_in">max</span>(maxv, h[i]);<br>            r[i] = maxv;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            res += <span class="hljs-built_in">min</span>(l[i], r[i]) - h[i];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="45-跳跃游戏II-medium"><a href="#45-跳跃游戏II-medium" class="headerlink" title="45. *跳跃游戏II(medium)"></a>45. *跳跃游戏II(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game-ii/">https://leetcode.cn/problems/jump-game-ii/</a></p>
</blockquote>
<ul>
<li>假设<code>f[i]</code>表示到达位置<code>i</code>所需要的最小跳跃次数.</li>
<li>那么<code>f[i] = f[j] + 1</code>, 其中<code>j</code>是最小的, 能够一步跳到<code>i</code>的位置.</li>
<li><code>i, j</code>的维护逻辑类似于双指针算法.</li>
<li>注意, 这里<code>i</code>要从1开始, 因为<code>f[0] = 0</code>是一种特殊情况, 不能参与到循环中, 一旦进入循环就会被更新.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; j + nums[j] &lt; i) j ++;<br>            f[i] = f[j] + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="46-全排列-medium"><a href="#46-全排列-medium" class="headerlink" title="46. *全排列(medium)"></a>46. *全排列(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/permutations/">https://leetcode.cn/problems/permutations/</a></p>
</blockquote>
<ul>
<li>本题是无重复元素的数组求全排列.</li>
<li>搜索顺序是: 对于每一个全排列上的坑位, 枚举这个坑位填哪一个数, 如果一个数被填了就需要记录, 防止重复填.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">bool</span>&gt; st;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        st.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>()); path.<span class="hljs-built_in">resize</span>(nums.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (st[i]) <span class="hljs-keyword">continue</span>;<br>            path[u] = nums[i]; st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-built_in">dfs</span>(nums, u + <span class="hljs-number">1</span>);<br>            st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="48-旋转图像-medium"><a href="#48-旋转图像-medium" class="headerlink" title="48. *旋转图像(medium)"></a>48. *旋转图像(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-image/">https://leetcode.cn/problems/rotate-image/</a></p>
</blockquote>
<ul>
<li>顺时针90度: 主对角线对称(左上-右下), 竖直轴线对称.</li>
<li>逆时针90度: 主对角线对称(左上-右下), 水平轴线对称.</li>
<li>顺时针/逆时针180度: 主对角线对称 + 副对角线对称.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>       <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j ++)<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[j][i]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, k = m - <span class="hljs-number">1</span>; j &lt; k; j ++, k --)<br>                <span class="hljs-built_in">swap</span>(matrix[i][j], matrix[i][k]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="49-字母异位词分组-medium"><a href="#49-字母异位词分组-medium" class="headerlink" title="49. *字母异位词分组(medium)"></a>49. *字母异位词分组(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/group-anagrams/">https://leetcode.cn/problems/group-anagrams/</a></p>
</blockquote>
<ul>
<li>这个题的题意是: 给定一个字符串的数组, 如果将这个数组中的元素分为若干个group, 每一个group中的所有字符串经过排序后都能得到同样的结果.</li>
<li>那么直接用哈希表, key作为排序后的结果, value就是所有符合题意的字符串即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;str: strs) &#123;<br>            <span class="hljs-keyword">auto</span> nstr = str;<br>            <span class="hljs-built_in">sort</span>(nstr.<span class="hljs-built_in">begin</span>(), nstr.<span class="hljs-built_in">end</span>());<br>            hash[nstr].<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br>        vector&lt;vector&lt;string&gt;&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [_, s]: hash) ans.<span class="hljs-built_in">push_back</span>(s);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="51-N皇后-hard"><a href="#51-N皇后-hard" class="headerlink" title="51. *N皇后 (hard)"></a>51. *N皇后 (hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/n-queens/">https://leetcode.cn/problems/n-queens/</a></p>
</blockquote>
<ul>
<li>用<code>col</code>, <code>dg</code>, <code>udg</code>分别记录每一列, 对角线/反对角线上是否有<code>Q</code>.</li>
<li>遍历时先遍历每一行<code>u</code>, 然后遍历每一列<code>i</code>, 如果一个位置<code>(u, i)</code>在列, 对角线, 反对角线上都没有棋子, 那么就可以放下棋子, 然后递归到下一个位置.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; col, dg, udg;<br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-type">int</span> _n) &#123;<br>        n = _n;<br>        col = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        dg = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        udg = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>);<br>        path = <span class="hljs-built_in">vector</span>&lt;string&gt;(n, <span class="hljs-built_in">string</span>(n, <span class="hljs-string">&#x27;.&#x27;</span>));<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == n) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (col[i] || dg[u + i] || udg[n + i - u]) <span class="hljs-keyword">continue</span>;<br>            col[i] = dg[u + i] = udg[n + i - u] = <span class="hljs-literal">true</span>;<br>            path[u][i] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>            <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>);<br>            path[u][i] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>            col[i] = dg[u + i] = udg[n + i - u] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="53-最大子数组和-medium"><a href="#53-最大子数组和-medium" class="headerlink" title="53. *最大子数组和(medium)"></a>53. *最大子数组和(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p>
</blockquote>
<ul>
<li>假设<code>f[i]</code>表示以<code>i</code>结尾的所有子数组中, 和的最大值.</li>
<li>那么状态转移就是: <code>f[i] = max(nums[i], f[i - 1] + nums[i])</code>.</li>
<li>最后的答案就是求所有<code>f[i]</code>的最大值.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> f = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            f = <span class="hljs-built_in">max</span>(f + nums[i], nums[i]);<br>            ans = <span class="hljs-built_in">max</span>(ans, f);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="54-螺旋矩阵-medium"><a href="#54-螺旋矩阵-medium" class="headerlink" title="54. *螺旋矩阵(medium)"></a>54. *螺旋矩阵(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix/">https://leetcode.cn/problems/spiral-matrix/</a></p>
</blockquote>
<ul>
<li>遍历时, 一旦遇到下标越界/边界已经搜索过的情况, 就把<code>dx, dy</code>数组的方向改变一下即可.</li>
<li>注意: x的正方向是下, y的正方向是右.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">st</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(m, <span class="hljs-literal">false</span>));<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n * m; k ++) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(matrix[x][y]);<br>            st[x][y] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> a = x + dx[d], b = y + dy[d];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m || st[a][b])<br>                d = (d + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span>;<br>            x += dx[d], y += dy[d];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="55-跳跃游戏-medium"><a href="#55-跳跃游戏-medium" class="headerlink" title="55. *跳跃游戏(medium)"></a>55. *跳跃游戏(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/jump-game/">https://leetcode.cn/problems/jump-game/</a></p>
</blockquote>
<ul>
<li>对于数组中的每一个数<code>nums[i]</code>, 它能够跳到的最大的位置就是<code>i + nums[i]</code>.</li>
<li>那么, 当遍历到<code>i</code>时, 如果之前能够跳到的最大位置<code>j &lt; i</code>, 那么就无法到达这个位置, 因此, 就无法到达终点.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canJump</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> f = <span class="hljs-number">0</span> + nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (f &lt; i) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            f = <span class="hljs-built_in">max</span>(f, i + nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="56-合并区间-medium"><a href="#56-合并区间-medium" class="headerlink" title="56. *合并区间(medium)"></a>56. *合并区间(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-intervals/">https://leetcode.cn/problems/merge-intervals/</a></p>
</blockquote>
<ul>
<li>
<p>首先, 区间按照左端点排序.</p>
</li>
<li>
<p>然后, 用<code>[st, ed]</code>维护当前右端点最大的区间, 然后依次枚举当前区间<code>[l, r]</code>:</p>
<ul>
<li>如果<code>l &lt;= ed</code>, 有交集, 那么直接更新<code>ed = max(ed, r)</code>.</li>
<li>如果<code>l &gt; ed</code>, 没交集, 那么需要先把<code>[st, ed]</code>放在答案中, 然后更新区间<code>st = l, ed = r</code>.</li>
</ul>
</li>
<li>
<p>注意: 枚举完之后, 最后一个区间<code>[st, ed]</code>也要放到答案中.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        <span class="hljs-built_in">sort</span>(intervals.<span class="hljs-built_in">begin</span>(), intervals.<span class="hljs-built_in">end</span>());<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> st = <span class="hljs-number">-1</span>, ed = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;range: intervals) &#123;<br>            <span class="hljs-type">int</span> l = range[<span class="hljs-number">0</span>], r = range[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (l &lt;= ed)<br>                ed = <span class="hljs-built_in">max</span>(ed, r);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (ed != <span class="hljs-number">-1</span>) ans.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>                st = l, ed = r;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ed != <span class="hljs-number">-1</span>) ans.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="62-不同路径-medium"><a href="#62-不同路径-medium" class="headerlink" title="62. *不同路径(medium)"></a>62. *不同路径(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-paths/">https://leetcode.cn/problems/unique-paths/</a></p>
</blockquote>
<ul>
<li>设<code>f[i][j]</code>表示从起点走到<code>(i, j)</code>的路径数量.</li>
<li>首先初始化起点, 路径数量是1: <code>f[0][0] = 1</code>.</li>
<li>之后更新状态: <code>f[i][j] += f[i - 1][j]</code>, 以及<code>f[i][j] += f[i][j - 1]</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (!i &amp;&amp; !j) f[i][j] = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (i) f[i][j] += f[i - <span class="hljs-number">1</span>][j];<br>                    <span class="hljs-keyword">if</span> (j) f[i][j] += f[i][j - <span class="hljs-number">1</span>];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[m - <span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="64-最小路径和-medium"><a href="#64-最小路径和-medium" class="headerlink" title="64. *最小路径和(medium)"></a>64. *最小路径和(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-path-sum/">https://leetcode.cn/problems/minimum-path-sum/</a></p>
</blockquote>
<ul>
<li>设<code>f[i][j]</code>表示从起点走到<code>(i, j)</code>的最小路径和.</li>
<li>首先初始化所有位置的<code>f[i][j]</code>为<code>INF</code>, 然后将起点<code>f[0][0] = grid[0][0];</code></li>
<li>之后更新状态: <code>f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j];</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">0x3f3f3f3f</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++) &#123;<br>                <span class="hljs-keyword">if</span> (!i &amp;&amp; !j) f[i][j] = grid[i][j];<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (i) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j] + grid[i][j]);<br>                    <span class="hljs-keyword">if</span> (j) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i][j - <span class="hljs-number">1</span>] + grid[i][j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="70-爬楼梯-easy"><a href="#70-爬楼梯-easy" class="headerlink" title="70. *爬楼梯 (easy)"></a>70. *爬楼梯 (easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p>
</blockquote>
<ul>
<li>斐波那契数列的第0项是1, 第1项也是1.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>        LL a = <span class="hljs-number">1</span>, b = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (n --) &#123;<br>            LL c = a + b;<br>            a = b, b = c;<br>        &#125;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="72-编辑距离-medium"><a href="#72-编辑距离-medium" class="headerlink" title="72. *编辑距离(medium)"></a>72. *编辑距离(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/edit-distance/description/">https://leetcode.cn/problems/edit-distance/description/</a></p>
</blockquote>
<ul>
<li>假设<code>f[i][j]</code>表示从<code>word1[1:i]</code>转换为<code>word2[1:j]</code>的最小编辑次数, 针对<code>word1[i]</code>的操作, 状态转移分为三种情况:
<ul>
<li>增加<code>word1[i]</code>: 那么就要求<code>word[1:i]</code>和<code>word2[1:j-1]</code>匹配.</li>
<li>删除<code>word1[i]</code>: 要求<code>word[1:i-1]</code>和<code>word2[1:j]</code>匹配</li>
<li>替换<code>word1[i]</code>: 要求<code>word[1:i-1]</code>和<code>word2[1:j-1]</code>匹配, 并且<code>word1[i] == word2[j]</code>.
<ul>
<li>如果<code>word1[i] == word2[j]</code>, 那么就可以直接从<code>f[i - 1][j - 1]</code>转移.</li>
</ul>
</li>
</ul>
</li>
<li>注意初始化<code>f[i][0]</code>和<code>f[0][i]</code>为<code>i</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(string word1, string word2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = word1.<span class="hljs-built_in">size</span>(), m = word2.<span class="hljs-built_in">size</span>();<br>        word1 = <span class="hljs-string">&#x27; &#x27;</span> + word1;<br>        word2 = <span class="hljs-string">&#x27; &#x27;</span> + word2;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) f[i][<span class="hljs-number">0</span>] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i ++) f[<span class="hljs-number">0</span>][i] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++) &#123;<br>                f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, f[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (word1[i] == word2[j])<br>                    f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">else</span><br>                    f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            &#125;<br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="73-矩阵置零-medium"><a href="#73-矩阵置零-medium" class="headerlink" title="73. *矩阵置零(medium)"></a>73. *矩阵置零(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/set-matrix-zeroes/">https://leetcode.cn/problems/set-matrix-zeroes/</a></p>
</blockquote>
<ul>
<li>原地算法:
<ul>
<li>首先记录一下第0行和第0列是否需要清0.</li>
<li>然后从第1行/第1列开始对矩阵进行判断, 如果第i行包含0元素, 就在<code>matrix[i][0]</code>处标记为0.
<ul>
<li>原来的<code>matrix[i][0]</code>可能是0, 也可能不是0, 这个时候如果标记为0, 那么原来的值就不知道, 那么后面就无法判断第0行和第0列是否需要清0, 所以需要预先处理一下第0行和第0列.</li>
</ul>
</li>
<li>然后根据标记的<code>matrix[i][0]</code>和<code>matrix[0][i]</code>进行清理.</li>
<li>之后清理第0行和第0列.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> row = <span class="hljs-literal">false</span>, col = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span> (!matrix[i][<span class="hljs-number">0</span>])<br>                col = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>            <span class="hljs-keyword">if</span> (!matrix[<span class="hljs-number">0</span>][i])<br>                row = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (!matrix[i][j]) &#123;<br>                    matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>                    matrix[<span class="hljs-number">0</span>][j] = <span class="hljs-number">0</span>;<br>                &#125;<br>        <span class="hljs-comment">// 注意这里要从1开始遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span> (!matrix[i][<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; j ++)<br>                    matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i ++)<br>            <span class="hljs-keyword">if</span> (!matrix[<span class="hljs-number">0</span>][i]) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n; j ++)<br>                    matrix[j][i] = <span class="hljs-number">0</span>;<br>            &#125;<br>        <span class="hljs-keyword">if</span> (row) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++)<br>                matrix[<span class="hljs-number">0</span>][i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (col) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>                matrix[i][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="74-搜索二维矩阵-medium"><a href="#74-搜索二维矩阵-medium" class="headerlink" title="74. *搜索二维矩阵(medium)"></a>74. *搜索二维矩阵(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix/">https://leetcode.cn/problems/search-a-2d-matrix/</a></p>
</blockquote>
<ul>
<li>二维矩阵和一维数组没有什么区别, 一位数组的下标<code>idx</code>分别除以/模矩阵列数就是在矩阵中的坐标<code>(idx / m, idx % m)</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n * m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (matrix[mid / m][mid % m] &lt; target) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> matrix[l / m][l % m] == target;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="75-颜色分类-medium"><a href="#75-颜色分类-medium" class="headerlink" title="75. *颜色分类(medium)"></a>75. *颜色分类(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-colors/">https://leetcode.cn/problems/sort-colors/</a></p>
</blockquote>
<ul>
<li>
<p>核心思想是扫描数组的时候, 维护三个区域, 一个区域全是0, 一个区域全是1, 另一个区域全是2.</p>
</li>
<li>
<p>维护三个指针<code>i, j, k</code>, <code>j</code>扫描数组:</p>
<ul>
<li>如果<code>nums[j] == 0</code>, 那么<code>0</code>就放置到<code>i</code>处, 然后让<code>i</code>指针移动.</li>
<li>如果<code>nums[j] == 1</code>, 那么直接<code>j ++</code>.</li>
<li>如果<code>nums[j] == 2</code>, 那么直接交换到<code>k</code>指针处, 然后<code>k --</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>, k = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &lt;= k) &#123;<br>            <span class="hljs-keyword">if</span> (nums[j] == <span class="hljs-number">0</span>) <span class="hljs-built_in">swap</span>(nums[i ++], nums[j ++]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[j] == <span class="hljs-number">1</span>) j ++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[j] == <span class="hljs-number">2</span>) <span class="hljs-built_in">swap</span>(nums[j], nums[k --]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="76-最小覆盖子串-hard"><a href="#76-最小覆盖子串-hard" class="headerlink" title="76. *最小覆盖子串(hard)"></a>76. *最小覆盖子串(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-window-substring/">https://leetcode.cn/problems/minimum-window-substring/</a></p>
</blockquote>
<ul>
<li>思路: 当指针<code>i</code>向前移动时, 向后移动指针<code>j</code>, 直到子串完全覆盖<code>t</code>中的所有字符.</li>
<li>然后向左移动指针, 找到长度最小的, 也可以完全覆盖<code>t</code>中字符的最小子串.
<ul>
<li><code>hash[s[i]]</code>表示<code>t</code>中字符在<code>s</code>中出现的次数, 如果<code>hash[s[j]] + 1 &gt; 0</code>, 那么表示如果<code>j</code>再向前移动, 就无法覆盖<code>t</code>中所有字符了.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: t) hash[c] ++;<br>        <span class="hljs-type">int</span> tot = hash.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, len = n;<br>        string ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(s[i]) &amp;&amp; --hash[s[i]] == <span class="hljs-number">0</span>) k ++;<br>            <span class="hljs-keyword">if</span> (k == tot) &#123;<br>                <span class="hljs-keyword">while</span> (j &lt; i) &#123;<br>                    <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(s[j]) &amp;&amp; hash[s[j]] + <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(s[j])) hash[s[j]] ++;<br>                    j ++;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (i - j + <span class="hljs-number">1</span> &lt;= len) &#123;<br>                    len = i - j + <span class="hljs-number">1</span>;<br>                    ans = s.<span class="hljs-built_in">substr</span>(j, i - j + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="78-子集-medium"><a href="#78-子集-medium" class="headerlink" title="78. *子集(medium)"></a>78. *子集(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subsets/">https://leetcode.cn/problems/subsets/</a></p>
</blockquote>
<ul>
<li>递归写法:
<ul>
<li>枚举数组中的每个数选/不选即可.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == nums.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(nums, u + <span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">push_back</span>(nums[u]);<br>        <span class="hljs-built_in">dfs</span>(nums, u + <span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>迭代写法: 用二进制枚举子集</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; path;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>                <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>)<br>                    path.<span class="hljs-built_in">push_back</span>(nums[j]);<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="79-单词搜索-medium"><a href="#79-单词搜索-medium" class="headerlink" title="79. *单词搜索(medium)"></a>79. *单词搜索(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-search/">https://leetcode.cn/problems/word-search/</a></p>
</blockquote>
<ul>
<li>遍历网格中的每一个格子, 从每一个格子开始进行搜索.
<ul>
<li>对于每一个格子, 如果它与当前单词字符相等, 就把格子设置为<code>.</code> (标记为已搜索过). 然后扩展到其他合法格子.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">exist</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;<br>       <span class="hljs-type">int</span> n = board.<span class="hljs-built_in">size</span>(), m = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, <span class="hljs-number">0</span>, i, j))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board, string word, <span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (board[x][y] != word[u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (u == word.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">char</span> t = board[x][y];<br>        board[x][y] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>        <span class="hljs-type">int</span> n = board.<span class="hljs-built_in">size</span>(), m = board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m || board[a][b] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(board, word, u + <span class="hljs-number">1</span>, a, b)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        board[x][y] = t;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="84-柱状图中最大的矩形-hard"><a href="#84-柱状图中最大的矩形-hard" class="headerlink" title="84. *柱状图中最大的矩形(hard)"></a>84. *柱状图中最大的矩形(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">https://leetcode.cn/problems/largest-rectangle-in-histogram/</a></p>
</blockquote>
<ul>
<li>对于每个柱子<code>h[i]</code>, 找到它左边, 右边第一个比它小的位置下标<code>l, r</code>.</li>
<li>那么这个矩形的面积就是<code>(r - l + 1) * h[i]</code>, 枚举这个值就可以.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; h)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; left, right;<br><br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>() &amp;&amp; h[i] &lt;= h[stk.<span class="hljs-built_in">top</span>()]) stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) left.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">else</span> left.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>() + <span class="hljs-number">1</span>);<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        stk = <span class="hljs-built_in">stack</span>&lt;<span class="hljs-type">int</span>&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>() &amp;&amp; h[i] &lt;= h[stk.<span class="hljs-built_in">top</span>()]) stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>()) right.<span class="hljs-built_in">push_back</span>(h.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> right.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>() - <span class="hljs-number">1</span>);<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(right.<span class="hljs-built_in">begin</span>(), right.<span class="hljs-built_in">end</span>());<br>        <br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; h.<span class="hljs-built_in">size</span>(); i ++)<br>            ans = <span class="hljs-built_in">max</span>(ans, h[i] * (right[i] - left[i] + <span class="hljs-number">1</span>));<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="92-反转链表-II-medium"><a href="#92-反转链表-II-medium" class="headerlink" title="92. 反转链表 II (medium)"></a>92. 反转链表 II (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list-ii/">https://leetcode.cn/problems/reverse-linked-list-ii/</a></p>
</blockquote>
<ul>
<li>首先, 找到第<code>left-1</code>个节点, 和<code>right</code>节点, 操作<code>[left, right]</code>这一组节点边界的指针.</li>
<li>之后, 按照反转链表迭代的写法, 反转<code>[left, right]</code>内部的节点.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>); dummy-&gt;next = head;<br>        <span class="hljs-keyword">auto</span> p = dummy, q = dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i ++) p = p-&gt;next;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right; i ++) q = q-&gt;next;<br>        <br>        <span class="hljs-keyword">auto</span> u = p-&gt;next, v = p-&gt;next-&gt;next;<br>        p-&gt;next-&gt;next = q-&gt;next;<br>        p-&gt;next = q;<br>        <span class="hljs-keyword">while</span> (u != q) &#123;<br><br>            <span class="hljs-keyword">auto</span> r = v-&gt;next;<br>            v-&gt;next = u;<br>            u = v, v = r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="94-二叉树的中序遍历-easy"><a href="#94-二叉树的中序遍历-easy" class="headerlink" title="94. *二叉树的中序遍历(easy)"></a>94. *二叉树的中序遍历(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">https://leetcode.cn/problems/binary-tree-inorder-traversal/</a></p>
</blockquote>
<ul>
<li>
<p>递归写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans; <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>迭代写法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>      <span class="hljs-comment">// 这里root和stk.size()是两个判断条件.</span><br>      <span class="hljs-comment">// root用来判断上一个处理节点是否有右节点, 如果有就递归到右节点</span><br>      <span class="hljs-comment">// stk.size()用来判断上一个节点如果没有右节点, 就从栈中弹出上一个节点处理</span><br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="98-验证二叉搜索树-medium"><a href="#98-验证二叉搜索树-medium" class="headerlink" title="98. *验证二叉搜索树(medium)"></a>98. *验证二叉搜索树(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">https://leetcode.cn/problems/validate-binary-search-tree/</a></p>
</blockquote>
<ul>
<li>dfs函数返回一个节点所在子树的元素最小值和最大值.</li>
<li>递归向上比较左子树最大值, 右子树最小值和当前节点值的关系即可验证.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">bool</span> ans = <span class="hljs-literal">true</span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-type">int</span> minv = root-&gt;val, maxv = root-&gt;val;<br>        <span class="hljs-keyword">if</span> (root-&gt;left) &#123;<br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>            <span class="hljs-keyword">if</span> (t[<span class="hljs-number">1</span>] &gt;= root-&gt;val) ans = <span class="hljs-literal">false</span>;<br>            minv = <span class="hljs-built_in">min</span>(minv, t[<span class="hljs-number">0</span>]);<br>            maxv = <span class="hljs-built_in">max</span>(maxv, t[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (root-&gt;right) &#123;<br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>            <span class="hljs-keyword">if</span> (t[<span class="hljs-number">0</span>] &lt;= root-&gt;val) ans = <span class="hljs-literal">false</span>;<br>            minv = <span class="hljs-built_in">min</span>(minv, t[<span class="hljs-number">0</span>]);<br>            maxv = <span class="hljs-built_in">max</span>(maxv, t[<span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;minv, maxv&#125;;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="101-对称二叉树-easy"><a href="#101-对称二叉树-easy" class="headerlink" title="101. *对称二叉树(easy)"></a>101. *对称二叉树(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p>
</blockquote>
<ul>
<li>
<p>递归判断一个节点的左节点和右节点是否相等即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;left, root-&gt;right); <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!p || !q) <span class="hljs-keyword">return</span> !p &amp;&amp; !q;<br>        <span class="hljs-keyword">if</span> (p-&gt;val != q-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="hljs-built_in">dfs</span>(p-&gt;right, q-&gt;left);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. *二叉树的层序遍历"></a>102. *二叉树的层序遍历</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p>
</blockquote>
<ul>
<li>注意: 层序遍历的话, 一定要首先特判根节点是否为<code>NULL</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>          <span class="hljs-comment">// 这里的q.size()就是一层的长度</span><br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-type">int</span>&gt; level;<br>            <span class="hljs-keyword">while</span> (len --) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                level.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="104-二叉树的最大深度-easy"><a href="#104-二叉树的最大深度-easy" class="headerlink" title="104. *二叉树的最大深度(easy)"></a>104. *二叉树的最大深度(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left), <span class="hljs-built_in">maxDepth</span>(root-&gt;right)) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="105-从前序与中序遍历序列构造二叉树-medium"><a href="#105-从前序与中序遍历序列构造二叉树-medium" class="headerlink" title="105. *从前序与中序遍历序列构造二叉树 (medium)"></a>105. *从前序与中序遍历序列构造二叉树 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = inorder.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) hash[inorder[i]] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(preorder, inorder, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;preorder, vector&lt;<span class="hljs-type">int</span>&gt; &amp;inorder, <span class="hljs-type">int</span> pl, <span class="hljs-type">int</span> pr, <span class="hljs-type">int</span> il, <span class="hljs-type">int</span> ir)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (pl &gt; pr) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>       <span class="hljs-type">int</span> r = preorder[pl];<br>       <span class="hljs-type">int</span> k = hash[r];<br>       <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(r);<br>      <span class="hljs-comment">// 注意这里是(k - 1) - il + 1</span><br>       root-&gt;left = <span class="hljs-built_in">dfs</span>(preorder, inorder, pl + <span class="hljs-number">1</span>, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il + <span class="hljs-number">1</span> - <span class="hljs-number">1</span>, il, k - <span class="hljs-number">1</span>);<br>       root-&gt;right = <span class="hljs-built_in">dfs</span>(preorder, inorder, pl + <span class="hljs-number">1</span> + k - <span class="hljs-number">1</span> - il + <span class="hljs-number">1</span>, pr, k + <span class="hljs-number">1</span>, ir);<br>       <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="108-将有序数组转换为二叉搜索树-medium"><a href="#108-将有序数组转换为二叉搜索树-medium" class="headerlink" title="108. *将有序数组转换为二叉搜索树(medium)"></a>108. *将有序数组转换为二叉搜索树(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/</a></p>
</blockquote>
<ul>
<li>从中点开始创造节点, 然后左子树和右子树从中点前后范围递归构建.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(nums[mid]);<br>        root-&gt;left = <span class="hljs-built_in">dfs</span>(nums, l, mid - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">dfs</span>(nums, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="114-二叉树展开为链表-medium"><a href="#114-二叉树展开为链表-medium" class="headerlink" title="114. *二叉树展开为链表(medium)"></a>114. *二叉树展开为链表(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/</a></p>
</blockquote>
<ul>
<li>从直观上来看, 需要把一个节点的左子树, 归并到这个节点和右节点之间.</li>
<li>左子树有两个关键的节点:
<ul>
<li>左子树根节点, 当前节点的右指针要指向左子树根节点.</li>
<li>当前节点中序遍历的前驱, 前驱的右节点需要指向右子树根节点.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur = root;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-keyword">if</span> (cur-&gt;left) &#123;<br>                <span class="hljs-keyword">auto</span> prev = cur-&gt;left;<br>                <span class="hljs-keyword">while</span> (prev-&gt;right) prev = prev-&gt;right;<br>                prev-&gt;right = cur-&gt;right;<br>                cur-&gt;right = cur-&gt;left;<br>                cur-&gt;left = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="118-杨辉三角-easy"><a href="#118-杨辉三角-easy" class="headerlink" title="118. *杨辉三角(easy)"></a>118. *杨辉三角(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/pascals-triangle/">https://leetcode.cn/problems/pascals-triangle/</a></p>
</blockquote>
<ul>
<li>注意: 杨辉三角每一行的第一个数和最后一个数都是1.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; f;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i ++) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">level</span><span class="hljs-params">(i + <span class="hljs-number">1</span>)</span></span>;<br>            level[<span class="hljs-number">0</span>] = level[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++)<br>                level[j] = f[i - <span class="hljs-number">1</span>][j] + f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            f.<span class="hljs-built_in">push_back</span>(level);<br>        &#125;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="121-买卖股票的最佳时机-easy"><a href="#121-买卖股票的最佳时机-easy" class="headerlink" title="121. *买卖股票的最佳时机(easy)"></a>121. *买卖股票的最佳时机(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p>
</blockquote>
<ul>
<li>
<p>直接倒序遍历的过程中, 统计股票价格最大值即可.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> v = <span class="hljs-number">-1</span>, n = prices.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">if</span> (v == <span class="hljs-number">-1</span>) v = prices[i];<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans = <span class="hljs-built_in">max</span>(ans, v - prices[i]);<br>                v = <span class="hljs-built_in">max</span>(v, prices[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="124-二叉树中的最大路径和-hard"><a href="#124-二叉树中的最大路径和-hard" class="headerlink" title="124. *二叉树中的最大路径和(hard)"></a>124. *二叉树中的最大路径和(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">https://leetcode.cn/problems/binary-tree-maximum-path-sum/</a></p>
</blockquote>
<ul>
<li><code>dfs</code>函数是从当前节点出发, 伸到子树中所有节点的单向路径的最大权值之和.</li>
<li>那么对于一条路径, 他有三种情况:
<ul>
<li>从左节点向下延伸.</li>
<li>从右节点向下延伸.</li>
<li>从左右节点同时向下延伸.</li>
</ul>
</li>
<li>只需要对这三种情况取一个max即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-built_in">dfs</span>(root-&gt;left), r = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>        <span class="hljs-type">int</span> maxv = root-&gt;val;<br>        maxv = <span class="hljs-built_in">max</span>(maxv, root-&gt;val + l);<br>        maxv = <span class="hljs-built_in">max</span>(maxv, root-&gt;val + r);<br>        <span class="hljs-type">int</span> c = maxv;<br>        maxv = <span class="hljs-built_in">max</span>(maxv, l + r + root-&gt;val);<br>        ans = <span class="hljs-built_in">max</span>(ans, maxv);<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="128-最长连续序列-medium"><a href="#128-最长连续序列-medium" class="headerlink" title="128. *最长连续序列(medium)"></a>128. *最长连续序列(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-consecutive-sequence/">https://leetcode.cn/problems/longest-consecutive-sequence/</a></p>
</blockquote>
<ul>
<li>首先, 将数组中所有数字插入哈希表.</li>
<li>然后, 枚举数组中的每一个数字<code>x</code>, 将这个数字作为起点 (起点的意思就是<code>!hash.count(x - 1)</code>), 然后枚举<code>x + 1, x + 2, ...</code>, 如果一直在哈希表中, 那么序列就可以延伸, 直到有一个元素不在哈希表.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) hash.<span class="hljs-built_in">insert</span>(x);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(x - <span class="hljs-number">1</span>)) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> y = x + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (hash.<span class="hljs-built_in">count</span>(y)) y ++;<br>            ans = <span class="hljs-built_in">max</span>(ans, y - x);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="131-分割回文串-medium"><a href="#131-分割回文串-medium" class="headerlink" title="131. *分割回文串(medium)"></a>131. *分割回文串(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-partitioning/">https://leetcode.cn/problems/palindrome-partitioning/</a></p>
</blockquote>
<ul>
<li>首先, 如果一个字符串是<code>aaaaa..</code>, 那么枚举分割方案的时间复杂度是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.765ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2548.3 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-36-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-36-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-36-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path id="MJX-36-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-36-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-36-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-36-TEX-N-28"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mn"><use data-c="32" xlink:href="#MJX-36-TEX-N-32"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><use data-c="1D45B" xlink:href="#MJX-36-TEX-I-1D45B"/></g></g><g data-mml-node="mo" transform="translate(2159.3,0)"><use data-c="29" xlink:href="#MJX-36-TEX-N-29"/></g></g></g></svg>, 所以这个问题是一个爆搜问题.</li>
<li>其次, 枚举<strong>分割方案</strong>的方法是, 枚举一个起点<code>u</code>, 然后从<code>u</code>向后 (包括<code>u</code>), 枚举终点<code>i</code>, 枚举终点后, 递归到下一个起点<code>i + 1</code>.</li>
<li>可以用一个<code>f[i][j]</code>预处理<code>s[i, j]</code>是否是回文串, 递推式是:
<ul>
<li><code>f[i][j] = f[i + 1][j - 1] &amp;&amp; s[i] == s[j]</code>.</li>
<li>注意由于要满足拓扑序, <code>i</code>要从后向前, <code>j</code>要从前向后.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; path;<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; f;<br>    vector&lt;vector&lt;string&gt;&gt; ans;<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        f = vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt;(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --)<br>                <span class="hljs-keyword">if</span> (i == j) f[i][j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &gt; j - <span class="hljs-number">1</span>) f[i][j] = (s[i] == s[j]);<br>                <span class="hljs-keyword">else</span> f[i][j] = f[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &amp;&amp; (s[i] == s[j]);<br>        <span class="hljs-built_in">dfs</span>(s, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;    <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (u == s.<span class="hljs-built_in">size</span>()) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = u; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (!f[u][i]) <span class="hljs-keyword">continue</span>;<br>            path.<span class="hljs-built_in">push_back</span>(s.<span class="hljs-built_in">substr</span>(u, i - u + <span class="hljs-number">1</span>));<br>            <span class="hljs-built_in">dfs</span>(s, i + <span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="136-只出现一次的数字-easy"><a href="#136-只出现一次的数字-easy" class="headerlink" title="136. *只出现一次的数字(easy)"></a>136. *只出现一次的数字(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/single-number/">https://leetcode.cn/problems/single-number/</a></p>
</blockquote>
<ul>
<li>直接对数组中所有元素进行异或就可以.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums) ans = ans ^ x;<br>       <span class="hljs-keyword">return</span> ans; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="139-单词拆分-medium"><a href="#139-单词拆分-medium" class="headerlink" title="139. *单词拆分(medium)"></a>139. *单词拆分(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-break/">https://leetcode.cn/problems/word-break/</a></p>
</blockquote>
<ul>
<li>设<code>f[i]</code>表示以<code>s[i]</code>结尾, 是否存在划分方式.</li>
<li>那么假设<code>k &lt; i</code>, 并且<code>s[k:i]</code>是在字典中出现的, 那么<code>f[i] = f[k - 1]</code>.
<ul>
<li>如果要判断<code>s[k:i]</code>是否在字典中出现过, 可以用字符串哈希, 做到<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-37-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-37-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-37-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-37-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-37-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-37-TEX-N-28"/></g><g data-mml-node="mn" transform="translate(1152,0)"><use data-c="31" xlink:href="#MJX-37-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(1652,0)"><use data-c="29" xlink:href="#MJX-37-TEX-N-29"/></g></g></g></svg>的时间复杂度.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">131</span>;<br>        <span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br>        unordered_set&lt;ULL&gt; hash;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;word: wordDict) &#123;<br>            ULL h = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : word) h = h * P + c;<br>            hash.<span class="hljs-built_in">insert</span>(h);<br>        &#125;<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        s = <span class="hljs-string">&#x27; &#x27;</span> + s;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">if</span> (!f[i]) <span class="hljs-keyword">continue</span>;<br>            ULL h = <span class="hljs-number">0</span>;<br>          <span class="hljs-comment">// 枚举f[i]能更新到哪个位置</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j ++) &#123;<br>                h = h * P + s[j];<br>                <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(h)) f[j] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[n];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138. *随机链表的复制"></a>138. *随机链表的复制</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/copy-list-with-random-pointer/">https://leetcode.cn/problems/copy-list-with-random-pointer/</a></p>
</blockquote>
<ul>
<li>首先, 对于旧链表中的每一个节点, 在后面插入一个新的节点, 那么我就可以通过旧链表的位置相对关系, 推导出新链表的位置相对关系.</li>
<li>之后, 如果要复制<code>random</code>边, 只需要让旧链表中的节点<code>p</code>, 让<code>p-&gt;next-&gt;random = p-&gt;random-&gt;next</code>.
<ul>
<li>其中<code>p-&gt;next</code>是新链表中的对应节点, <code>p-&gt;random-&gt;next</code>就是<code>p-&gt;random</code>在新链表中的相对位置.</li>
</ul>
</li>
<li>之后, 再把新链表节点从原链表拆出来就可以.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next) &#123;<br>            <span class="hljs-keyword">auto</span> q = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(p-&gt;val);<br>            q-&gt;next = p-&gt;next;<br>            p-&gt;next = q;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;random) p-&gt;next-&gt;random = p-&gt;random-&gt;next;<br>            <span class="hljs-keyword">else</span> p-&gt;next-&gt;random = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>), cur = dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p; p = p-&gt;next) &#123;<br>            cur = cur-&gt;next = p-&gt;next;<br>            p-&gt;next = p-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="141-环形链表-easy"><a href="#141-环形链表-easy" class="headerlink" title="141. *环形链表(easy)"></a>141. *环形链表(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle/">https://leetcode.cn/problems/linked-list-cycle/</a></p>
</blockquote>
<ul>
<li>用快慢指针, 快指针一次两个, 慢指针一次一个, 最终相遇, 就证明有环.</li>
<li>注意, 如果链表只有一个节点, 那么当两个指针相等的时候可能都是<code>NULL</code>, 这个要特判一下.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = head, q = head;<br>        <span class="hljs-keyword">while</span> (p &amp;&amp; q) &#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (q) q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (q &amp;&amp; p == q) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="142-环形链表II-medium"><a href="#142-环形链表II-medium" class="headerlink" title="142. *环形链表II (medium)"></a>142. *环形链表II (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">https://leetcode.cn/problems/linked-list-cycle-ii/</a></p>
</blockquote>
<ul>
<li>继上一题, 如果要找环形链表的环入口:
<ul>
<li>当快慢指针第一次相遇时, 让慢指针退后到起始点.</li>
<li>然后快指针和慢指针同时向后移动一次, 最终相遇点就是环的入口.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = head, q = head;<br>        <span class="hljs-keyword">while</span> (p &amp;&amp; q) &#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (q) q = q-&gt;next;<br>            <span class="hljs-keyword">if</span> (q &amp;&amp; p == q) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!q) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        p = head;<br>        <span class="hljs-keyword">while</span> (p != q) p = p-&gt;next, q = q-&gt;next;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="144-二叉树的前序遍历-medium"><a href="#144-二叉树的前序遍历-medium" class="headerlink" title="144. 二叉树的前序遍历(medium)"></a>144. 二叉树的前序遍历(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">https://leetcode.cn/problems/binary-tree-preorder-traversal/</a></p>
</blockquote>
<ul>
<li>递归写法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left);<br>        <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>迭代写法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    stack&lt;TreeNode *&gt; stk;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (root || stk.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (root) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>(); stk.<span class="hljs-built_in">pop</span>();<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="146-LRU缓存-medium"><a href="#146-LRU缓存-medium" class="headerlink" title="146. *LRU缓存(medium)"></a>146. *LRU缓存(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lru-cache/">https://leetcode.cn/problems/lru-cache/</a></p>
</blockquote>
<ul>
<li>LRU缓存需要用一个双向链表和一个哈希表实现.
<ul>
<li>双向链表: 存储实际的<code>key</code>和<code>value</code>.</li>
<li>哈希表: 用于快速通过<code>key</code>获取双向链表节点的位置.</li>
</ul>
</li>
<li>构造函数逻辑:
<ul>
<li>主要初始化双向链表的哨兵节点.</li>
</ul>
</li>
<li><code>get</code>函数逻辑:
<ul>
<li>首先通过<code>key</code>, 在哈希表中找到节点 (如果节点不存在就直接返回<code>NULL</code>).</li>
<li>然后把这个节点从双向链表中删除, 放到头节点.</li>
</ul>
</li>
<li><code>put</code>函数逻辑:
<ul>
<li>如果哈希表原来存在, 那么就修改, 从双链表中删除, 放到头节点.</li>
<li>如果没有:
<ul>
<li>如果容量满了, 那么就要删除双向链表的尾部节点, 并且从哈希表中清除记录.</li>
<li>从哈希表中创建节点, 然后放到双链表最左侧.</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> key, value;<br>        Node *left, *right;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _key, <span class="hljs-type">int</span> _value): <span class="hljs-built_in">key</span>(_key), <span class="hljs-built_in">value</span>(_value), <span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>    &#125; *L, *R;<br>    unordered_map&lt;<span class="hljs-type">int</span>, Node*&gt; hash;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node *u)</span> </span>&#123;<br>        u-&gt;right-&gt;left = u-&gt;left;<br>        u-&gt;left-&gt;right = u-&gt;right;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Node *u)</span> </span>&#123;<br>        u-&gt;left = L;<br>        u-&gt;right = L-&gt;right;<br>        L-&gt;right-&gt;left = u;<br>        L-&gt;right = u;<br>    &#125;<br><br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        n = capacity;<br>        L = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);<br>        R = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>);<br>        L-&gt;right = R, R-&gt;left = L;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!hash.<span class="hljs-built_in">count</span>(key)) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">auto</span> t = hash[key];<br>        <span class="hljs-built_in">remove</span>(t); <span class="hljs-built_in">insert</span>(t);<br>        <span class="hljs-keyword">return</span> t-&gt;value;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">count</span>(key)) &#123;<br>            <span class="hljs-keyword">auto</span> t = hash[key];<br>            t-&gt;value = value;<br>            <span class="hljs-built_in">remove</span>(t); <span class="hljs-built_in">insert</span>(t);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (hash.<span class="hljs-built_in">size</span>() == n) &#123;<br>                <span class="hljs-keyword">auto</span> p = R-&gt;left;<br>                hash.<span class="hljs-built_in">erase</span>(p-&gt;key);<br>                <span class="hljs-built_in">remove</span>(p);<br>                <span class="hljs-keyword">delete</span> p;<br>            &#125;<br>            <span class="hljs-keyword">auto</span> t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>            hash[key] = t;<br>            <span class="hljs-built_in">insert</span>(t);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="148-排序链表-medium"><a href="#148-排序链表-medium" class="headerlink" title="148. *排序链表(medium)"></a>148. *排序链表(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-list/">https://leetcode.cn/problems/sort-list/</a></p>
</blockquote>
<ul>
<li>如果要求空间复杂度是常数, 那么只能用非递归的归并排序.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>       <span class="hljs-comment">// 统计链表节点数目</span><br>       <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = head; p ; p = p-&gt;next) n ++;<br><br>       <span class="hljs-comment">// 第一层枚举两个归并区间中每个区间的长度</span><br>       <span class="hljs-comment">// 一共做n-1层, 最终合并到n个元素</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i *= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">auto</span> dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>), cur = dummy;<br>            <span class="hljs-comment">// 第二层以枚举由所有的两个归并区间</span><br>         		<span class="hljs-comment">// 注意这里一定是j &lt;= n, 因为j = n证明区间里面只有一个元素, 也要单独做一层.</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j += i * <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-comment">// head存储归并区间开头</span><br>                <span class="hljs-keyword">auto</span> p = head, q = p;<br>                <span class="hljs-comment">// 把q放到下一个归并区间开头, 归并区间长度很可能不足i</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; i &amp;&amp; q; k ++) q = q-&gt;next;<br>                <span class="hljs-comment">// o存储下一个归并区间的开头, 方便更新head</span><br>                <span class="hljs-keyword">auto</span> o = q;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; i &amp;&amp; o; k ++) o = o-&gt;next;<br>                <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (l &lt; i &amp;&amp; r &lt; i &amp;&amp; p &amp;&amp; q)<br>                    <span class="hljs-keyword">if</span> (p-&gt;val &lt;= q-&gt;val) cur = cur-&gt;next = p, p = p-&gt;next, l ++;<br>                    <span class="hljs-keyword">else</span> cur = cur-&gt;next = q, q = q-&gt;next, r ++;<br>                <span class="hljs-keyword">while</span> (l &lt; i &amp;&amp; p) cur = cur-&gt;next = p, p = p-&gt;next, l ++;<br>                <span class="hljs-keyword">while</span> (r &lt; i &amp;&amp; q) cur = cur-&gt;next = q, q = q-&gt;next, r ++;<br>                head = o;<br>            &#125;<br>            <span class="hljs-comment">// 做完一层, 最后的节点next是NULL</span><br>            cur-&gt;next = <span class="hljs-literal">NULL</span>;<br>            head = dummy-&gt;next;<br>       &#125;<br>       <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="152-乘积最大子数组-medium"><a href="#152-乘积最大子数组-medium" class="headerlink" title="152. *乘积最大子数组(medium)"></a>152. *乘积最大子数组(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-product-subarray/">https://leetcode.cn/problems/maximum-product-subarray/</a></p>
</blockquote>
<ul>
<li>设<code>f[i]</code>, <code>g[i]</code>分别表示以<code>i</code>结尾的, 连续子数组乘积的最大值和最小值.
<ul>
<li>存储最小值的原因是因为乘法具有负负得正的特性.</li>
</ul>
</li>
<li>那么<code>f[i] = max(nums[i], f[i - 1] * nums[i], g[i - 1] * nums[i])</code>.</li>
<li>并且<code>g[i] = min(nums[i], f[i - 1] * nums[i], g[i - 1] * nums[i])</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = nums[<span class="hljs-number">0</span>], f = nums[<span class="hljs-number">0</span>], g = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-type">int</span> fp = f, gp = g;<br>            f = <span class="hljs-built_in">max</span>(nums[i], <span class="hljs-built_in">max</span>(nums[i] * fp, nums[i] * gp));<br>            g = <span class="hljs-built_in">min</span>(nums[i], <span class="hljs-built_in">min</span>(nums[i] * fp, nums[i] * gp));<br>            ans = <span class="hljs-built_in">max</span>(ans, f);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="153-寻找旋转排序数组中的最小值-medium"><a href="#153-寻找旋转排序数组中的最小值-medium" class="headerlink" title="153. *寻找旋转排序数组中的最小值(medium)"></a>153. *寻找旋转排序数组中的最小值(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/</a></p>
</blockquote>
<ul>
<li>假设数组的第一个元素是<code>nums[0]</code>.</li>
<li>数组的前半部分满足<code>nums[i] &gt;= nums[0]</code>, 后半部分满足<code>nums[i] &lt; nums[0]</code>, 以此来二分.</li>
<li>如果数组完全单调递增, 那么最终二分出来的<code>nums[i] &gt;= nums[0]</code>, 此时直接返回<code>nums[0]</code>.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (nums[mid] &gt;= nums[<span class="hljs-number">0</span>]) l = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[l] &gt;= nums[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> nums[l];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="155-最小栈-medium"><a href="#155-最小栈-medium" class="headerlink" title="155. 最小栈(medium)"></a>155. 最小栈(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/min-stack/">https://leetcode.cn/problems/min-stack/</a></p>
</blockquote>
<ul>
<li>直接单独开一个栈, 专门用来存储最小值.</li>
<li>push时, 如果这个最小栈是空的, 或者要插入的值value小于等于(注意, 一定是小于等于)最小栈栈顶, 那么就要向最小栈中插入.</li>
<li>pop时, 如果最小栈的栈顶等于当前栈要pop出去的元素, 那么最小栈就pop.</li>
<li>对于<code>stack</code>来说, 要调用<code>top()</code>一定要保证栈不是空的!!</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stk_min;<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        stk.<span class="hljs-built_in">push</span>(val);<br>        <span class="hljs-keyword">if</span> (stk_min.<span class="hljs-built_in">empty</span>() || val &lt;= stk_min.<span class="hljs-built_in">top</span>()) stk_min.<span class="hljs-built_in">push</span>(val);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (stk_min.<span class="hljs-built_in">top</span>() == stk.<span class="hljs-built_in">top</span>()) stk_min.<span class="hljs-built_in">pop</span>();<br>       stk.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">top</span>(); <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> stk_min.<span class="hljs-built_in">top</span>(); <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="160-相交链表-easy"><a href="#160-相交链表-easy" class="headerlink" title="160. *相交链表(easy)"></a>160. *相交链表(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></p>
</blockquote>
<ul>
<li>让两个指针同时向前走一步, 如果有一个指针走到尽头, 那么就把它放到第二个指针的头部继续走.</li>
<li>当两个指针相同时, 如果不为NULL, 那么就是相遇点, 否则就不是.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = headA, q = headB;<br>        <span class="hljs-keyword">while</span> (p != q) &#123;<br>            <span class="hljs-keyword">if</span> (p) p = p-&gt;next;<br>            <span class="hljs-keyword">else</span> p = headB;<br>            <span class="hljs-keyword">if</span> (q) q = q-&gt;next;<br>            <span class="hljs-keyword">else</span> q = headA;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!p) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="169-多数元素-easy"><a href="#169-多数元素-easy" class="headerlink" title="169. *多数元素(easy)"></a>169. *多数元素(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/majority-element/">https://leetcode.cn/problems/majority-element/</a></p>
</blockquote>
<ul>
<li>摩尔投票算法: 使用<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-38-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-38-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-38-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-38-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-38-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-38-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-38-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-38-TEX-N-29"/></g></g></g></svg>时间复杂度, <svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-39-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-39-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-39-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path id="MJX-39-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-39-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-39-TEX-N-28"/></g><g data-mml-node="mn" transform="translate(1152,0)"><use data-c="31" xlink:href="#MJX-39-TEX-N-31"/></g><g data-mml-node="mo" transform="translate(1652,0)"><use data-c="29" xlink:href="#MJX-39-TEX-N-29"/></g></g></g></svg>的空间复杂度, 找到一个数组中的众数.
<ul>
<li>从前到后遍历数组中的元素<code>x</code>, 并且维护一个当前候选人<code>r</code>和投票数<code>c</code>.</li>
<li>如果某个元素<code>x</code>等于<code>r</code>, 那么投票数<code>c ++</code>.</li>
<li>如果不等于<code>r</code>, 那么投票数<code>c --</code>.</li>
<li>如果投票数减到0, 那么<code>r</code>就要换人.</li>
<li>最终的<code>r</code>就是赢家.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (!c) r = x;<br>            <span class="hljs-keyword">if</span> (x == r) c ++;<br>            <span class="hljs-keyword">else</span> c --;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="189-轮转数组-medium"><a href="#189-轮转数组-medium" class="headerlink" title="189 *轮转数组(medium)"></a>189 *轮转数组(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotate-array/">https://leetcode.cn/problems/rotate-array/</a></p>
</blockquote>
<ul>
<li>
<p>这种题一般是把一个数组/序列的一部分移动到最前面的位置, 通用做法是:</p>
<ul>
<li>先反转整个数组, 再分别反转数组的前面/后面的位置.</li>
</ul>
</li>
<li>
<p>注意: <code>k</code>可能是一个很大的异常值, 需要模上数组长度.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        k = k % nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">begin</span>() + k);<br>        <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + k, nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="198-打家劫舍-medium"><a href="#198-打家劫舍-medium" class="headerlink" title="198. *打家劫舍 (medium)"></a>198. *打家劫舍 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber/">https://leetcode.cn/problems/house-robber/</a></p>
</blockquote>
<ul>
<li>状态机DP: <code>f[i][0]</code>表示第<code>i</code>个房子不打劫, <code>f[i][1]</code>表示打劫, 从后向前递推即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br><br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = nums[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) &#123;<br>            f[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            f[i][<span class="hljs-number">1</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(f[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="199-二叉树的右视图-medium"><a href="#199-二叉树的右视图-medium" class="headerlink" title="199. *二叉树的右视图(medium)"></a>199. *二叉树的右视图(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">https://leetcode.cn/problems/binary-tree-right-side-view/</a></p>
</blockquote>
<ul>
<li>右视图序列就是层序遍历中每一层最后一个节点组成的序列.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ans;<br><br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (i == len - <span class="hljs-number">1</span>) ans.<span class="hljs-built_in">push_back</span>(t-&gt;val);<br>                <span class="hljs-keyword">if</span> (t-&gt;left) q.<span class="hljs-built_in">push</span>(t-&gt;left);<br>                <span class="hljs-keyword">if</span> (t-&gt;right) q.<span class="hljs-built_in">push</span>(t-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="200-岛屿数量-medium"><a href="#200-岛屿数量-medium" class="headerlink" title="200. *岛屿数量 (medium)"></a>200. *岛屿数量 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/number-of-islands/">https://leetcode.cn/problems/number-of-islands/</a></p>
</blockquote>
<ul>
<li>Flood Fill算法:
<ul>
<li>每次遇到一块陆地, 就从这个陆地为起点进行搜索, 从这个起点向四周扩散, 如果再次遇到陆地, 就递归搜索.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                    <span class="hljs-built_in">dfs</span>(grid, i, j), ans ++;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;grid, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        grid[x][y] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>            <span class="hljs-type">int</span> a = x + dx[i], b = y + dy[i];<br>            <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m || grid[a][b] == <span class="hljs-string">&#x27;0&#x27;</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-built_in">dfs</span>(grid, a, b);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="206-反转链表-easy"><a href="#206-反转链表-easy" class="headerlink" title="206. *反转链表(easy)"></a>206. *反转链表(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>
</blockquote>
<ul>
<li>递归方法: 注意先判断链表是否是空/只有一个节点.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> tail = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>迭代方法:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode *p = <span class="hljs-literal">NULL</span>;<br>        ListNode *q = head;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">auto</span> r = q-&gt;next;<br>            q-&gt;next = p;<br>            p = q, q = r;<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="207-课程表-medium"><a href="#207-课程表-medium" class="headerlink" title="207. *课程表(medium)"></a>207. *课程表(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/course-schedule/">https://leetcode.cn/problems/course-schedule/</a></p>
</blockquote>
<ul>
<li>从先修课程到后置课程连接一条有向边, 组成一个有向图.</li>
<li>然后用拓扑排序, 所有入度为0的节点先入队, 然后BFS, 每次扩展一层就把入度-1, 然后再次把入度为0的点入队.</li>
<li>如果一个图有环, 那么当遍历到环的入口节点之后, 入口节点入度-1后还是1, 永远无法变成0, 那么这种节点就永远无法进入队列, 因此只要进入/弹出队列的节点数目小于<code>n</code>, 就证明有环.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-type">int</span> numCourses, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = numCourses;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n)</span></span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;e: prerequisites) &#123;<br>            <span class="hljs-type">int</span> a = e[<span class="hljs-number">1</span>], b = e[<span class="hljs-number">0</span>];<br>            g[a].<span class="hljs-built_in">push_back</span>(b); d[b] ++;<br>        &#125;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">if</span> (!d[i]) q.<span class="hljs-built_in">push</span>(i);<br>        <br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> u: g[t])<br>                <span class="hljs-keyword">if</span> (-- d[u] == <span class="hljs-number">0</span>)<br>                    q.<span class="hljs-built_in">push</span>(u);<br>            cnt ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cnt == n;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="208-实现Trie-前缀树"><a href="#208-实现Trie-前缀树" class="headerlink" title="208. *实现Trie(前缀树)"></a>208. *实现Trie(前缀树)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/">https://leetcode.cn/problems/implement-trie-prefix-tree/</a></p>
</blockquote>
<ul>
<li>前缀树模板题.</li>
<li>前缀树存储的元素需要有固定的字符集进行编码, 假设字符集中的元素个数为n, 那么前缀树就是一个n叉树.</li>
<li>n叉树的节点有两个成员变量:
<ul>
<li>一个用来存储所有的儿子.</li>
<li>另一个用来存储这个节点是否是某个元素的结尾.</li>
</ul>
</li>
<li>查询和插入都是<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-40-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-40-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-40-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-40-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-40-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-40-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-40-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-40-TEX-N-29"/></g></g></g></svg>的时间复杂度, 其中<svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-41-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D45B" xlink:href="#MJX-41-TEX-I-1D45B"/></g></g></g></svg>是字符集元素的个数.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        Node *son[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">bool</span> is_end;<br><br>        <span class="hljs-built_in">Node</span>() &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i ++) son[i] = <span class="hljs-literal">NULL</span>;<br>            is_end = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125; *root;<br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: word) &#123;<br>            <span class="hljs-type">int</span> u = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (!p-&gt;son[u]) p-&gt;son[u] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>();<br>            p = p-&gt;son[u];<br>        &#125;<br>        p-&gt;is_end = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: word) &#123;<br>            <span class="hljs-type">int</span> u = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (!p-&gt;son[u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p-&gt;son[u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p-&gt;is_end;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c: prefix) &#123;<br>            <span class="hljs-type">int</span> u = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (!p-&gt;son[u]) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p-&gt;son[u];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="215-数组中的第K个最大元素-medium"><a href="#215-数组中的第K个最大元素-medium" class="headerlink" title="215. *数组中的第K个最大元素(medium)"></a>215. *数组中的第K个最大元素(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">https://leetcode.cn/problems/kth-largest-element-in-an-array/</a></p>
</blockquote>
<ul>
<li>首先注意题目要求是第k个最大, 还是第k个最小.</li>
<li>本题是快速选择算法.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, k); <br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> nums[l];<br>        <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = nums[l + (r - l) / <span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (nums[ ++ i] &gt; x);<br>            <span class="hljs-keyword">while</span> (nums[ --j] &lt; x);<br>            <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(nums[i], nums[j]);<br>        &#125;<br>        <span class="hljs-type">int</span> sl = j - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k &lt;= sl) <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(nums, l, j, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">quick_sort</span>(nums, j + <span class="hljs-number">1</span>, r, k - sl);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="226-翻转二叉树-easy"><a href="#226-翻转二叉树-easy" class="headerlink" title="226. *翻转二叉树(easy)"></a>226. *翻转二叉树(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></p>
</blockquote>
<ul>
<li>首先递归翻转左子树和右子树, 然后将左子树和右子树进行交换即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">auto</span> left = <span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        <span class="hljs-keyword">auto</span> right = <span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        root-&gt;left = right;<br>        root-&gt;right = left;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="230-二叉搜索树中第K小的元素-medium"><a href="#230-二叉搜索树中第K小的元素-medium" class="headerlink" title="230. *二叉搜索树中第K小的元素(medium)"></a>230. *二叉搜索树中第K小的元素(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">https://leetcode.cn/problems/kth-smallest-element-in-a-bst/</a></p>
</blockquote>
<ul>
<li>中序遍历的过程中, 每次遍历一个节点, 就将计数器+1, 计数到<code>k</code>的时候, 就找到了第k小的元素.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> k, ans;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> _k)</span> </span>&#123;<br>        k = _k;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(root-&gt;left)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (-- k == <span class="hljs-number">0</span>) &#123;<br>            ans = root-&gt;val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="234-回文链表-easy"><a href="#234-回文链表-easy" class="headerlink" title="234. *回文链表(easy)"></a>234. *回文链表(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/palindrome-linked-list/">https://leetcode.cn/problems/palindrome-linked-list/</a></p>
</blockquote>
<ul>
<li>首先, 找到链表的中间节点.</li>
<li>之后, 将中间节点后面的链表反转.</li>
<li>然后, 将反转部分的链表和前半部分的链表进行对比即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">auto</span> cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span>) &#123;<br>            cnt ++;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        cnt = cnt % <span class="hljs-number">2</span> ? cnt / <span class="hljs-number">2</span> : cnt / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br><br>        cur = head;<br>        <span class="hljs-keyword">while</span> (cnt --) cur = cur-&gt;next;<br><br>        ListNode *p = <span class="hljs-literal">NULL</span>;<br>        ListNode *q = cur-&gt;next;<br>        <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">auto</span> r = q-&gt;next;<br>            q-&gt;next = p;<br>            p = q, q = r;<br>        &#125;<br>        <span class="hljs-keyword">auto</span> l1 = head, l2 = p;<br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">NULL</span> &amp;&amp; l2 != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l1-&gt;val != l2-&gt;val) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            l1 = l1-&gt;next, l2 = l2-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="236-二叉树的最近公共祖先-medium"><a href="#236-二叉树的最近公共祖先-medium" class="headerlink" title="236. *二叉树的最近公共祖先(medium)"></a>236. *二叉树的最近公共祖先(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
</blockquote>
<ul>
<li>两个节点的最近公共祖先就是同时包含两个节点的, 并且深度最深的节点.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    TreeNode *ans = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root, p, q);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-comment">// root子树是否含有p, q, 都不含00, 有p: 01, 有q: 10, 都有11</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> state = <span class="hljs-built_in">dfs</span>(root-&gt;left, p, q);<br>        <span class="hljs-keyword">if</span> (root == p) state |= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root == q) state |= <span class="hljs-number">2</span>;<br>        state |= <span class="hljs-built_in">dfs</span>(root-&gt;right, p, q);<br>        <span class="hljs-keyword">if</span> (state == <span class="hljs-number">3</span> &amp;&amp; !ans) ans = root;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. *除自身以外数组的乘积"></a>238. *除自身以外数组的乘积</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/product-of-array-except-self/">https://leetcode.cn/problems/product-of-array-except-self/</a></p>
</blockquote>
<ul>
<li>思路: 原地算法
<ul>
<li>首先维护一个类似前缀和的数组, <code>s[i]</code>表示从<code>nums[0]</code>乘到<code>nums[i - 1]</code>.</li>
<li>然后用一个<code>suffix</code>维护后缀积, 遍历乘一遍, 直接赋值到前缀和数组就可以.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">productExceptSelf</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++) s[i] = s[i - <span class="hljs-number">1</span>] * nums[i - <span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-type">int</span> suffix = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            s[i] *= suffix;<br>            suffix *= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="239-滑动窗口最大值-hard"><a href="#239-滑动窗口最大值-hard" class="headerlink" title="239. *滑动窗口最大值(hard)"></a>239. *滑动窗口最大值(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">https://leetcode.cn/problems/sliding-window-maximum/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br>        <span class="hljs-type">int</span> q[N], hh = <span class="hljs-number">0</span>, tt = <span class="hljs-number">-1</span>;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>            <span class="hljs-keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="hljs-number">1</span> &gt; q[hh]) hh ++;<br>            <span class="hljs-keyword">while</span> (hh &lt;= tt &amp;&amp; nums[i] &gt; nums[q[tt]]) tt --;<br>            q[ ++ tt] = i;<br>            <span class="hljs-keyword">if</span> (i - k + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ans.<span class="hljs-built_in">push_back</span>(nums[q[hh]]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="240-搜索二维矩阵II-medium"><a href="#240-搜索二维矩阵II-medium" class="headerlink" title="240. *搜索二维矩阵II (medium)"></a>240. *搜索二维矩阵II (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">https://leetcode.cn/problems/search-a-2d-matrix-ii/</a></p>
</blockquote>
<ul>
<li>拿右上角/左下角的元素作为基准进行搜索即可.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = matrix.<span class="hljs-built_in">size</span>(), m = matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; m) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[x][y] == target) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[x][y] &gt; target) y --;<br>            <span class="hljs-keyword">else</span> x ++;<br>       &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="279-完全平方数-medium"><a href="#279-完全平方数-medium" class="headerlink" title="279. *完全平方数(medium)"></a>279. *完全平方数(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/">https://leetcode.cn/problems/perfect-squares/</a></p>
</blockquote>
<ul>
<li>设<code>f[i]</code>表示能够拼凑出<code>i</code>的方案中, 完全平方数个数的最小值.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-built_in">sqrt</span>(x);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(x + <span class="hljs-number">1</span>, <span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= x; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j * j &lt;= i; j ++) &#123;<br>                f[i] = <span class="hljs-built_in">min</span>(f[i], f[i - j * j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[x];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="283-移动零-medium"><a href="#283-移动零-medium" class="headerlink" title="283. *移动零(medium)"></a>283. *移动零(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/move-zeroes/">https://leetcode.cn/problems/move-zeroes/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) &#123;<br>            <span class="hljs-keyword">if</span> (x) nums[k ++] = x;<br>       &#125;<br>       <span class="hljs-keyword">while</span> (k &lt; nums.<span class="hljs-built_in">size</span>()) nums[k ++] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="287-寻找重复数-medium"><a href="#287-寻找重复数-medium" class="headerlink" title="287. *寻找重复数(medium)"></a>287. *寻找重复数(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-duplicate-number/">https://leetcode.cn/problems/find-the-duplicate-number/</a></p>
</blockquote>
<ul>
<li>这个题等价于环型链表找环入口问题.</li>
<li>对于一个<code>i</code>, 从<code>i</code>向<code>nums[i]</code>连一条边.</li>
<li>如果有重复数, 一定存在环:
<ul>
<li>首先, 环入口入度为2, 因为<code>nums[i]</code>会出现两次, 但是下标不同.</li>
<li>其次, 环入口出度为1, 因为<code>nums[i]</code>在下标范围.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> p = nums[<span class="hljs-number">0</span>], q = nums[nums[<span class="hljs-number">0</span>]];<br>        <span class="hljs-keyword">while</span> (p != q) &#123;<br>            p = nums[p];<br>            q = nums[nums[q]];<br>        &#125;<br>        p = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (p != q) &#123;<br>            p = nums[p];<br>            q = nums[q];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="295-数据流的中位数-hard"><a href="#295-数据流的中位数-hard" class="headerlink" title="295. *数据流的中位数(hard)"></a>295. *数据流的中位数(hard)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-median-from-data-stream/">https://leetcode.cn/problems/find-median-from-data-stream/</a></p>
</blockquote>
<ul>
<li>用<code>up</code>: 小根堆和<code>down</code>: 大根堆来维护.</li>
<li>如果一个数小于等于<code>down.top()</code>那么就插到<code>down</code>中, 否则就插到<code>up</code>中.</li>
<li>然后需要动态维护<code>down</code>和<code>up</code>的大小, 保证<code>down</code>和<code>up</code>大小相等, 或者<code>down.size() - up.size() = 1</code>.</li>
<li>这样就能维护中位数的边界.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MedianFinder</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; up;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; down;<br><br>    <span class="hljs-built_in">MedianFinder</span>() &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (down.<span class="hljs-built_in">empty</span>() || num &lt;= down.<span class="hljs-built_in">top</span>()) &#123;<br>            down.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (down.<span class="hljs-built_in">size</span>() &gt; up.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) &#123;<br>                up.<span class="hljs-built_in">push</span>(down.<span class="hljs-built_in">top</span>());<br>                down.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            up.<span class="hljs-built_in">push</span>(num);<br>            <span class="hljs-keyword">if</span> (up.<span class="hljs-built_in">size</span>() &gt; down.<span class="hljs-built_in">size</span>()) &#123;<br>                down.<span class="hljs-built_in">push</span>(up.<span class="hljs-built_in">top</span>());<br>                up.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = up.<span class="hljs-built_in">size</span>() + down.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> down.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">return</span> (up.<span class="hljs-built_in">top</span>() + down.<span class="hljs-built_in">top</span>()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="300-最长递增子序列-medium"><a href="#300-最长递增子序列-medium" class="headerlink" title="300. *最长递增子序列(medium)"></a>300. *最长递增子序列(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-increasing-subsequence/">https://leetcode.cn/problems/longest-increasing-subsequence/</a></p>
</blockquote>
<ul>
<li>最长上升子序列模型.</li>
<li>注意一点, <code>q</code>数组的长度要初始化成<code>n + 1</code>, 因为最长上升子序列的长度最小值就是1, 没有0, 避免出现下标问题 (因为长度值要作为下标).</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">q</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len;<br>            <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>                <span class="hljs-type">int</span> mid = l + (r - l) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (q[mid] &lt; nums[i]) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            len = <span class="hljs-built_in">max</span>(len, r + <span class="hljs-number">1</span>);<br>            q[r + <span class="hljs-number">1</span>] = nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="322-零钱兑换-medium"><a href="#322-零钱兑换-medium" class="headerlink" title="322. *零钱兑换(medium)"></a>322. *零钱兑换(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></p>
</blockquote>
<ul>
<li>设<code>f[i][j]</code>表示从前<code>i</code>个硬币中选, 正好能凑成<code>amount</code>的方案中, 最少的硬币数量.</li>
<li>然后用完全背包问题即可解决.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; coins, <span class="hljs-type">int</span> amount)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = coins.<span class="hljs-built_in">size</span>(), m = amount;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(m + <span class="hljs-number">1</span>, <span class="hljs-number">0x3f3f3f3f</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = coins[i]; j &lt;= m; j ++) &#123;<br>                f[j] = <span class="hljs-built_in">min</span>(f[j], f[j - coins[i]] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = f[amount] == <span class="hljs-number">0x3f3f3f3f</span> ? <span class="hljs-number">-1</span> : f[amount];<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="347-前k个高频元素-medium"><a href="#347-前k个高频元素-medium" class="headerlink" title="347. *前k个高频元素(medium)"></a>347. *前k个高频元素(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">https://leetcode.cn/problems/top-k-frequent-elements/</a></p>
</blockquote>
<ul>
<li>首先统计一下数组中各个元素出现的次数.</li>
<li>然后, 用计数排序的思想, 开一个<code>n + 1</code>长度的数组, 数组下标表示出现次数, 这个数组存储出现次数为<code>i</code>的元素有<code>nums[i]</code>种.</li>
<li>然后反向遍历这个计数排序的数组即可得到答案.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x: nums) hash[x] ++;<br><br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, c]: hash) cnt[c] ++;<br><br>        <span class="hljs-type">int</span> i = n, t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (t &lt; k) t += cnt[i --];<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [x, c]: hash)<br>            <span class="hljs-keyword">if</span> (c &gt; i)<br>                ans.<span class="hljs-built_in">push_back</span>(x);<br>        <span class="hljs-keyword">return</span> ans;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="394-字符串解码-medium"><a href="#394-字符串解码-medium" class="headerlink" title="394. *字符串解码(medium)"></a>394. *字符串解码(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/decode-string/">https://leetcode.cn/problems/decode-string/</a></p>
</blockquote>
<ul>
<li>这类题是一种前缀表达式的计算问题, 通用思路是用<code>dfs</code>.
<ul>
<li><code>dfs</code>中, 用一个引用变量<code>u</code>记录处理到表达式的哪个位置.</li>
<li>如果遇到算符, 就需要递归地把运算数计算出来.</li>
<li>如果遇到运算数的一部分, 就需要把所有运算数进行拼接.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    string s;<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string _s)</span> </span>&#123;<br>        s = _s;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(u);<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;u)</span> </span>&#123;<br>        string ans;<br>        <span class="hljs-keyword">while</span> (u &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[u] != <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(s[u])) &#123;<br>               <span class="hljs-type">int</span> k = u;<br>               <span class="hljs-keyword">while</span> (k &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; <span class="hljs-built_in">isdigit</span>(s[k])) k ++;<br>               <span class="hljs-type">int</span> cnt = <span class="hljs-built_in">stoi</span>(s.<span class="hljs-built_in">substr</span>(u, k - u));<br>               u = k + <span class="hljs-number">1</span>;<br>               string res = <span class="hljs-built_in">dfs</span>(u);<br>               u ++; <span class="hljs-comment">// 过滤]</span><br>               <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i ++) ans += res; <br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[u] &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; s[u] &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || s[u] &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; s[u] &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>) ans += s[u ++];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. *分割等和子集"></a>416. *分割等和子集</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-equal-subset-sum/">https://leetcode.cn/problems/partition-equal-subset-sum/</a></p>
</blockquote>
<ul>
<li>这个题本质上是一个背包问题:
<ul>
<li>每一个物品的体积就是<code>a[i]</code>.</li>
<li>总体积是数组和<code>sum / 2</code>.</li>
<li>最终的结果是是否可以满足选的物品体积之和等于<code>sum / 2</code>.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>, n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums) sum += x;<br>        <span class="hljs-keyword">if</span> (sum % <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        sum /= <span class="hljs-number">2</span>;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(sum + <span class="hljs-number">1</span>)</span></span>;<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : nums)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = sum; j &gt;= x; j --) &#123;<br>                f[j] |= f[j - x];<br>            &#125;<br>        <span class="hljs-keyword">return</span> f[sum];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="437-路径总和III-medium"><a href="#437-路径总和III-medium" class="headerlink" title="437. *路径总和III (medium)"></a>437. *路径总和III (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">https://leetcode.cn/problems/path-sum-iii/</a></p>
</blockquote>
<ul>
<li>首先, 这道题类似于前缀和:
<ul>
<li>要求在前缀和数组<code>s</code>中找到<code>l, r</code>, 使得<code>s[r] - s[l - 1] = k</code>.</li>
<li>也就是当遍历到<code>s[i]</code>时, 要在之前的<code>0&lt;= j &lt; i</code>中, 找到一个<code>s[j]</code>, 使得<code>s[j] = s[i] - k</code>.</li>
<li>那么直接在之前用哈希表存储每一个<code>s[j]</code>就可以了, 当遍历到<code>s[i]</code>, 就查有没有符合题意的<code>s[j]</code>.</li>
</ul>
</li>
<li>注意: 前缀和容易超出<code>int</code>范围, 需要用<code>long long</code>存储.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    unordered_map&lt;LL, <span class="hljs-type">int</span>&gt; hash;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-comment">// 0是前缀和中的0位置的元素 </span><br>        hash[<span class="hljs-number">0</span>]++;<br>        <span class="hljs-built_in">dfs</span>(root, targetSum, (LL)<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root, <span class="hljs-type">int</span> sum, LL cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> ;<br>        cur += root-&gt;val;<br>        res += hash[cur - sum];<br>        hash[cur] ++;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;left, sum, cur), <span class="hljs-built_in">dfs</span>(root-&gt;right, sum, cur);<br>        hash[cur] --;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>
<h2 id="438-找到字符串中所有字母异位词-medium"><a href="#438-找到字符串中所有字母异位词-medium" class="headerlink" title="438 *找到字符串中所有字母异位词(medium)"></a>438 *找到字符串中所有字母异位词(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">https://leetcode.cn/problems/find-all-anagrams-in-a-string/</a></p>
</blockquote>
<ul>
<li>思路:
<ul>
<li>判断两个字符串是否是字母异位词的充要条件是: 两个字符串的字符出现种类, 以及次数相同.</li>
<li>直接维护一个<code>p.size()</code>的滑动窗口, 判断滑动窗口内的子串是否和<code>p</code>是字母异位词即可.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string p)</span> </span>&#123;<br>       unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; hash;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : p) hash[c] ++;<br>       <span class="hljs-type">int</span> tot = hash.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// p中有多少种字符</span><br>       <br>       <span class="hljs-comment">// 符合条件的字符种类数目</span><br>       <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>       vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++) &#123;<br>         <span class="hljs-comment">// 处理滑动窗口边界</span><br>            <span class="hljs-keyword">if</span> (i - j + <span class="hljs-number">1</span> &gt; p.<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-keyword">if</span> (hash[s[j]] == <span class="hljs-number">0</span>) k --;<br>                hash[s[j ++]] ++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (--hash[s[i]] == <span class="hljs-number">0</span>) k ++;<br>            <span class="hljs-keyword">if</span> (k == tot) ans.<span class="hljs-built_in">push_back</span>(j);<br>       &#125;<br>       <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="543-二叉树的直径-easy"><a href="#543-二叉树的直径-easy" class="headerlink" title="543. *二叉树的直径(easy)"></a>543. *二叉树的直径(easy)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">https://leetcode.cn/problems/diameter-of-binary-tree/</a></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">dfs</span>(root);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>  <span class="hljs-comment">// dfs的意思是, 从root出发, 包括root, 到达底部的最长路径上节点的个数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> left = <span class="hljs-built_in">dfs</span>(root-&gt;left), right = <span class="hljs-built_in">dfs</span>(root-&gt;right);<br>      <span class="hljs-comment">// 其实应该是left + right  + 1 - 1, +1表示加上root这个点, -1表示求边数</span><br>        ans = <span class="hljs-built_in">max</span>(ans, left + right);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(left, right) + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="560-和为k的子数组-medium"><a href="#560-和为k的子数组-medium" class="headerlink" title="560. *和为k的子数组 (medium)"></a>560. *和为k的子数组 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subarray-sum-equals-k/">https://leetcode.cn/problems/subarray-sum-equals-k/</a></p>
</blockquote>
<ul>
<li>思路: 假设前缀和数组是<code>s</code>, 问题就等价于前缀和数组中是否存在<code>s[r] - s[l - 1] = k</code>, 和两数之和本质相同.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">s</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="hljs-number">1</span>] + nums[i - <span class="hljs-number">1</span>];<br><br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++) &#123;<br>            res += hash[s[i] - k];<br>            hash[s[i]] ++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="739-每日温度-medium"><a href="#739-每日温度-medium" class="headerlink" title="739. *每日温度(medium)"></a>739. *每日温度(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/daily-temperatures/">https://leetcode.cn/problems/daily-temperatures/</a></p>
</blockquote>
<ul>
<li>单调栈问题可以用<svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000" xmlns:xlink="http://www.w3.org/1999/xlink"><defs><path id="MJX-42-TEX-I-1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/><path id="MJX-42-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path id="MJX-42-TEX-I-1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path id="MJX-42-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><use data-c="1D442" xlink:href="#MJX-42-TEX-I-1D442"/></g><g data-mml-node="mo" transform="translate(763,0)"><use data-c="28" xlink:href="#MJX-42-TEX-N-28"/></g><g data-mml-node="mi" transform="translate(1152,0)"><use data-c="1D45B" xlink:href="#MJX-42-TEX-I-1D45B"/></g><g data-mml-node="mo" transform="translate(1752,0)"><use data-c="29" xlink:href="#MJX-42-TEX-N-29"/></g></g></g></svg>的时间复杂度求出一个元素左侧/右侧比他大/小, /具有单调性的最近的元素.</li>
<li>如果要找到右边第一个比他大的元素, 那么在遍历它之前, 就需要有右侧的先验知识, 因此从右向左维护单调栈.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; t)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; stk;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-keyword">while</span> (stk.<span class="hljs-built_in">size</span>() &amp;&amp; t[i] &gt;= t[stk.<span class="hljs-built_in">top</span>()]) stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>())<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">else</span><br>                ans.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>() - i);<br>            stk.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(ans.<span class="hljs-built_in">begin</span>(), ans.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="763-划分字母区间-medium"><a href="#763-划分字母区间-medium" class="headerlink" title="763. *划分字母区间(medium)"></a>763. *划分字母区间(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/partition-labels/">https://leetcode.cn/problems/partition-labels/</a></p>
</blockquote>
<ul>
<li>这道题的本质是区间问题, 对于每一种字符, 都有一个开始和结束位置, 这个位置看成一个一个区间, 最终合并区间就是分割方案.</li>
<li>实际上只需维护一个所有区间能到达的最右范围<code>end</code>, 从前向后遍历, 如果最右范围<code>end = i</code>, 那么就说明<code>[0, i]</code>这一段已经和后面一段不可能产生交集, 因此就可以作为一个合法分割.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> last[<span class="hljs-number">26</span>];<br>        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) last[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br><br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br>            end = <span class="hljs-built_in">max</span>(end, last[s[i] - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>            <span class="hljs-keyword">if</span> (end == i) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(end - start + <span class="hljs-number">1</span>);<br>                start = end = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="994-腐烂的🍊-medium"><a href="#994-腐烂的🍊-medium" class="headerlink" title="994. *腐烂的🍊 (medium)"></a>994. *腐烂的🍊 (medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/rotting-oranges/">https://leetcode.cn/problems/rotting-oranges/</a></p>
</blockquote>
<ul>
<li>多源BFS问题:
<ul>
<li>直接把腐烂的橘子放入队列中宽搜即可.</li>
<li>注意一个逻辑, 在队列中统计的是BFS的层数, 最终的答案应该是层数 - 1, 而且注意, 这个层数- 1应该是建立在队列中一开始有东西的前提下, 如果一开始就没有东西, 那么直接返回0.</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = grid.<span class="hljs-built_in">size</span>(), m = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        queue&lt;PII&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">2</span>)<br>                    q.<span class="hljs-built_in">push</span>(&#123;i, j&#125;);<br>        <br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>()) res --;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-type">int</span> len = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">while</span> (len --) &#123;<br>                <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i ++) &#123;<br>                    <span class="hljs-type">int</span> a = t.x + dx[i], b = t.y + dy[i];<br>                    <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span> || a &gt;= n || b &lt; <span class="hljs-number">0</span> || b &gt;= m || grid[a][b] != <span class="hljs-number">1</span>)<br>                        <span class="hljs-keyword">continue</span>;<br>                    grid[a][b] = <span class="hljs-number">2</span>;<br>                    q.<span class="hljs-built_in">push</span>(&#123;a, b&#125;);<br>                &#125;<br>            &#125;<br>            res ++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j ++)<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<h2 id="1143-最长公共子序列-medium"><a href="#1143-最长公共子序列-medium" class="headerlink" title="1143. *最长公共子序列(medium)"></a>1143. *最长公共子序列(medium)</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-common-subsequence/description/">https://leetcode.cn/problems/longest-common-subsequence/description/</a></p>
</blockquote>
<ul>
<li>设<code>f[i][j]</code>表示<code>a[1:i]</code>, <code>b[1:j]</code>中所有公共子序列中长度的最大值.</li>
<li>那么<code>f[i][j]</code>可以由两种状态转移:
<ul>
<li><code>a[i] == b[j]</code>, 那么<code>f[i][j] = f[i - 1][j - 1] + 1</code>.</li>
<li><code>a[i] != b[j]</code>, 那么<code>f[i][j] = max(f[i - 1][j], f[i][j - 1])</code>.
<ul>
<li>这种情况就是子序列中选<code>a[i]</code>还是选<code>b[j]</code>, 这两部分可能有重叠, 但是对于最大值来讲无妨.</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string text1, string text2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = text1.<span class="hljs-built_in">size</span>(), m = text2.<span class="hljs-built_in">size</span>();<br>        text1 = <span class="hljs-string">&#x27; &#x27;</span> + text1;<br>        text2 = <span class="hljs-string">&#x27; &#x27;</span> + text2;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m + <span class="hljs-number">1</span>));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (text1[i] == text2[j])<br>                    f[i][j] = f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span><br>                    f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        <span class="hljs-keyword">return</span> f[n][m];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

      
       <hr><span style="font-style: italic;color: gray;"> 向阳而生, 喜欢聪明的人. </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©B1ueDrops
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
